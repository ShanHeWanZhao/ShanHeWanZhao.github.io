<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Reef&#39;s Blog</title>
  
  <subtitle>hello world</subtitle>
  <link href="https://blog.shanzhao.site/atom.xml" rel="self"/>
  
  <link href="https://blog.shanzhao.site/"/>
  <updated>2025-02-27T09:11:19.000Z</updated>
  <id>https://blog.shanzhao.site/</id>
  
  <author>
    <name>reef</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Seata — AT模式和TCC模式详细对比</title>
    <link href="https://blog.shanzhao.site/2025-02-23/seata-at-he-tcc-mo-shi-de-xiang-xi-dui-bi/"/>
    <id>https://blog.shanzhao.site/2025-02-23/seata-at-he-tcc-mo-shi-de-xiang-xi-dui-bi/</id>
    <published>2025-02-23T15:01:08.000Z</published>
    <updated>2025-02-27T09:11:19.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;​	深入对比分析了 &lt;strong&gt;AT&lt;/strong&gt; 和 &lt;strong&gt;TCC&lt;/strong&gt; 模式在 &lt;strong&gt;网络 I&amp;#x2F;O&lt;/strong&gt; 和 &lt;strong&gt;锁资源&lt;/strong&gt; 两个方面的性能差异，并根据分析结果提供了选择建议。最后，讨论了 &lt;strong&gt;AT&lt;/strong&gt; 模式在业务中使用不当可能带来的问题，并提出了相应的解决方案&lt;/p&gt;</summary>
    
    
    
    <category term="Seata" scheme="https://blog.shanzhao.site/categories/Seata/"/>
    
    
    <category term="分布式" scheme="https://blog.shanzhao.site/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="分布式事务" scheme="https://blog.shanzhao.site/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
    <category term="AT模式" scheme="https://blog.shanzhao.site/tags/AT%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="TCC模式" scheme="https://blog.shanzhao.site/tags/TCC%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Seata — TCC模式详细分析</title>
    <link href="https://blog.shanzhao.site/2025-02-03/seata-tcc-mo-shi-xiang-xi-fen-xi/"/>
    <id>https://blog.shanzhao.site/2025-02-03/seata-tcc-mo-shi-xiang-xi-fen-xi/</id>
    <published>2025-02-03T12:45:09.000Z</published>
    <updated>2025-02-24T13:32:19.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;​	深入分析了 Seata 的 TCC 模式，通过实际使用案例引出了关键注解的应用。结合 TM、RM 和 TC 的工作流程，剖析了 &lt;code&gt;TccActionInterceptor&lt;/code&gt; 在 try 阶段的实现原理，详细讲解了 &lt;code&gt;TCCResourceManager&lt;/code&gt; 如何处理 commit 和 rollback 操作。同时，解析了 &lt;code&gt;TCC_FENCE_LOG&lt;/code&gt; 表如何保障事务幂等性，并有效解决了悬挂和空回滚等常见问题&lt;/p&gt;</summary>
    
    
    
    <category term="Seata" scheme="https://blog.shanzhao.site/categories/Seata/"/>
    
    
    <category term="分布式" scheme="https://blog.shanzhao.site/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="分布式事务" scheme="https://blog.shanzhao.site/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
    <category term="AT模式" scheme="https://blog.shanzhao.site/tags/AT%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Seata — AT模式二阶段全解析</title>
    <link href="https://blog.shanzhao.site/2025-01-14/seata-at-mo-shi-er-jie-duan-quan-jie-xi/"/>
    <id>https://blog.shanzhao.site/2025-01-14/seata-at-mo-shi-er-jie-duan-quan-jie-xi/</id>
    <published>2025-01-14T04:38:09.000Z</published>
    <updated>2025-01-18T03:27:54.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;​	本文深入解析了 Seata AT 模式下&lt;strong&gt;全局事务的提交与回滚&lt;/strong&gt;机制，详细讲解了 &lt;strong&gt;&lt;code&gt;GlobalTransaction&lt;/code&gt; 提交全局事务&lt;/strong&gt;、&lt;strong&gt;分支事务的异步提交&lt;/strong&gt;以及 &lt;strong&gt;全局回滚的执行流程&lt;/strong&gt;。重点探讨了 &lt;strong&gt;事务协调器（TC）和资源管理器（RM）如何协作完成事务提交与回滚&lt;/strong&gt;。特别是在 &lt;strong&gt;并发控制与数据一致性&lt;/strong&gt; 问题上，展示了 Seata 如何通过 &lt;strong&gt;UndoLog校验&lt;/strong&gt; 机制避免“脏写”问题，并实现&lt;strong&gt;强一致性&lt;/strong&gt;的全局事务回滚&lt;/p&gt;</summary>
    
    
    
    <category term="Seata" scheme="https://blog.shanzhao.site/categories/Seata/"/>
    
    
    <category term="分布式" scheme="https://blog.shanzhao.site/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="分布式事务" scheme="https://blog.shanzhao.site/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
    <category term="AT模式" scheme="https://blog.shanzhao.site/tags/AT%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Seata — AT模式一阶段全解析</title>
    <link href="https://blog.shanzhao.site/2024-12-24/seata-at-mo-shi-yi-jie-duan-quan-jie-xi/"/>
    <id>https://blog.shanzhao.site/2024-12-24/seata-at-mo-shi-yi-jie-duan-quan-jie-xi/</id>
    <published>2024-12-24T10:34:09.000Z</published>
    <updated>2024-12-28T11:13:34.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;​	基于 &lt;strong&gt;Seata 1.7.1&lt;/strong&gt; 源码，本篇文章详细拆解了一阶段分布式事务的执行流程，重点包括 &lt;strong&gt;降级检查策略&lt;/strong&gt;、&lt;strong&gt;undo log 的生成与管理&lt;/strong&gt;、&lt;strong&gt;非本地事务运行模式下的支持&lt;/strong&gt;、&lt;strong&gt;锁冲突检测及重试机制&lt;/strong&gt;，以及一阶段事务如何决定提交或回滚，为理解 AT 模式的核心原理提供了全面解析&lt;/p&gt;</summary>
    
    
    
    <category term="Seata" scheme="https://blog.shanzhao.site/categories/Seata/"/>
    
    
    <category term="分布式" scheme="https://blog.shanzhao.site/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="分布式事务" scheme="https://blog.shanzhao.site/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
    <category term="AT模式" scheme="https://blog.shanzhao.site/tags/AT%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Seata — 核心组件和启动流程</title>
    <link href="https://blog.shanzhao.site/2024-11-15/seata-he-xin-zu-jian-he-qi-dong-liu-cheng/"/>
    <id>https://blog.shanzhao.site/2024-11-15/seata-he-xin-zu-jian-he-qi-dong-liu-cheng/</id>
    <published>2024-11-15T12:34:07.000Z</published>
    <updated>2024-11-27T06:13:07.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;​	基于 &lt;strong&gt;Seata 1.7.1&lt;/strong&gt; 源码，这篇文章算是 AT 模式源码解析的前置内容。文章先从 &lt;strong&gt;自动配置类&lt;/strong&gt; 切入，梳理了客户端核心组件（&lt;strong&gt;TM、RM&lt;/strong&gt;）的职责和初始化流程，接着分析 &lt;strong&gt;AT 模式下 DataSource 代理的实现原理&lt;/strong&gt;，最后再简单介绍了服务端的启动过程以及 &lt;strong&gt;TC 的创建逻辑&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Seata" scheme="https://blog.shanzhao.site/categories/Seata/"/>
    
    
    <category term="分布式" scheme="https://blog.shanzhao.site/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="分布式事务" scheme="https://blog.shanzhao.site/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>CloudFlare-CDN缓存清除</title>
    <link href="https://blog.shanzhao.site/2024-06-14/cloudflare-cdn-huan-cun-qing-chu/"/>
    <id>https://blog.shanzhao.site/2024-06-14/cloudflare-cdn-huan-cun-qing-chu/</id>
    <published>2024-06-14T02:33:50.000Z</published>
    <updated>2025-06-18T12:42:55.855Z</updated>
    
    
    <summary type="html">&lt;hr&gt;
&lt;p&gt;​	给出了一些api用于清除Cloudflare的CDN缓存方式&lt;/p&gt;</summary>
    
    
    
    <category term="cloudflare" scheme="https://blog.shanzhao.site/categories/cloudflare/"/>
    
    
    <category term="cdn缓存清除" scheme="https://blog.shanzhao.site/tags/cdn%E7%BC%93%E5%AD%98%E6%B8%85%E9%99%A4/"/>
    
  </entry>
  
  <entry>
    <title>Redisson — 分布式本地缓存RLocalCachedMap的实现</title>
    <link href="https://blog.shanzhao.site/2023-08-19/redisson-redissonlocalcachedmap/"/>
    <id>https://blog.shanzhao.site/2023-08-19/redisson-redissonlocalcachedmap/</id>
    <published>2023-08-19T09:43:07.000Z</published>
    <updated>2023-08-25T11:34:03.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;​	基于 Redisson 3.16.8，对 &lt;strong&gt;RedissonLocalCachedMap&lt;/strong&gt; 的功能及核心方法进行了深入解析，并重点探讨其关键参数对整体缓存行为的影响，为后续定向优化提供参考&lt;/p&gt;</summary>
    
    
    
    <category term="Redisson" scheme="https://blog.shanzhao.site/categories/Redisson/"/>
    
    
    <category term="分布式" scheme="https://blog.shanzhao.site/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="缓存" scheme="https://blog.shanzhao.site/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>Redisson — 红锁的实现与思考</title>
    <link href="https://blog.shanzhao.site/2023-07-27/redisson-hong-suo-de-shi-xian-yu-si-kao/"/>
    <id>https://blog.shanzhao.site/2023-07-27/redisson-hong-suo-de-shi-xian-yu-si-kao/</id>
    <published>2023-07-27T11:48:03.000Z</published>
    <updated>2023-08-22T14:34:10.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;​	基于 Redisson 3.16.8版本，深入分析了&lt;strong&gt;红锁的设计背景&lt;/strong&gt;及其&lt;strong&gt;在 Redisson 中的实现&lt;/strong&gt;，最后讨论了&lt;strong&gt;红锁的局限性&lt;/strong&gt;，并介绍了可能的替代方案。同时，还详细的分析了 &lt;strong&gt;Redisson 如何通过引入 &lt;code&gt;WAIT&lt;/code&gt; 命令来优化普通分布式锁的可靠性&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Redisson" scheme="https://blog.shanzhao.site/categories/Redisson/"/>
    
    
    <category term="分布式" scheme="https://blog.shanzhao.site/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="红锁" scheme="https://blog.shanzhao.site/tags/%E7%BA%A2%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>Redisson — 分布式锁的实现</title>
    <link href="https://blog.shanzhao.site/2023-06-18/redisson-fen-bu-shi-suo-de-shi-xian/"/>
    <id>https://blog.shanzhao.site/2023-06-18/redisson-fen-bu-shi-suo-de-shi-xian/</id>
    <published>2023-06-18T10:33:03.000Z</published>
    <updated>2023-06-25T12:58:09.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;​	基于 Redisson 3.16.8版本，对互斥型分布式锁的源码做了详细分析，主要包括：&lt;strong&gt;Lua 脚本的加解锁逻辑&lt;/strong&gt;、&lt;strong&gt;看门狗机制的背景与实现&lt;/strong&gt;，以及&lt;strong&gt;如何通过 Redis 的 pub&amp;#x2F;sub 功能配合 JDK Semaphore 来实现线程阻塞与唤醒，从而避免忙等待&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;另外，也简单分析了一下共享型分布式锁的实现思路，比如 &lt;strong&gt;RCountDownLatch 和 RSemaphore&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Redisson" scheme="https://blog.shanzhao.site/categories/Redisson/"/>
    
    
    <category term="分布式" scheme="https://blog.shanzhao.site/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="分布式锁" scheme="https://blog.shanzhao.site/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>Netty（四） — 异步编程的实现和思考</title>
    <link href="https://blog.shanzhao.site/2022-11-19/netty-yi-bu-bian-cheng-zhi-promise/"/>
    <id>https://blog.shanzhao.site/2022-11-19/netty-yi-bu-bian-cheng-zhi-promise/</id>
    <published>2022-11-19T09:58:03.000Z</published>
    <updated>2022-11-24T13:52:09.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;​	分析了 Netty 的 Future 与 Promise 的实现与设计理念，并在此基础上总结了异步编程概念的应用及个人思考&lt;/p&gt;</summary>
    
    
    
    <category term="Netty" scheme="https://blog.shanzhao.site/categories/Netty/"/>
    
    
    <category term="异步编程" scheme="https://blog.shanzhao.site/tags/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Promise" scheme="https://blog.shanzhao.site/tags/Promise/"/>
    
  </entry>
  
  <entry>
    <title>Netty（三） — EventLoopGroup和EventLoop</title>
    <link href="https://blog.shanzhao.site/2022-10-13/netty-eventloop/"/>
    <id>https://blog.shanzhao.site/2022-10-13/netty-eventloop/</id>
    <published>2022-10-13T15:18:03.000Z</published>
    <updated>2022-10-16T11:52:09.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;​	 基于Netty 4.1.34版本，分析了 Netty 中NIO相关的 &lt;strong&gt;EventLoopGroup&lt;/strong&gt; 与 &lt;strong&gt;EventLoop&lt;/strong&gt; 的核心功能和实现原理，重点涵盖了&lt;strong&gt;JDK Selector 的性能瓶颈与 Netty 优化策略&lt;/strong&gt;、&lt;strong&gt;事件循环线程的阻塞与唤醒机制（含空轮询 Bug 修复方案）、IO 事件与任务调度细节&lt;/strong&gt;，并配套流程图直观展示 EventLoop 工作流程&lt;/p&gt;</summary>
    
    
    
    <category term="Netty" scheme="https://blog.shanzhao.site/categories/Netty/"/>
    
    
    <category term="NIO" scheme="https://blog.shanzhao.site/tags/NIO/"/>
    
    <category term="事件循环" scheme="https://blog.shanzhao.site/tags/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
    
  </entry>
  
  <entry>
    <title>Netty（二） — Pipeline和Handler</title>
    <link href="https://blog.shanzhao.site/2022-08-16/netty-pipeline-he-handler/"/>
    <id>https://blog.shanzhao.site/2022-08-16/netty-pipeline-he-handler/</id>
    <published>2022-08-16T13:33:03.000Z</published>
    <updated>2022-08-25T11:58:09.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;​	分析了 Netty 中 &lt;strong&gt;ChannelPipeline、ChannelHandler、ChannelHandlerContext&lt;/strong&gt; 各自的作用和实现原理，重点讲了下&lt;strong&gt;解码器基类 ByteToMessageDecoder 是怎么解决粘包&amp;#x2F;拆包的问题&lt;/strong&gt;以及在&lt;strong&gt;实际使用时该如何考虑&lt;/strong&gt;。最后用一张&lt;strong&gt;流程图总结了这三个核心组件在实际数据处理过程中的组合和协作方式&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Netty" scheme="https://blog.shanzhao.site/categories/Netty/"/>
    
    
    <category term="解码器" scheme="https://blog.shanzhao.site/tags/%E8%A7%A3%E7%A0%81%E5%99%A8/"/>
    
    <category term="责任链模式" scheme="https://blog.shanzhao.site/tags/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Netty（一） — Channel和Unsafe</title>
    <link href="https://blog.shanzhao.site/2022-07-20/netty-channel-he-unsafe/"/>
    <id>https://blog.shanzhao.site/2022-07-20/netty-channel-he-unsafe/</id>
    <published>2022-07-20T11:33:03.000Z</published>
    <updated>2022-07-25T11:58:09.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;​	基于 Netty 4.1.34，从 Channel 的整体架构入手，分析了 Channel 与 Unsafe 的配合机制，以及底层对应的 NIO 实现类。在分析过程中也穿插了对关键方法的说明，最后总结了 Netty Channel 相比原生 JDK Channel 在使用体验和扩展性上的优势。&lt;/p&gt;</summary>
    
    
    
    <category term="Netty" scheme="https://blog.shanzhao.site/categories/Netty/"/>
    
    
    <category term="NIO" scheme="https://blog.shanzhao.site/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot（五） — 嵌入式Tomcat</title>
    <link href="https://blog.shanzhao.site/2022-05-13/springboot-qian-ru-shi-tomcat-de-shi-yong/"/>
    <id>https://blog.shanzhao.site/2022-05-13/springboot-qian-ru-shi-tomcat-de-shi-yong/</id>
    <published>2022-05-13T11:35:03.000Z</published>
    <updated>2022-05-13T11:35:03.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;​	主要分析了嵌入式 Tomcat 的构建流程，重点对比了它&lt;strong&gt;和传统 Tomcat 启动方式的差异&lt;/strong&gt;，也梳理了 SpringBoot 提供的相关扩展点，比如 &lt;strong&gt;ServletContextInitializerBeans 的处理逻辑&lt;/strong&gt;。最后&lt;strong&gt;结合 Tomcat 启动和 Spring 单例 Bean 初始化的整体流程，对延迟绑定端口，以及整个启动顺序背后的依赖关系做了系统性的分析和思考&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="SpringBoot" scheme="https://blog.shanzhao.site/categories/SpringBoot/"/>
    
    
    <category term="嵌入式Tomcat" scheme="https://blog.shanzhao.site/tags/%E5%B5%8C%E5%85%A5%E5%BC%8FTomcat/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot（四） — Condition相关原理</title>
    <link href="https://blog.shanzhao.site/2022-04-21/springboot-conditional-zhu-jie-xiang-guan-yuan-li/"/>
    <id>https://blog.shanzhao.site/2022-04-21/springboot-conditional-zhu-jie-xiang-guan-yuan-li/</id>
    <published>2022-04-21T12:40:03.000Z</published>
    <updated>2022-04-18T11:33:20.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;​	基于Spring Boot 2.7.x 版本，深入分析了&lt;strong&gt;OnBean、OnClass、OnProperty这三类常见Condition的源码实现&lt;/strong&gt;，在此基础上，探讨了 &lt;code&gt;@Conditional&lt;/code&gt; 注解的&lt;strong&gt;组合用法&lt;/strong&gt;（&lt;strong&gt;与、或、非&lt;/strong&gt;逻辑）的处理机制。&lt;/p&gt;
&lt;p&gt;​	同时，分析了&lt;strong&gt;Condition匹配结果的debug支持&lt;/strong&gt;实现，以及 &lt;code&gt;ConfigurationClassPostProcessor&lt;/code&gt; 中&lt;strong&gt;Condition判断的触发流程&lt;/strong&gt;，重点关注其&lt;strong&gt;通过 &lt;code&gt;importedBy&lt;/code&gt; 链支持的 &lt;code&gt;TrackedConditionEvaluator&lt;/code&gt; 回溯与剪枝优化策略&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​	最后，提供了逻辑&lt;strong&gt;或&lt;/strong&gt;&lt;code&gt;@Conditional&lt;/code&gt;组合与 &lt;strong&gt;importedBy路径 skip 判定的测试用例&lt;/strong&gt;，以验证整体逻辑的正确性&lt;/p&gt;</summary>
    
    
    
    <category term="SpringBoot" scheme="https://blog.shanzhao.site/categories/SpringBoot/"/>
    
    
    <category term="Condition" scheme="https://blog.shanzhao.site/tags/Condition/"/>
    
    <category term="回溯" scheme="https://blog.shanzhao.site/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot（三）— 自动配置源码解析</title>
    <link href="https://blog.shanzhao.site/2022-03-26/springboot-zi-dong-pei-zhi-yuan-ma-jie-xi/"/>
    <id>https://blog.shanzhao.site/2022-03-26/springboot-zi-dong-pei-zhi-yuan-ma-jie-xi/</id>
    <published>2022-03-26T14:11:03.000Z</published>
    <updated>2022-04-14T10:45:20.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;​	基于 Spring Boot 2.7.x 版本，深入剖析了 &lt;code&gt;@EnableAutoConfiguration&lt;/code&gt; 注解的实现原理，重点解析了其背后通过 &lt;code&gt;DeferredImportSelector&lt;/code&gt; 实现的自动配置机制。特别对 &lt;code&gt;@AutoConfigureBefore&lt;/code&gt; 与 &lt;code&gt;@AutoConfigureAfter&lt;/code&gt; 所涉及的 &lt;strong&gt;DFS 拓扑排序逻辑&lt;/strong&gt; 进行了详细的分析，揭示了自动配置类加载顺序的核心控制机制&lt;/p&gt;
&lt;p&gt;​	最后，还分析了 2.7.0 版本新增的 &lt;code&gt;@AutoConfiguration&lt;/code&gt; 注解的&lt;strong&gt;特殊语义&lt;/strong&gt;，包括其与&lt;strong&gt;新的 &lt;code&gt;.imports&lt;/code&gt; SPI 文件的绑定&lt;/strong&gt;、&lt;strong&gt;默认排除扫描机制&lt;/strong&gt;（&lt;code&gt;AutoConfigurationExcludeFilter&lt;/code&gt;）。并给出了自己的使用建议&lt;/p&gt;</summary>
    
    
    
    <category term="SpringBoot" scheme="https://blog.shanzhao.site/categories/SpringBoot/"/>
    
    
    <category term="拓扑排序" scheme="https://blog.shanzhao.site/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    
    <category term="自动配置" scheme="https://blog.shanzhao.site/tags/%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot（二）— SPI和starter优化器原理</title>
    <link href="https://blog.shanzhao.site/2022-03-04/springboot-spi-he-starter-you-hua-qi/"/>
    <id>https://blog.shanzhao.site/2022-03-04/springboot-spi-he-starter-you-hua-qi/</id>
    <published>2022-03-04T12:40:03.000Z</published>
    <updated>2022-03-19T11:33:20.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;​	算是一篇SrpingBoot自动配置原理解析的前置文章。首先从源码角度回顾了早期的 &lt;code&gt;spring.factories&lt;/code&gt; SPI 加载机制，接着分析了 Spring Boot 2.7.x 引入的基于注解粒度的 &lt;code&gt;.imports&lt;/code&gt; 文件机制，展示了其在自动配置解耦方面的优势。并介绍了两个常被 starter 使用的辅助组件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;spring-boot-configuration-processor：生成配置元数据，IDE使用&lt;/li&gt;
&lt;li&gt;spring-boot-autoconfigure-processor：加速自动配置加载&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;​	最后，结合自定义 starter 的实践，附上了完整的测试用例，验证上述机制在实际开发中的可用性&lt;/p&gt;</summary>
    
    
    
    <category term="SpringBoot" scheme="https://blog.shanzhao.site/categories/SpringBoot/"/>
    
    
    <category term="starter" scheme="https://blog.shanzhao.site/tags/starter/"/>
    
    <category term="SPI" scheme="https://blog.shanzhao.site/tags/SPI/"/>
    
  </entry>
  
  <entry>
    <title>Spring-事物NOT_SUPPORTED策略下多数据源切换的问题</title>
    <link href="https://blog.shanzhao.site/2022-03-03/spring-shi-wu-not-supported-ce-lue-xia-duo-shu-ju-yuan-qie-huan-de-wen-ti/"/>
    <id>https://blog.shanzhao.site/2022-03-03/spring-shi-wu-not-supported-ce-lue-xia-duo-shu-ju-yuan-qie-huan-de-wen-ti/</id>
    <published>2022-03-03T10:34:17.000Z</published>
    <updated>2022-03-03T10:34:17.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;​	从案例中分析了NOT_SUPPORTED默认情况下为什么不能进行多数据源切换以及优雅的解决办法，以及给出了自己的思考&lt;/p&gt;</summary>
    
    
    
    <category term="Spring" scheme="https://blog.shanzhao.site/categories/Spring/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot（一）— fatJar启动和LaunchedURLClassLoader加载class的原理</title>
    <link href="https://blog.shanzhao.site/2022-02-15/springboot-fatjar-qi-dong-he-launchedurlclassloader-jia-zai-class-de-yuan-li/"/>
    <id>https://blog.shanzhao.site/2022-02-15/springboot-fatjar-qi-dong-he-launchedurlclassloader-jia-zai-class-de-yuan-li/</id>
    <published>2022-02-15T13:16:27.000Z</published>
    <updated>2022-02-17T07:33:23.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;​	基于 Spring Boot 2.7.x，从整体架构角度出发，梳理并串联了 fatjar 模式下的关键组件：&lt;code&gt;Archive&lt;/code&gt;、&lt;code&gt;JarFile&lt;/code&gt;、&lt;code&gt;JarEntry&lt;/code&gt;、&lt;code&gt;Handler&lt;/code&gt;、&lt;code&gt;JarURLConnection&lt;/code&gt;，重点&lt;strong&gt;分析它们在类加载过程中的职责与协作关系&lt;/strong&gt;。全文&lt;strong&gt;不聚焦具体 jar 包结构解析细节，而是深入源码层面解析 fatjar 启动流程及 &lt;code&gt;LaunchedURLClassLoader#loadClass&lt;/code&gt; 实现机制&lt;/strong&gt;，并辅以实际测试用例进行debug和验证。&lt;/p&gt;</summary>
    
    
    
    <category term="SpringBoot" scheme="https://blog.shanzhao.site/categories/SpringBoot/"/>
    
    
    <category term="fatjar" scheme="https://blog.shanzhao.site/tags/fatjar/"/>
    
    <category term="LaunchedURLClassLoader" scheme="https://blog.shanzhao.site/tags/LaunchedURLClassLoader/"/>
    
    <category term="URLClassLoader" scheme="https://blog.shanzhao.site/tags/URLClassLoader/"/>
    
    <category term="类加载器" scheme="https://blog.shanzhao.site/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat-Session管理</title>
    <link href="https://blog.shanzhao.site/2022-01-09/tomcat-session-guan-li/"/>
    <id>https://blog.shanzhao.site/2022-01-09/tomcat-session-guan-li/</id>
    <published>2022-01-09T06:13:33.000Z</published>
    <updated>2022-01-14T11:09:20.000Z</updated>
    
    
    <summary type="html">&lt;hr&gt;
&lt;p&gt;​	本文从源码出发，剖析 Tomcat 中 Session 的懒加载、保活与生命周期控制机制，并解析了 StandardManager 如何借助序列化完成热部署场景下的 Session 持久化与自动恢复&lt;/p&gt;</summary>
    
    
    
    <category term="Tomcat" scheme="https://blog.shanzhao.site/categories/Tomcat/"/>
    
    
  </entry>
  
</feed>
