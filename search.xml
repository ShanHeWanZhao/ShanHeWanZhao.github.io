<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>java源码</title>
      <link href="/2025/03/08/java-yuan-ma/"/>
      <url>/2025/03/08/java-yuan-ma/</url>
      
        <content type="html"><![CDATA[<h1 id="1-HashMap"><a href="#1-HashMap" class="headerlink" title="1.HashMap"></a>1.HashMap</h1><p>重点字段：</p><ul><li><p>DEFAULT_LOAD_FACTOR&#x3D;0.75</p><blockquote><p>​默认加载因子。loadFactor加载因子是控制数组存放数据的疏密程度，loadFactor越趋近于1，那么 数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor越小，也就是趋近于0，数组中存放的数据(entry)也就越少，也就越稀疏。</p><p>​loadFactor太大可能导致链表过长，查找元素效率低。而太小导致数组的空闲空间太多，利用率低，存放的数据会很分散。</p><p>​loadFactor的默认值为0.75f是官方给出的一个比较好的临界值。</p></blockquote></li><li><p>TREEIFY_THRESHOLD&#x3D;8</p><blockquote><p>树化阈值。当桶(bucket)上的结点数大于这个值时会转成红黑树</p></blockquote></li><li><p>UNTREEIFY_THRESHOLD&#x3D;6</p><blockquote><p>链表化阈值（当桶(bucket)上的结点数小于这个值时树转链表）</p></blockquote></li><li><p>MIN_TREEIFY_CAPACITY&#x3D;64</p><blockquote><p>桶中结构树化对应的table的最小长度</p></blockquote></li><li><p>loadFactor&#x3D;0.75</p><blockquote><p>计算阈值使用，必须大于0</p></blockquote></li><li><p>threshold &#x3D; loaloadFactor * 数组长度</p><blockquote><p>扩容阈值，当HashMap拥有的元素数量大于了threshold，就会触发数组的扩容</p></blockquote></li></ul><h2 id="1-1-put方法："><a href="#1-1-put方法：" class="headerlink" title="1.1 put方法："></a>1.1 put方法：</h2><ul><li>如果是第一次添加元素，先初始化数组，在计算索引位置直接放入就行</li><li>计算索引后，数组中对应的那个bucket不存在，直接放到这个bucket</li><li>计算索引后，数组中对应的那个bucket存在<ul><li>equals根节点，直接替换</li><li>根节点为树形节点，代表已经树化，调用红黑树来放节点</li><li>以此遍历这个bucket链表，如果equals，直接替换。否则遍历到链表的末尾，再根据当前链表的长度来决定是放在末尾还是红黑树化<ul><li>红黑树化要求：链表的长度（算上bucket）已经大于等于了8且数组长度大于64</li></ul></li></ul></li></ul><h2 id="1-2-resize方法："><a href="#1-2-resize方法：" class="headerlink" title="1.2 resize方法："></a>1.2 resize方法：</h2><p><strong>HashMap数组的长度始终为2的次幂，且扩容时都是长度加倍。原因就是方便扩容</strong></p><blockquote><p> 试想一下，现要扩容一个已经有链表结构的数组:</p><p> ​先创建一个长度为2倍的新数组。</p><p> ​如果原数组某一个bucket（数组中的一个位置）为空或只有一个元素，不具备链表结构，那么这个bucket很好计算。</p><p> ​如果一个bucket已经有链表的结构了，那么计算当前Node在新数组的索引方法：当前Node中key的hash值 &amp; （新数组长度 - 1），因为新数组的长度始终是2的次幂，且是旧数组的2倍。所以这个计算出来的新索引要么是原索引，要么就是原索引的2倍（只取决于key的hash高一位是不是0），计算索引的核心方法如下。所以，将链表结构的bucket重新分配到新数组中就简单很多了</p></blockquote><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// e.hash &amp; oldCap == 0 就代表e的hash值（转换为2进制）高一位为0，</span><span class="token comment" spellcheck="true">// 与（新的容量-1）相与后，其在数组的索引位置不变</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> oldCap<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">==</span> null<span class="token punctuation">)</span>        loHead <span class="token operator">=</span> e<span class="token punctuation">;</span>    <span class="token keyword">else</span>        loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>    loTail <span class="token operator">=</span> e<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 这里则高一位为1，与新的容量 &amp; 后，</span>     <span class="token comment" spellcheck="true">// 其在新数组的索引位置会增加新容量的扩大值（即原容量的大小）</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">==</span> null<span class="token punctuation">)</span>        hiHead <span class="token operator">=</span> e<span class="token punctuation">;</span>    <span class="token keyword">else</span>        hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>    hiTail <span class="token operator">=</span> e<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-3-线程不安全"><a href="#1-3-线程不安全" class="headerlink" title="1.3 线程不安全"></a>1.3 线程不安全</h2><p>当两个线程同时put数据时，且被put的两个数据能定位到HashMap数组的相同那个bucket位置上，就可能产生一个覆盖掉另一个的可能，造成一个数据消失。</p><p><img src="/img/hashmap_concurrent.png"></p><p>如上如，当两个线程同时到达红框位置，且放在一个bucket里，就会出现被覆盖，导致一个放入的数据消失了</p><h1 id="2-LinkedHashMap"><a href="#2-LinkedHashMap" class="headerlink" title="2. LinkedHashMap"></a>2. LinkedHashMap</h1><p>LinkedHashMap既是Map，有具有排序功能，根据accessOrder的值来排序</p><p>重点字段：</p><ul><li><p>head：连接头节点</p></li><li><p>tail：链表为节点</p></li><li><p>accessOrder（默认false）：</p><blockquote><p> false: 表示按照放入顺序排序，越晚放入的元素就越排在后面。</p><p> true：按访问时间排序。最近一个被访问的数据将会排在链表末尾</p></blockquote></li></ul><h2 id="2-1-排序如何实现"><a href="#2-1-排序如何实现" class="headerlink" title="2.1 排序如何实现"></a>2.1 排序如何实现</h2><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">HashMap<span class="token punctuation">.</span>Node</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 具有链表结构的Entry</span>    <span class="token comment" spellcheck="true">// 前一个节点和后一个节点</span>    Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> before<span class="token punctuation">,</span> after<span class="token punctuation">;</span>    <span class="token function">Entry</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>LinkedHashMap的Entry新增了<strong>before节点和after节点，所以是个双向链表结构。</strong></p><p>并重写了<strong>java.util.HashMap#newNode</strong>和<strong>java.util.LinkedHashMap#afterNodeAccess</strong>方法</p><p><strong>新节点添加到末尾</strong>：newNode方法在构造新节点时使用，会将当前结点设为tail</p><p><strong>最近一次被访问的节点移动到末尾</strong>：如果accessOrder为true，那么从map里获取数据时，会触发afterNodeAccess，将当前节点设置到tail。</p><p>LinkedHashMap并设计了很多内部的遍历器，在用map的遍历方法时，负责按顺序取出数据</p><h1 id="3-ConcurrentHashMap"><a href="#3-ConcurrentHashMap" class="headerlink" title="3. ConcurrentHashMap"></a>3. ConcurrentHashMap</h1><p>利用CAS和加锁，实现线程安全的Map数据结构</p><p>ConcurrentHashMap的数据结构和HashMap差不多，也是数组+链表实现，当链表长度大于8转化为红黑树，红黑树长度小于6退化为链表</p><h2 id="3-1-put方法"><a href="#3-1-put方法" class="headerlink" title="3.1 put方法"></a>3.1 put方法</h2><p>死循环put元素，直到操作成功才退出</p><ul><li>数组还没初始化，开始数组的初始化</li><li>数组的bucket还未被占用，CAS占用（成功了就break，失败了就代表已经被其他节点占用了，进行下一次循环进入其他if分支）</li><li>有线程正在进行扩容操作，则先帮助扩容</li><li>bucket被占用，锁住根节点，开始构造到链表的为尾节点。添加到尾节点后，在判断当前链表长度是否超过8，否则就转换为红黑树</li></ul><h2 id="3-2-为什么key和value不允许为null，而HashMap可以呢？"><a href="#3-2-为什么key和value不允许为null，而HashMap可以呢？" class="headerlink" title="3.2 为什么key和value不允许为null，而HashMap可以呢？"></a>3.2 为什么key和value不允许为null，而HashMap可以呢？</h2><blockquote><p><strong>ConcurrentHashMap如果允许key和value为null，会产生二义性</strong>。即不能确定map里本身没有这个数据，还是说有这个数据，但这个数据存的是null值。</p><p>为什么HashMap可以允许呢？因为它不会产生二义性，使用<strong>HashMap默认就是单线程下，假设我们获取key为A的数据返回了null，之后还马上可以通过containsKey来判断到底是不存在A还是A就为null（因为是单线程，不用担心其他线程会修改数据）</strong></p><p>但ConcurrentHashMap是线程安全的，也就是默认会在多线程下修改数据。假设ConcurrentHashMap支持设置null，这时线程A获取key为null的数据返回了null，此时我们不确定A在不在ConcurrentHashMap里，需要用containsKey来判断key为null是否存在于ConcurrentHashMap里。但多线程的情况下，B线程在A线程containsKey操作前添加了key为null的数据，导致A线程containsKey返回了true，导致和第一步预期不同（第一步可能是不存在key为null的数据）</p><p>综上：<strong>ConcurrentHashMap，它是为并发而生的，它是要用在并发场景中的，当我们 map.get(key)返回 null 的时候，是没办法通过 map.containsKey来准确的检测，因为在检测过程中可能会被其他线程锁修改，而导致检测结果并不可靠。</strong></p></blockquote><h1 id="4-LockSupport"><a href="#4-LockSupport" class="headerlink" title="4. LockSupport"></a>4. LockSupport</h1><p>​java中实现<strong>当前线程的阻塞和定时阻塞</strong>，并提供<strong>唤醒指定线程</strong>的工具，在内部使用sun.misc.Unsafe来实现这一系列的操作。在AQS中普遍被使用</p><p>部分核心方法：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 唤醒指定的线程（如果该线程被park了） * 如果线程先被unpark（解除等待）了，那么该线程下一次调用park(进入等待)则不起作用 */</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">unpark</span><span class="token punctuation">(</span>Thread thread<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>thread <span class="token operator">!=</span> null<span class="token punctuation">)</span>        UNSAFE<span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 阻塞当前线程，并设置一个阻塞器（这个只是用来jstack查看，并不能通过notifyAll来唤醒阻塞的线程） */</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">park</span><span class="token punctuation">(</span>Object blocker<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Thread t <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">setBlocker</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> blocker<span class="token punctuation">)</span><span class="token punctuation">;</span>    UNSAFE<span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> 0L<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">setBlocker</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 定时等待，阻塞当前线程指定的纳秒数，当时间到达时就自动唤醒（定时任务会调用） */</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">parkNanos</span><span class="token punctuation">(</span><span class="token keyword">long</span> nanos<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nanos <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>        UNSAFE<span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> nanos<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 定时等待，阻塞当前线程直到指定的时间戳（deadline）到来就自动唤醒（定时任务会调用） */</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">parkUntil</span><span class="token punctuation">(</span><span class="token keyword">long</span> deadline<span class="token punctuation">)</span> <span class="token punctuation">{</span>    UNSAFE<span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> deadline<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="5-AbstractQueuedSynchronizer"><a href="#5-AbstractQueuedSynchronizer" class="headerlink" title="5.AbstractQueuedSynchronizer"></a>5.AbstractQueuedSynchronizer</h1><p>重要的内部数据结构Node:</p><p>​Node是一个通用的数据结构，既充当同步队列节点，也充当等待队列的节点</p><ul><li><strong>同步队列</strong>：<strong>当线程尝试获取锁时，未获取到锁的线程会被构造成一个Node，利用CAS放入同步尾部作为尾节点，等待被唤醒。同步队列关联的是整个锁，一对一的关系。而同步队列中的Node又根据nextWaiter字段判断当前Node是共享节点还是独占节点</strong><ul><li><strong>共享节点：共享锁的实现（Semaphore、CountDownLatch等）。nextWaiter字段为固定的Node#SHARED。释放当前节点的线程后，还具有向后传播的能力（根据state的值判断是否需要释放后继共享节点里的线程）</strong></li><li><strong>互斥节点：互斥锁的实现（ReentrantLock等），nextWaiter字段为Node#EXCLUSIVE（即null），只会释放当前节点里的线程</strong></li></ul></li><li><strong>等待队列</strong>：当已经获取到锁的线程触发<strong>java.util.concurrent.locks.Condition#await()<strong>方法阻塞自己，让出锁时。</strong>会将当前线程构造成一个Node（等待节点，状态为CONDITION），利用CAS放入等待队列尾部。等待队列关联的是Condition。所以，当ReentrantLock构造多个Condition时，就有多个等待队列，ReentrantLock和等待队列可以为一对多，而Condition和等待队列时一对一</strong>。而<strong>当其他线程获取当前锁（ReentrantLock）的线程调用java.util.concurrent.locks.Condition#signal等方法时，便会将等待队列的首节点转入到同步队列的尾节点，并重新设置Node的状态</strong><ul><li><strong>等待节点：nextWaiter字段为等待队列中下一个等待节点的指针</strong></li></ul></li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 共享锁</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> Node SHARED <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 互斥锁</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> Node EXCLUSIVE <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//  取消获取锁</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> CANCELLED <span class="token operator">=</span>  <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> SIGNAL    <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 等待condition唤醒（等待队列才会用到这个状态）</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> CONDITION <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> PROPAGATE <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 当前节点的状态</span>    <span class="token keyword">volatile</span> <span class="token keyword">int</span> waitStatus<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 同步队列专用</span>    <span class="token keyword">volatile</span> Node prev<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 同步队列专用</span>    <span class="token keyword">volatile</span> Node next<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 等待线程</span>    <span class="token keyword">volatile</span> Thread thread<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 1. 当前Node为同步队列中的共享节点时：SHARED</span>    <span class="token comment" spellcheck="true">// 2. 当前Node为同步队列中的独占节点时：null</span>    <span class="token comment" spellcheck="true">// 3. 当前Node为等待队列中的节点时：下一个等待节点的指针</span>    Node nextWaiter<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 判断当前节点是互斥锁，还是共享锁</span>    <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">isShared</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> nextWaiter <span class="token operator">==</span> SHARED<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 当前节点的前驱结点</span>    <span class="token keyword">final</span> Node <span class="token function">predecessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> NullPointerException <span class="token punctuation">{</span>        Node p <span class="token operator">=</span> prev<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> null<span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token keyword">return</span> p<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Used to establish initial head or SHARED marker</span>    <span class="token punctuation">}</span>    <span class="token function">Node</span><span class="token punctuation">(</span>Thread thread<span class="token punctuation">,</span> Node mode<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// Used by addWaiter</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>nextWaiter <span class="token operator">=</span> mode<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>thread <span class="token operator">=</span> thread<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">Node</span><span class="token punctuation">(</span>Thread thread<span class="token punctuation">,</span> <span class="token keyword">int</span> waitStatus<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// Used by Condition</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>waitStatus <span class="token operator">=</span> waitStatus<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>thread <span class="token operator">=</span> thread<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关键字段和方法：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 同步队列专属的头尾节点。</span><span class="token comment" spellcheck="true">// 因为只有在同步队列里的线程才需要被唤醒。等待队列里的线程如果要被唤醒，需要先加入到同步队列</span><span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> Node head<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> Node tail<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 可获取到锁的次数</span><span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> state<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 自旋的阈值（纳秒）。当超时等待时间小于这个值时，就不会再暂停线程，而是自旋。因为这个时间已经很少了，考虑到阻塞线程后上线文切换会消耗时间，就没必要再阻塞了</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> spinForTimeoutThreshold <span class="token operator">=</span> 1000L<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 获取到独占锁的线程</span><span class="token keyword">private</span> <span class="token keyword">transient</span> Thread exclusiveOwnerThread<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**    留给子类实现的尝试获取共享锁的方法，共享锁获取，返回AQS里state的剩余值     1：返回值 > 0，代表当前线程获取成功，且state还有剩余值，表示可以继续传播给下一个共享节点线程，让其尝试获取锁     2：返回值 = 0，代表当前线程获取成功，但state值刚好被用完，那么下一个共享节点线程就不应该被唤醒了（因为这时已经获取不到state的剩余值了）    3：返回值 &lt; 0，代表当前线程都没获取成功，直接获取失败，阻塞等待被其他线程唤醒后在尝试获取*/</span><span class="token keyword">protected</span> <span class="token keyword">int</span> <span class="token function">tryAcquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UnsupportedOperationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 获取共享锁</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">doAcquireSharedInterruptibly</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span>    <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    <span class="token keyword">final</span> Node node <span class="token operator">=</span> <span class="token function">addWaiter</span><span class="token punctuation">(</span>Node<span class="token punctuation">.</span>SHARED<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> failed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">final</span> Node p <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">predecessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> head<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 首节点的下个节点才有资格获取锁（首节点就是获取到锁的节点）</span>                <span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token function">tryAcquireShared</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 至少当前线程获取成功了，但可能state值已经被用完了</span>                    <span class="token comment" spellcheck="true">// 获取成功，传播给下一个共享Node，根据state的剩余值来判断是否需要唤醒下一个共享Node里的线程</span>                    <span class="token function">setHeadAndPropagate</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>                    p<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// help GC</span>                    failed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> node<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 不能获取到锁线程就park</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>failed<span class="token punctuation">)</span>            <span class="token function">cancelAcquire</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 释放共享锁（Semaphore会使用）</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">doReleaseShared</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Node h <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> h <span class="token operator">!=</span> tail<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> ws <span class="token operator">=</span> h<span class="token punctuation">.</span>waitStatus<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">==</span> Node<span class="token punctuation">.</span>SIGNAL<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> Node<span class="token punctuation">.</span>SIGNAL<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// loop to recheck cases</span>                <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>                     <span class="token operator">!</span><span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> Node<span class="token punctuation">.</span>PROPAGATE<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// loop on failed CAS</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">==</span> head<span class="token punctuation">)</span>                   <span class="token comment" spellcheck="true">// loop if head changed</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*    将目标节点（参数node）设为同步队列的尾部（使用CAS来解决并发问题）。    所以，在这整个过程中，链表中除首节点外其余节点的prev在任何时刻都不会为空；        但除尾节点外其余节点的next字段有可能为空 （刚好走完第②步，还没走到第③步）*/</span><span class="token keyword">private</span> Node <span class="token function">enq</span><span class="token punctuation">(</span><span class="token keyword">final</span> Node node<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Node t <span class="token operator">=</span> tail<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 初始化同步队列，设置一个空Node为首尾节点</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetHead</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                tail <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            node<span class="token punctuation">.</span>prev <span class="token operator">=</span> t<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 先将目标节点的prev设置程原尾节点 ①</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetTail</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// CAS设置尾节点 ②</span>                t<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 设置成功了，才把原尾节点的next设为目标节点（现尾节点）③</span>                <span class="token keyword">return</span> t<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 唤醒目标节点（参数node）的最近下一个可唤醒节点中的线程</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span>Node node<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> ws <span class="token operator">=</span> node<span class="token punctuation">.</span>waitStatus<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> ws<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 首节点的下个节点唤醒失败时，就从尾节点向前遍历，直到找到距首节点最近的可唤醒的节点</span>    <span class="token comment" spellcheck="true">// 目的是避免并发时（节点入队列和唤醒），倒数第二个节点（甚至不止）的next字段为空，导致拿不到其实已经入队列里的后续节点</span>    Node s <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> null <span class="token operator">||</span> s<span class="token punctuation">.</span>waitStatus <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        s <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Node t <span class="token operator">=</span> tail<span class="token punctuation">;</span> t <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> t <span class="token operator">!=</span> node<span class="token punctuation">;</span> t <span class="token operator">=</span> t<span class="token punctuation">.</span>prev<span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span>waitStatus <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>                s <span class="token operator">=</span> t<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">!=</span> null<span class="token punctuation">)</span>        LockSupport<span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="6-ReentrantLock"><a href="#6-ReentrantLock" class="headerlink" title="6.ReentrantLock"></a>6.ReentrantLock</h1><p>以ReentrantLock为例，分析公平锁和非公平锁的实现。</p><p>因为ReentrantLock是互斥锁，所以只允许一个线程获取到锁，所以AQS的state初始值为1，当获取到锁的线程尝试重入时，便会增加state。</p><h2 id="6-1-非公平锁（NonfairSync）："><a href="#6-1-非公平锁（NonfairSync）：" class="headerlink" title="6.1 非公平锁（NonfairSync）："></a>6.1 非公平锁（NonfairSync）：</h2><p>lock（加锁过程）：</p><ul><li>java.util.concurrent.locks.ReentrantLock.Sync#nonfairTryAcquire：利用CAS尝试设置state，能设置成功，代表获取到锁，成功返回。设置失败，代表已经被其他线程获取了锁，返回失败</li><li>返回失败后：<ul><li>将当前线程构造为Node节点，设置到同步队列的链表中</li><li>进入到<strong>java.util.concurrent.locks.AbstractQueuedSynchronizer#acquireQueued</strong>方法：死循环获取当前Node的前一个节点（<strong>同步队列的首节点是成功获取到锁的节点</strong>），如果前驱结点为首节点，当前Node才有资格获取锁。如果还是获取不到，就调用<strong>java.util.concurrent.locks.LockSupport#park</strong>(java.lang.Object)方法阻塞当前线程，等待其他线程唤醒再去竞争锁</li></ul></li></ul><p>unlock（释放锁）：</p><ul><li>java.util.concurrent.locks.ReentrantLock.Sync#tryRelease：复原state（将其归0），exclusiveOwnerThread设为null</li><li>java.util.concurrent.locks.AbstractQueuedSynchronizer#release：在tryRelease成功后，使用<strong>java.util.concurrent.locks.LockSupport#unpark</strong>方法唤醒同步队列首节点的下一个节点里的线程，让他再去尝试获取锁</li></ul><h2 id="6-2-公平锁（FairSync）："><a href="#6-2-公平锁（FairSync）：" class="headerlink" title="6.2 公平锁（FairSync）："></a>6.2 公平锁（FairSync）：</h2><p>lock（加锁过程）：</p><p>和非公平锁很像，不同的部分就在覆盖了<strong>java.util.concurrent.locks.AbstractQueuedSynchronizer#tryAcquire</strong>这个方法和非公平锁略有不同。在新的线程获取锁失败，并将自己构造为Node节点并放入同步队列链表后，还会通过调用<strong>java.util.concurrent.locks.AbstractQueuedSynchronizer#hasQueuedPredecessors</strong>方法</p><pre class="line-numbers language-java"><code class="language-java"> <span class="token comment" spellcheck="true">/** 查询是否有线程等待获取的时间长于当前线程 * 判断是否存在队列中第二个Node(因为首节点是个空节点)，且第二个节点中的线程是否是当前线程 * 也就是说：判断同步队列中当前节点是否有前驱结点 * true:代表当前线程不是等待最久的线程或压根就没有等待的线程 * false:在代表当前线程已经是等待最久的线程（毕竟队列越前面，则代表进去的越久）&lt;p/> * 只有公平锁才需要用到这个方法，来判断当前线程是否等待时间最长 */</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">hasQueuedPredecessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node t <span class="token operator">=</span> tail<span class="token punctuation">;</span>     Node h <span class="token operator">=</span> head<span class="token punctuation">;</span>    Node s<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 用 h != t 来做判断是因为调用这个方法的线程此时还没有进入等待队列</span>    <span class="token comment" spellcheck="true">// 如果 h != t，则代表队列中有线程在等待获取锁</span>    <span class="token keyword">return</span> h <span class="token operator">!=</span> t <span class="token operator">&amp;&amp;</span>        <span class="token punctuation">(</span><span class="token punctuation">(</span>s <span class="token operator">=</span> h<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">||</span> s<span class="token punctuation">.</span>thread <span class="token operator">!=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>来测试当前线程是否是等待最久的线程（也就是同步队列是否还有其他等待节点，因为新加的节点总是插入到队尾，弹出是总是从队首弹出，先进先出</strong>），如果是等待最近的线程，才有资格尝试获取锁</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// ReentrantLock的公平锁第一次尝试获取锁</span><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> Thread current <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">hasQueuedPredecessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token comment" spellcheck="true">// 测试当前线程是否是等待最久的线程</span>                <span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> acquires<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">==</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> nextc <span class="token operator">=</span> c <span class="token operator">+</span> acquires<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nextc <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Maximum lock count exceeded"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">setState</span><span class="token punctuation">(</span>nextc<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>unlock（释放锁）：和非公平锁一样</p><h2 id="6-3-总结"><a href="#6-3-总结" class="headerlink" title="6.3 总结"></a>6.3 总结</h2><h3 id="6-3-1-为什么叫公平锁和非公平锁"><a href="#6-3-1-为什么叫公平锁和非公平锁" class="headerlink" title="6.3.1 为什么叫公平锁和非公平锁"></a>6.3.1 为什么叫公平锁和非公平锁</h3><p>​根据上面的分析，<strong>公平锁在获取锁是总是会先判断当前线程是否是等待最久的线程</strong>。<strong>所以，就算是同步队列存在大量Node，且有线程第一次在获取锁，那么，下一次获取到锁的线程也一定是同步队列的首节点的下一个节点（首节点就是当前获取到锁的节点，只有获取成功了，同步才会更新首节点）</strong></p><p>​<strong>非公平锁中：对于已经进入同步队列的线程来说，也只能首节点的下一个节点里的线程能尝试获取锁。但对于还未构造成Node加入到同步队列的线程来说，这个线程和首节点的下一个节点里的线程能竞争获取锁</strong>，所以非公平。<strong>但对于已经进入同步队列的线程来说，前驱结点是一定比后面的节点先获取到锁的</strong></p><h3 id="6-3-2-各自优势"><a href="#6-3-2-各自优势" class="headerlink" title="6.3.2 各自优势"></a>6.3.2 <strong>各自优势</strong></h3><ul><li>公平锁：防止线程饥饿，分散性很好</li><li>非公平锁：更快。一是<strong>获取锁是不用判断当前线程是否是等待最久的线程</strong>。二是<strong>上下文交换没有公平锁频繁</strong>。在存在大量锁竞争的前提下，可以肯定，公平锁上下文切换很频繁，获取锁后的线程再次获取锁时是一定会阻塞的。而非公平锁则不一样，下一次获取到锁的线程仍可能是上一次获取到锁的线程，没有上下文切换</li></ul><h1 id="7-CountDownLatch"><a href="#7-CountDownLatch" class="headerlink" title="7.CountDownLatch"></a>7.CountDownLatch</h1><p>CountDownLatch为共享锁实现，只能使用一次。用来“卡点”，阻塞的线程需要等待其他线程准备好了后（countDown直到AQS里的state为0），才继续被唤醒执行后面的代码。</p><p>在CountDownLatch中，AQS里的state值并不表示可获取到锁的次数，而是<strong>java.util.concurrent.CountDownLatch#countDown</strong> state值的次数后会释放所有调用了**java.util.concurrent.CountDownLatch#await()**的线程</p><p>内部的同步器Sync主要方法</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**    获取共享锁，只有AQS的state为0才能获取到    通过这个接口就可以猜到，当state为0时（拉下了所有门闩），总会返回1，代表获取锁成功。    并依次传播下去递归调用这个方法，直到同步队列的所有Node里的线程全部唤醒，这就是CountDownLatch的原理*/</span><span class="token keyword">protected</span> <span class="token keyword">int</span> <span class="token function">tryAcquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 释放共享锁，state第一次被减为0才释放成功，也就表示了CountDownLatch只能用一次</span><span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryReleaseShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> releases<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Decrement count; signal when transition to zero</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> nextc <span class="token operator">=</span> c<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> nextc<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> nextc <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>await方法会阻塞当前线程，直到其他线程“拉下所有门闩”。阻塞的线程会构造为共享节点加入同步队列，只有队首节点的下一个节点才有资格尝试获取锁，获取不到就LockSupport#park</p><p>countDown会将state值减小1，当state将为0时，释放同步队列里的第二个共享节点里的线程。当这个线程释放后，就能成功获取到锁了，将这个事件传播下去，一次唤醒同步队列里的所有共享节点。至此，所有被阻塞的线程都被唤醒且会成功获取到锁，最终从await方法里返回</p><h1 id="8-Semaphore"><a href="#8-Semaphore" class="headerlink" title="8.Semaphore"></a>8.Semaphore</h1><p>​<strong>信号量，共享锁实现。可以利用构造器指定令牌（permits）的数量。当线程到达时，获取（acquire）指定数量的令牌，当没有可用令牌（premits为0）时，阻塞线程，等待令牌的释放（release）再被唤醒后继续执行。基于此，即可实现共享锁（permits大于1），也可实现不可重入的互斥锁（permits为1）</strong></p><p>也分为公平锁和分公平锁，其判断方式完全和ReentrantLock一致。</p><p>​<strong>非公平锁允许准备进入同步块的线程（还未加入同步队列）和同步队列中的第二个节点竞争获取锁。而公平锁则只允许同步队列中第二个节点里的线程能尝试获取锁。</strong></p><p>​<strong>其实现方式就是将state设为我们允许并发运行的线程数量，每当一个线程获取到锁后，将state - 1，如果state为0则阻塞所有准备进入同步块的线程，并将其构造为共享节点加入同步队列。每当有线程从同步块退出时，将state + 1，并根据是否非公平来唤醒同步队列的第二个节点来尝试获取锁</strong></p><h1 id="9-Condition接口"><a href="#9-Condition接口" class="headerlink" title="9.Condition接口"></a>9.Condition接口</h1><p><strong>等待通知接口，代替Object原生的wait和notify，其具体实现为AQS里的ConditionObject</strong></p><p>主要字段：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 等待队列中的首节点</span><span class="token keyword">private</span> <span class="token keyword">transient</span> Node firstWaiter<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 等待队列中的尾节点</span><span class="token keyword">private</span> <span class="token keyword">transient</span> Node lastWaiter<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>Condition的实现是用了<strong>等待队列（但数据结构还是AQS里的Node，将Node#waitStatus设为2就表示这是等待节点）</strong></p><p><strong>只有获取到锁的线程才能调用Condition的阻塞和唤醒方法</strong></p><h2 id="9-1-Condition-await"><a href="#9-1-Condition-await" class="headerlink" title="9.1 Condition#await"></a>9.1 Condition#await</h2><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 响应中断</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Node node <span class="token operator">=</span> <span class="token function">addConditionWaiter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> savedState <span class="token operator">=</span> <span class="token function">fullyRelease</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 释放锁并且唤醒同步队列中的第二个节点</span>    <span class="token keyword">int</span> interruptMode <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 死循环判断当前节点是否在等待队列中</span>    <span class="token comment" spellcheck="true">// 等待队列中的节点一定要阻塞，而同步队列中的节点是可以被唤醒的</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isOnSyncQueue</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        LockSupport<span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>interruptMode <span class="token operator">=</span> <span class="token function">checkInterruptWhileWaiting</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 当signal后，需要重新获取锁，要复原现场，需要重新持有上一次所持有的所有的state值</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">acquireQueued</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> savedState<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> interruptMode <span class="token operator">!=</span> THROW_IE<span class="token punctuation">)</span>        interruptMode <span class="token operator">=</span> REINTERRUPT<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>nextWaiter <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// clean up if cancelled</span>        <span class="token function">unlinkCancelledWaiters</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>interruptMode <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 当前节点有中断</span>        <span class="token function">reportInterruptAfterWait</span><span class="token punctuation">(</span>interruptMode<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>流程分析：</p><ul><li>首先将当前线程构造为等待节点，并加入到等待队列的末尾</li><li>其次释放锁资源（能够await的线程一定是获取到锁的），同时唤醒同步队列的第二个节点，让其尝试获取锁</li><li>死循环判断当前节点是否为同步节点（等待节点在等待队列里，是一定要阻塞的。同步节点在同步队列里，是可以并被唤醒并尝试获取锁的），await到这里线程就阻塞了</li><li>当被唤醒后，当前节点一定被加入了同步队列，再尝试获取锁，如果能获取到，代表就可以返回了。如果获取不到，就表示当前同步块被其他线程暂用了，也还是阻塞。不过下一次被唤醒后就会通过同步队列的唤醒方式来尝试获取锁</li></ul><h2 id="9-2-Condition-signal和signalAll"><a href="#9-2-Condition-signal和signalAll" class="headerlink" title="9.2 Condition#signal和signalAll"></a>9.2 Condition#signal和signalAll</h2><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">doSignal</span><span class="token punctuation">(</span>Node first<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">do</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 将首节点的nextWaiter转移到首节点，如果nextWaiter为空，则表示队列中只有一个节点，且首尾相同</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>firstWaiter <span class="token operator">=</span> first<span class="token punctuation">.</span>nextWaiter<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>            lastWaiter <span class="token operator">=</span> null<span class="token punctuation">;</span>        first<span class="token punctuation">.</span>nextWaiter <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// gc处理</span>    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">transferForSignal</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>             <span class="token punctuation">(</span>first <span class="token operator">=</span> firstWaiter<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 将当前的等待节点转换为同步节点，并加入到同步队列的末尾</span><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">transferForSignal</span><span class="token punctuation">(</span>Node node<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> Node<span class="token punctuation">.</span>CONDITION<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        Node p <span class="token operator">=</span> <span class="token function">enq</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> ws <span class="token operator">=</span> p<span class="token punctuation">.</span>waitStatus<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> ws<span class="token punctuation">,</span> Node<span class="token punctuation">.</span>SIGNAL<span class="token punctuation">)</span><span class="token punctuation">)</span>            LockSupport<span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 前驱节点被取消了，或者设置为SIGNAL失败</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>signal主要就是将等待队列的首节点转移到同步队列的为节点，signalAll则是将等待队列中的所有节点都转移到同步节点。所以signal并不能唤醒await的线程</p><h2 id="9-3-总结"><a href="#9-3-总结" class="headerlink" title="9.3 总结"></a>9.3 总结</h2><p>Condition实现了等待通知，当一个线程进入同步块后，就可以调用await，释放自己获取的锁资源，将自己阻塞。内部实现是<strong>首先将当前线程构造成一个等待节点，加入ConditionObject的等待队列的末尾，再释放锁资源，之后唤醒同步队列的第二个节点让其尝试获取锁</strong>。而当其他进入同步块的线程调用signal后，会将等待队列的首节点转移到同步队列，并将其变成同步节点，最后再使用同步队列的唤醒机制等待被唤醒。</p><p>​所以signal并不能直接唤醒一个await的线程，最佳使用案例就是消费者发送者机制，比如阻塞队列。</p><h1 id="10-ReentrantReadWriteLock"><a href="#10-ReentrantReadWriteLock" class="headerlink" title="10. ReentrantReadWriteLock"></a>10. ReentrantReadWriteLock</h1><p>​读写锁，支持并发的读或互斥的写。读写锁分别各自实现，读锁使用共享锁，写锁使用互斥锁。ReentrantReadWriteLock内部的ReadLock和WriteLock都使用了内部同一个Sync对象来实现读写加锁的功能，在Sync内，他将AQS的state转换为二进制，高十六位表示读状态位，低十六位表示写状态位。由于读是共享的，所以state的高十六位表示了当前有多少个线程在读，在此期间写锁是禁用的。而低十六位是写锁，所以只可能有一个线程，但可能数字大于1（这是就表示写锁重入了）。当写锁被占用是，读是不允许的</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> SHARED_SHIFT<span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">//   读状态位            写状态位</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> SHARED_UNIT  <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> SHARED_SHIFT<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 0000000000000001 0000000000000000</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAX_COUNT <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> SHARED_SHIFT<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//0000000000000000 1111111111111111</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> EXCLUSIVE_MASK <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> SHARED_SHIFT<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//0000000000000000 1111111111111111</span><span class="token comment" spellcheck="true">// 获取共享锁冲入次数（读锁专用）</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">sharedCount</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span>    <span class="token punctuation">{</span> <span class="token keyword">return</span> c <span class="token operator">>>></span> SHARED_SHIFT<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 获取排他锁冲入次数（写锁专用）</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">exclusiveCount</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> c <span class="token operator">&amp;</span> EXCLUSIVE_MASK<span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>读写锁都支持重入，但写锁只能让当前线程重入，并且要解锁时需要unlock重入的次数。</p><h1 id="11-ThreadPoolExecutor"><a href="#11-ThreadPoolExecutor" class="headerlink" title="11. ThreadPoolExecutor"></a>11. ThreadPoolExecutor</h1><h2 id="11-1-重要字段"><a href="#11-1-重要字段" class="headerlink" title="11.1 重要字段"></a>11.1 重要字段</h2><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//状态控制器，初始值： 1110 0000 0000 0000 0000 0000 0000 0000</span><span class="token keyword">private</span> <span class="token keyword">final</span> AtomicInteger ctl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token function">ctlOf</span><span class="token punctuation">(</span>RUNNING<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> COUNT_BITS <span class="token operator">=</span> Integer<span class="token punctuation">.</span>SIZE <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 29位</span><span class="token comment" spellcheck="true">// 0001 1111 1111 1111 1111 1111 1111 1111</span><span class="token comment" spellcheck="true">// 1110 0000 0000 0000 0000 0000 0000 0000 取反后</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> CAPACITY   <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>                                                            <span class="token comment" spellcheck="true">// 运行中：111 00000000000000000000000000000</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> RUNNING    <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 不再接受新任务的入队列，但已经入队列还未还未的任务还可以继续执行</span><span class="token comment" spellcheck="true">// 000 00000000000000000000000000000</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> SHUTDOWN   <span class="token operator">=</span>  <span class="token number">0</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 不接受新任务入队列，也不处理队列中的任务，中断正在处理任务的worker</span><span class="token comment" spellcheck="true">// 001 00000000000000000000000000000</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> STOP       <span class="token operator">=</span>  <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 全部完成，任务终止，worker数为0</span><span class="token comment" spellcheck="true">// 010 00000000000000000000000000000</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TIDYING    <span class="token operator">=</span>  <span class="token number">2</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 011 00000000000000000000000000000</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TERMINATED <span class="token operator">=</span>  <span class="token number">3</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 计算线程池的状态</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span>     <span class="token punctuation">{</span> <span class="token keyword">return</span> c <span class="token operator">&amp;</span> <span class="token operator">~</span>CAPACITY<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 后29位为0，前3为跟随c</span><span class="token comment" spellcheck="true">// 计算线程池有多少工作线程</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> c <span class="token operator">&amp;</span> CAPACITY<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 前3位为0，后面29为跟随 c</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">ctlOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> rs<span class="token punctuation">,</span> <span class="token keyword">int</span> wc<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> rs <span class="token operator">|</span> wc<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 任务队列</span><span class="token keyword">private</span> <span class="token keyword">final</span> BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> workQueue<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 主锁</span><span class="token keyword">private</span> <span class="token keyword">final</span> ReentrantLock mainLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 工作线程的Set</span><span class="token keyword">private</span> <span class="token keyword">final</span> HashSet<span class="token operator">&lt;</span>Worker<span class="token operator">></span> workers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span>Worker<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">final</span> Condition termination <span class="token operator">=</span> mainLock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 池已经创建的线程最大数（一个动态值，线程池整个周期同时存在的最多线程数）</span><span class="token keyword">private</span> <span class="token keyword">int</span> largestPoolSize<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 完成的任务数</span><span class="token keyword">private</span> <span class="token keyword">long</span> completedTaskCount<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 创建线程的工厂</span><span class="token keyword">private</span> <span class="token keyword">volatile</span> ThreadFactory threadFactory<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 拒绝策略</span><span class="token keyword">private</span> <span class="token keyword">volatile</span> RejectedExecutionHandler handler<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 非核心线程数的保持时间</span><span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 是否允许核心线程过期</span><span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> allowCoreThreadTimeOut<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 核心线程数</span><span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> corePoolSize<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 最大线程数</span><span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>​ThreadPoolExecutor利用一个int类型的数来同时保存当前线程池状态和工作线程的数量，高3为用来表示当前线程的状态，低29为用来保存工作线程的数量。</p><p>​ThreadPoolExecutor内部的Worker就是工作线程的抽象，每一个Worker都是一个工作线程。同时，Worker又继承了AQS可以充当锁的角色，目的是更好的让外部知道当前worker是否正在运行，worker运行时（获取到任务后开始运行）会加锁，通过测试当前worker是否加上锁或者是否可以获得当前worker的锁，便可知道worker是否繁忙，有助于worker的清理</p></blockquote><h2 id="11-2-核心方法"><a href="#11-2-核心方法" class="headerlink" title="11.2 核心方法"></a>11.2 核心方法</h2><ul><li><p>shutdown：将当前线程池状态设为SHUTDOWN状态，再中断空闲的Worker（判断Worker是否空闲就通过它的锁方法）。<strong>所以，执行了这个方法后，正在执行的任务不会被中断，且已经存在workQueue中的Runnable也可以被执行，但是不能放入新的Runnable</strong></p></li><li><p>shutdownNow：将当前线程池状态设为STOP状态，将所有Worker设置为中断位，且倒出workQueue中的所有Runnable。<strong>所以，执行了这个方法后，正在运行的任务如果检测了中断位就会立即退出，如果没检测就还是会执行完，而已经存在workQueue中的Runnable将不会被执行，会将这些Runnable返回给调用者，让调用者处理</strong></p></li></ul><p>​ThredPoolExecutor除了核心方法外，还提供了很多辅助方法。比如setCorePoolSize方法之类的set方法，是支持动态修改参数的。而prestart相关方法都支持预启动核心线程等</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 执行Runnable的方法</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span>Runnable command<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>command <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取当前线程池状态</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 判断是否小于核心线程数，是则新建线程运行任务</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&lt;</span> corePoolSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 核心数满了，并且当前线程池状态为Running，加到等待队列中</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isRunning</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> workQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> recheck <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> <span class="token function">isRunning</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">remove</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token function">addWorker</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 等待队列满了，新建线程，但不能大于最大线程数</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 创建失败，直接调用拒绝策略</span>        <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当addWorker且成功创建Worker后，就会启动Worker，Worker实现了Runnable，</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// Worker的Runnable方法</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">runWorker</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">runWorker</span><span class="token punctuation">(</span>Worker w<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Thread wt <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Runnable task <span class="token operator">=</span> w<span class="token punctuation">.</span>firstTask<span class="token punctuation">;</span>    w<span class="token punctuation">.</span>firstTask <span class="token operator">=</span> null<span class="token punctuation">;</span>    w<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// allow interrupts</span>    <span class="token keyword">boolean</span> completedAbruptly <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 利用阻塞队列，一直循环取任务执行（阻塞队列为空时会阻塞当前想取出元素的线程）</span>        <span class="token comment" spellcheck="true">// 如果getTask为null，就代表会终结当前工作线程</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>task <span class="token operator">!=</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>task <span class="token operator">=</span> <span class="token function">getTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            w<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> STOP<span class="token punctuation">)</span> <span class="token operator">||</span>                 <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                  <span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> STOP<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                <span class="token operator">!</span>wt<span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                wt<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token function">beforeExecute</span><span class="token punctuation">(</span>wt<span class="token punctuation">,</span> task<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 钩子函数before</span>                Throwable thrown <span class="token operator">=</span> null<span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    task<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 真正的运行Runnable</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RuntimeException</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> x<span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Error</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> x<span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                    <span class="token function">afterExecute</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> thrown<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 钩子函数after</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                task <span class="token operator">=</span> null<span class="token punctuation">;</span>                w<span class="token punctuation">.</span>completedTasks<span class="token operator">++</span><span class="token punctuation">;</span>                w<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        completedAbruptly <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token function">processWorkerExit</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> completedAbruptly<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 核心方法之一，从阻塞队列中取任务</span><span class="token keyword">private</span> Runnable <span class="token function">getTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">boolean</span> timedOut <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Did the last poll() time out?</span>    <span class="token comment" spellcheck="true">// 死循环取任务</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Check if queue empty only if necessary.</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">>=</span> SHUTDOWN <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>rs <span class="token operator">>=</span> STOP <span class="token operator">||</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">decrementWorkerCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> wc <span class="token operator">=</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 允许核心线程过期和非核心线程都可以超时取任务</span>        <span class="token keyword">boolean</span> timed <span class="token operator">=</span> allowCoreThreadTimeOut <span class="token operator">||</span> wc <span class="token operator">></span> corePoolSize<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>wc <span class="token operator">></span> maximumPoolSize <span class="token operator">||</span> <span class="token punctuation">(</span>timed <span class="token operator">&amp;&amp;</span> timedOut<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>wc <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">||</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 原子性的尝试减少一个工作线程，减少成功才返回结束线程</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndDecrementWorkerCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span>                 <span class="token keyword">return</span> null<span class="token punctuation">;</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 如果是超时取任务，时间结束后还是取不到，则设置timedOut为true，下次循环就可以直接返回null退出了，这样，这个Worker也就终结了</span>            Runnable r <span class="token operator">=</span> timed <span class="token operator">?</span>                workQueue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span>keepAliveTime<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>NANOSECONDS<span class="token punctuation">)</span> <span class="token operator">:</span>            workQueue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 不为null才返回，就不用担心返回null而终结了当前线程</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">!=</span> null<span class="token punctuation">)</span>                <span class="token keyword">return</span> r<span class="token punctuation">;</span>            timedOut <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> retry<span class="token punctuation">)</span> <span class="token punctuation">{</span>            timedOut <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="11-3-总结"><a href="#11-3-总结" class="headerlink" title="11.3 总结"></a>11.3 总结</h2><p><strong>execute Runnable的流程</strong></p><ul><li>先判断线程池的工作线程数量是否小于核心线程数，小于核心线程数直接新建线程来执行</li><li>如果核心线程数满了，则将Runnable投入到workQueue中</li><li>如果workQueue满了，则创建非核心线程来继续执行任务</li><li>如果线程池中的工作现场数量到达了maximumPoolSize的值，则使用拒绝策略来执行任务</li></ul><p><strong>Worker的工作流程</strong></p><p>​调用getTask取任务来执行，如果取出的任务为空，则这个Worker也就结束了（终结了）。getTask不为空的话，还是先进性一系列的线程池状态校验，在执行钩子函数（beforeExecute），在真正的执行这个Runnable，再执行钩子函数（afterExecute），最后再将completedTasks加1，表示当前Worker完成的任务总数</p><p><strong>getTask流程</strong>（实现线程超时回收的关键）</p><ul><li>先进行一系列的状态校验</li><li><strong>判断是否允许超时（满足任意一个就行）</strong><ul><li><strong>allowCoreThreadTimeOut为true（都允许核心线程超时了，那没任务的情况下线程池就不该有线程）</strong></li><li><strong>当前线程池的工作线程数量大于核心线程数量就允许超时</strong></li></ul></li><li>判断是否触发减少工作线程数量的机制，然后使用CAS减少工作线程数量，减少成功才返回null，结束当前工作线程</li><li>通过阻塞队列取Runnable，如果不允许超时，则会一直阻塞到这。如果允许超时，则会超时等待keepAliveTime纳秒取Runnable，如果取不出来，则设置一次已经超时，再来循环一次，来判断是否该减少工作线程</li></ul><h1 id="12-Future"><a href="#12-Future" class="headerlink" title="12.Future"></a>12.Future</h1><p>java里Future的默认实现是FutureTask，将Callable作为构造器参数传入，就有了执行Callable的能力</p><h2 id="12-1-重点字段和主要方法："><a href="#12-1-重点字段和主要方法：" class="headerlink" title="12.1 重点字段和主要方法："></a>12.1 重点字段和主要方法：</h2><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// state字段，表示了当前Future的状态，取值为如下字段</span><span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> state<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> NEW          <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 初始状态，新建</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> COMPLETING   <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 正在结束</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> NORMAL       <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 正常执行完毕</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> EXCEPTIONAL  <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 异常执行完毕</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> CANCELLED    <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 前一个状态必须是NEW，已取消（未中断）</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> INTERRUPTING <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 前一个状态必须是NEW，正在中断（中断）</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> INTERRUPTED  <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 取消成功的才可以设置，中断完成（中断）</span><span class="token comment" spellcheck="true">// 待运行的Callable任务</span><span class="token keyword">private</span> Callable<span class="token operator">&lt;</span>V<span class="token operator">></span> callable<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Callable执行的结果。如果出现执行的过程中异常，则保存的是异常对象</span><span class="token keyword">private</span> Object outcome<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 运行Callable#call方法的线程（也即是运行业务代码的线程）</span><span class="token keyword">private</span> <span class="token keyword">volatile</span> Thread runner<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 当这里面的Callable还未执行完，却有其他线程调用Future#get()方法，</span><span class="token comment" spellcheck="true">// 会将其他线程阻塞并构造为等待节点，维持一个链表结构，以便在Callable执行完毕后唤醒并回调</span><span class="token keyword">private</span> <span class="token keyword">volatile</span> WaitNode waiters<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>state <span class="token operator">!=</span> NEW <span class="token operator">||</span>        <span class="token operator">!</span>UNSAFE<span class="token punctuation">.</span><span class="token function">compareAndSwapObject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> runnerOffset<span class="token punctuation">,</span>                                     null<span class="token punctuation">,</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        Callable<span class="token operator">&lt;</span>V<span class="token operator">></span> c <span class="token operator">=</span> callable<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> state <span class="token operator">==</span> NEW<span class="token punctuation">)</span> <span class="token punctuation">{</span>            V result<span class="token punctuation">;</span>            <span class="token keyword">boolean</span> ran<span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 执行业务方法</span>                result <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                ran <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>                result <span class="token operator">=</span> null<span class="token punctuation">;</span>                ran <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token function">setException</span><span class="token punctuation">(</span>ex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 异常结束，将状态设为EXCEPTIONAL，如果等待队列有节点，则唤醒对应的线程</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>ran<span class="token punctuation">)</span>                <span class="token function">set</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 正常结束，将状态设为NORMAL，如果等待队列有节点，则唤醒对应的线程</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        runner <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">int</span> s <span class="token operator">=</span> state<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">>=</span> INTERRUPTING<span class="token punctuation">)</span>            <span class="token function">handlePossibleCancellationInterrupt</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 阻塞获取</span><span class="token keyword">public</span> V <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">,</span> ExecutionException <span class="token punctuation">{</span>    <span class="token keyword">int</span> s <span class="token operator">=</span> state<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">&lt;=</span> COMPLETING<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 还未完全结束Callabke，进入等待</span>        s <span class="token operator">=</span> <span class="token function">awaitDone</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> 0L<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">report</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 根据state判断是否需要阻塞并做对于的事</span><span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">awaitDone</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> timed<span class="token punctuation">,</span> <span class="token keyword">long</span> nanos<span class="token punctuation">)</span>    <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    <span class="token keyword">final</span> <span class="token keyword">long</span> deadline <span class="token operator">=</span> timed <span class="token operator">?</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> nanos <span class="token operator">:</span> 0L<span class="token punctuation">;</span>    WaitNode q <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">boolean</span> queued <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 当前线程支持响应中断</span>            <span class="token function">removeWaiter</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> s <span class="token operator">=</span> state<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">></span> COMPLETING<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// Callable运行完毕，且result已经设置完毕</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>q <span class="token operator">!=</span> null<span class="token punctuation">)</span>                q<span class="token punctuation">.</span>thread <span class="token operator">=</span> null<span class="token punctuation">;</span>            <span class="token keyword">return</span> s<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 进入到以下分支，就代表Callable还未完全执行完毕</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> COMPLETING<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// cannot time out yet  Callable运行完毕，但正在设置result，让出执行时间，等待下次判断</span>            Thread<span class="token punctuation">.</span><span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>q <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 第一次循环，构造等待节点</span>            q <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WaitNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>queued<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 还未加入等待队列，则将节点加入到等待队列中</span>            queued <span class="token operator">=</span> UNSAFE<span class="token punctuation">.</span><span class="token function">compareAndSwapObject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> waitersOffset<span class="token punctuation">,</span>                                                 q<span class="token punctuation">.</span>next <span class="token operator">=</span> waiters<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>timed<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 是否运行超时判断</span>            nanos <span class="token operator">=</span> deadline <span class="token operator">-</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nanos <span class="token operator">&lt;=</span> 0L<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">removeWaiter</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> state<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            LockSupport<span class="token punctuation">.</span><span class="token function">parkNanos</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> nanos<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token comment" spellcheck="true">// 暂停当前线程，等待任务执行完毕的唤醒</span>            LockSupport<span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 任务执行完毕，唤醒等待队列的所有节点</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">finishCompletion</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// assert state > COMPLETING;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>WaitNode q<span class="token punctuation">;</span> <span class="token punctuation">(</span>q <span class="token operator">=</span> waiters<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>UNSAFE<span class="token punctuation">.</span><span class="token function">compareAndSwapObject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> waitersOffset<span class="token punctuation">,</span> q<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                Thread t <span class="token operator">=</span> q<span class="token punctuation">.</span>thread<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    q<span class="token punctuation">.</span>thread <span class="token operator">=</span> null<span class="token punctuation">;</span>                    LockSupport<span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                WaitNode next <span class="token operator">=</span> q<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                q<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// unlink to help gc</span>                q <span class="token operator">=</span> next<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    callable <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// to reduce footprint</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="12-2-总结"><a href="#12-2-总结" class="headerlink" title="12.2 总结"></a>12.2 总结</h2><p>FutureTask根据内部的state字段来判断当前任务运行到了哪个阶段并作出对于的抉择。</p><p>​如果想获取任务执行的结果，要使用get来获取结果，get是个阻塞的方法。当任务还未执行完毕时，会将调用get的方法阻塞并构造成WaitNode，再通过内部的next字段链接下一个WaitNode，形成一个链表结构。当任务执行完毕后，内部调用的finishCompletion方法会判断等待链表是否为空，不为空就代表有线程在获取结果时被阻塞了，这时唤醒阻塞队列的所有线程，最终，调用get方法的线程返回结果。</p><h1 id="13-ScheduledThreadPoolExecutor"><a href="#13-ScheduledThreadPoolExecutor" class="headerlink" title="13. ScheduledThreadPoolExecutor"></a>13. ScheduledThreadPoolExecutor</h1><h2 id="13-1-ScheduledExecutorService"><a href="#13-1-ScheduledExecutorService" class="headerlink" title="13.1 ScheduledExecutorService"></a>13.1 ScheduledExecutorService</h2><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 创建一个一次性的延迟（定时）任务，框架中cron表达式就是通过此接口实现的 * 只需要在任务完成后，在计算下一次的执行时间，再用此方法定时执行，以此类推 */</span><span class="token keyword">public</span> ScheduledFuture<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">schedule</span><span class="token punctuation">(</span>Runnable command<span class="token punctuation">,</span>                                   <span class="token keyword">long</span> delay<span class="token punctuation">,</span> TimeUnit unit<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*** 执行Callable接口的任务，也是一个一次性的定时任务*/</span><span class="token keyword">public</span> <span class="token operator">&lt;</span>V<span class="token operator">></span> ScheduledFuture<span class="token operator">&lt;</span>V<span class="token operator">></span> <span class="token function">schedule</span><span class="token punctuation">(</span>Callable<span class="token operator">&lt;</span>V<span class="token operator">></span> callable<span class="token punctuation">,</span>                                       <span class="token keyword">long</span> delay<span class="token punctuation">,</span> TimeUnit unit<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 基于固定的频率执行定时任务  * 例：初始执行任务的时间戳：当前时间戳（调用时）+ initialDelay  * 第二次执行：初始执行任务开始时的时间戳 + period  * 第三次执行：第二次执行任务开始时的时间戳 + period */</span><span class="token keyword">public</span> ScheduledFuture<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">scheduleAtFixedRate</span><span class="token punctuation">(</span>Runnable command<span class="token punctuation">,</span>                                              <span class="token keyword">long</span> initialDelay<span class="token punctuation">,</span>                                              <span class="token keyword">long</span> period<span class="token punctuation">,</span>                                              TimeUnit unit<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 基于固定的周期执行定时任务  * 例：初始执行任务的时间戳：当前时间戳（调用时）+ initialDelay *  第二次执行：初始任务执行完结时的时间戳 + delay *  第三次执行：第二次任务执行完结时的时间戳 + delay * */</span><span class="token keyword">public</span> ScheduledFuture<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">scheduleWithFixedDelay</span><span class="token punctuation">(</span>Runnable command<span class="token punctuation">,</span>                                                 <span class="token keyword">long</span> initialDelay<span class="token punctuation">,</span>                                                 <span class="token keyword">long</span> delay<span class="token punctuation">,</span>                                                 TimeUnit unit<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>所以，fixedRate的每次执行的开始时间是可以计算的。但fixedDelay却不行，因为它还受任务本身执行花费的时间所影响</strong>。</p><h2 id="13-2-DelayedWorkQueue"><a href="#13-2-DelayedWorkQueue" class="headerlink" title="13.2 DelayedWorkQueue"></a>13.2 DelayedWorkQueue</h2><p>数组实现的小顶堆结构，非常适合定时任务的处理</p><p><img src="/img/top_heap.png" alt="顶堆结构"></p><p>​<strong>大顶堆和小顶堆结构</strong></p><p>数组实现的小顶堆有如下规律：</p><ul><li>数组索引为0的元素是最小的</li><li>父节点小于两个子节点（但这两个子节点大小顺序不定）</li><li>数组结构紧凑（中间没有空元素）</li><li>假设<strong>父节点索引为x，则左子节点为2x + 1，右子节点为2x + 2</strong></li><li>假设<strong>子节点索引为y，则父节点索引为 (y - 1) &#x2F; 2</strong></li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 数组初始容量</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> INITIAL_CAPACITY <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 数组实现的最小顶堆结构，queue[0]始终都是最快需要被执行的那个任务</span><span class="token keyword">private</span> RunnableScheduledFuture<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> queue <span class="token operator">=</span>    <span class="token keyword">new</span> <span class="token class-name">RunnableScheduledFuture</span><span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span>INITIAL_CAPACITY<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// leader线程，定时等待queue[0]任务的那个线程</span><span class="token keyword">private</span> Thread leader <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">final</span> Condition available <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 新加入了任务，判断时都需要上移（和父节点换个位置）并调整位置</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">siftUp</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> RunnableScheduledFuture<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>k <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> parent <span class="token operator">=</span> <span class="token punctuation">(</span>k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 父节点的索引</span>        RunnableScheduledFuture<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> e <span class="token operator">=</span> queue<span class="token punctuation">[</span>parent<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 当前节点的下次执行时间更久，直接break</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 当前节点的下次执行时间更快，继续递归向上遍历，直到放到合适的位置</span>        queue<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>        <span class="token function">setIndex</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>        k <span class="token operator">=</span> parent<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    queue<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> key<span class="token punctuation">;</span>    <span class="token function">setIndex</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/**    重写的offer方法（该方法就是线程池投递任务的方法） */</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">offer</span><span class="token punctuation">(</span>Runnable x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    RunnableScheduledFuture<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> e <span class="token operator">=</span> <span class="token punctuation">(</span>RunnableScheduledFuture<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">)</span>x<span class="token punctuation">;</span>    <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> size<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> queue<span class="token punctuation">.</span>length<span class="token punctuation">)</span>            <span class="token function">grow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        size <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 数组中还没有任务，直接放在首位</span>            queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>            <span class="token function">setIndex</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 已存在定时任务，看是否需要调整位置</span>            <span class="token function">siftUp</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 代表向队列添加了一个需要最快执行的任务</span>            <span class="token comment" spellcheck="true">// 需要重置leader线程，并将阻塞的线程从等待队列转移到同步队列，当下面的unlock后再唤醒阻塞线程</span>            leader <span class="token operator">=</span> null<span class="token punctuation">;</span>            available<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 重写了take方法</span><span class="token keyword">public</span> RunnableScheduledFuture<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>    lock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            RunnableScheduledFuture<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> first <span class="token operator">=</span> queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>first <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 不存在定时任务，所有线程都在这等待</span>                available<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">long</span> delay <span class="token operator">=</span> first<span class="token punctuation">.</span><span class="token function">getDelay</span><span class="token punctuation">(</span>NANOSECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>delay <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 时间已过，弹出队首任务去执行它</span>                    <span class="token keyword">return</span> <span class="token function">finishPoll</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 进入下面，无论怎样都要等待，所以直接把first置为null，下次循环再获取</span>                <span class="token comment" spellcheck="true">// 因为可能多个线程走到下面，都持有了队首的引用。避免出现RunnableScheduledFuture运行完了但不能及时回收的情况</span>                <span class="token comment" spellcheck="true">// 当然，也只有一次性的RunnableScheduledFuture才会回收，定时任务都是循环使用这个RunnableScheduledFuture的</span>                first <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// don't retain ref while waiting</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>leader <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 由leader存在，其他线程只需要无限期等待就行</span>                    available<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 没有leader存在，设置当前线程为leader，并定时等待（时间就为最近待执行的那个任务的距离下次执行时间间隔）</span>                    Thread thisThread <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    leader <span class="token operator">=</span> thisThread<span class="token punctuation">;</span>                    <span class="token keyword">try</span> <span class="token punctuation">{</span>                        available<span class="token punctuation">.</span><span class="token function">awaitNanos</span><span class="token punctuation">(</span>delay<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 定时等待</span>                    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 时间一到，说明队首任务可执行了，但当前线程可能不是leader线程了，需要判断一下再置空</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>leader <span class="token operator">==</span> thisThread<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 必须判断，有可能实时的添加了一个最快需要执行的线程，导致当前线程被取消了leader</span>                            leader <span class="token operator">=</span> null<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>leader <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// 任务取出来了，leader为空且存在队首任务，需要唤醒一个无限等待的线程</span>            <span class="token comment" spellcheck="true">// 让其成为leader线程并继续定时等待</span>            available<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="13-3-ScheduledFutureTask"><a href="#13-3-ScheduledFutureTask" class="headerlink" title="13.3 ScheduledFutureTask"></a>13.3 ScheduledFutureTask</h2><p>ScheduledFutureTask继承了FutureTask，当向定时任务线程池投递任务时（Runnable或Callable），都会将其封装为ScheduledFutureTask</p><p>重点字段和方法</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**  * 当前任务的id（自增的），代表了进入队列的顺序 &lt;br/> * 当两个定时任务下次执行时间一致时，sequenceNumber越小就会越早执行 */</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">long</span> sequenceNumber<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 下次执行当前任务的纳秒时间戳</span><span class="token keyword">private</span> <span class="token keyword">long</span> time<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 执行定时任务的纳秒间隔时间 * 大于0：代表固定的频率，不受任务的执行所花费的时间影响 * 等于0：代表不是一个重复的任务（只会执行一次 * 小于0：代表固定的时间间隔，基于任务执行完毕后的时间计算。（任务执行完后再基于当前时间计算下次执行时间） */</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">long</span> period<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 当前任务在数组中的索引</span><span class="token keyword">int</span> heapIndex<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">getDelay</span><span class="token punctuation">(</span>TimeUnit unit<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> unit<span class="token punctuation">.</span><span class="token function">convert</span><span class="token punctuation">(</span>time <span class="token operator">-</span> <span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> NANOSECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 比较方法，决定了放入数组的位置</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span>Delayed other<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>other <span class="token operator">==</span> <span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// compare zero if same object</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>other <span class="token keyword">instanceof</span> <span class="token class-name">ScheduledFutureTask</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        ScheduledFutureTask<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> x <span class="token operator">=</span> <span class="token punctuation">(</span>ScheduledFutureTask<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">)</span>other<span class="token punctuation">;</span>        <span class="token keyword">long</span> diff <span class="token operator">=</span> time <span class="token operator">-</span> x<span class="token punctuation">.</span>time<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>diff <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>diff <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 当前任务的下次执行时间更长，返回正数</span>            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>sequenceNumber <span class="token operator">&lt;</span> x<span class="token punctuation">.</span>sequenceNumber<span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">long</span> diff <span class="token operator">=</span> <span class="token function">getDelay</span><span class="token punctuation">(</span>NANOSECONDS<span class="token punctuation">)</span> <span class="token operator">-</span> other<span class="token punctuation">.</span><span class="token function">getDelay</span><span class="token punctuation">(</span>NANOSECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>diff <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> <span class="token punctuation">(</span>diff <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * false: 代表当前任务为一次性任务 * true: 定时任务 */</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isPeriodic</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> period <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 当前任务执行完毕后，用来计算下次执行时间</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">setNextRunTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">long</span> p <span class="token operator">=</span> period<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// p为两次执行时间的时间间隔的纳秒值</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// p大于0，即为固定时间执行的任务，基于初始运行时间计算下一次的执行时间</span>        time <span class="token operator">+=</span> p<span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token comment" spellcheck="true">// p小于0，为基于完成任务的时间来执行，基于任务运行完的时间，来计算出下一次的执行时间</span>        time <span class="token operator">=</span> <span class="token function">triggerTime</span><span class="token punctuation">(</span><span class="token operator">-</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 主方法，运行当前定时任务</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">boolean</span> periodic <span class="token operator">=</span> <span class="token function">isPeriodic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">canRunInCurrentRunState</span><span class="token punctuation">(</span>periodic<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>periodic<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 非定时任务，当作普通任务直接调用FutureTask的run方法运行</span>        ScheduledFutureTask<span class="token punctuation">.</span><span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ScheduledFutureTask<span class="token punctuation">.</span><span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">runAndReset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 运行定时任务，且运行成功（没抛异常）</span>        <span class="token function">setNextRunTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 设置下一次执行时间</span>        <span class="token function">reExecutePeriodic</span><span class="token punctuation">(</span>outerTask<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 再把当前任务重新入队列</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/**    父类的FutureTask中的方法，运行并重置状态，用于任务的多次执行      * 正常执行时：不会修改运行状态（也就是说这个操作不会修改state字段值，保持初始值，以支持重复执行）。     * 出现异常时：还是将state设为EXCEPTIONAL，也就是说一个定时任务要是抛出了异常，之后就不会再执行它了     */</span><span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">runAndReset</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>state <span class="token operator">!=</span> NEW <span class="token operator">||</span> <span class="token comment" spellcheck="true">// 不为NEW状态的都不执行</span>        <span class="token operator">!</span>UNSAFE<span class="token punctuation">.</span><span class="token function">compareAndSwapObject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> runnerOffset<span class="token punctuation">,</span>                                     null<span class="token punctuation">,</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> ran <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> s <span class="token operator">=</span> state<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        Callable<span class="token operator">&lt;</span>V<span class="token operator">></span> c <span class="token operator">=</span> callable<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> s <span class="token operator">==</span> NEW<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                c<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 不设置返回结果。多次执行的任务就不该有执行结果</span>                ran <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">setException</span><span class="token punctuation">(</span>ex<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 抛出异常，修改state为EXCEPTIONAL，以后也不在执行它</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// runner must be non-null until state is settled to</span>        <span class="token comment" spellcheck="true">// prevent concurrent calls to run()</span>        runner <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// state must be re-read after nulling runner to prevent</span>        <span class="token comment" spellcheck="true">// leaked interrupts</span>        s <span class="token operator">=</span> state<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">>=</span> INTERRUPTING<span class="token punctuation">)</span>            <span class="token function">handlePossibleCancellationInterrupt</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> ran <span class="token operator">&amp;&amp;</span> s <span class="token operator">==</span> NEW<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="13-4-总结"><a href="#13-4-总结" class="headerlink" title="13.4 总结"></a>13.4 总结</h2><p><a href="https://segmentfault.com/a/1190000038371064">优秀的文章</a></p><p>​ScheduledThreadPoolExecutor本质还是个线程池，<strong>内部的DelayedWorkQueue就是工作队列。投递的定时任务和普通任务都会封装为ScheduledFutureTask，并最终放入DelayedWorkQueue里的那个数组（只不过定时任务有延时，可能会放在队列中的任何位置。而普通任务封装的ScheduledFutureTask执行时间就是当前而已，始终会放到队列的队首并立马执行）</strong></p><p>​DelayedWorkQueue实现了BlockingQueue，是基于<strong>数组的最小顶堆的数据结构</strong>实现，以此<strong>保证数组的第一个位置就是最近需要被执行的任务</strong>。结构图和特点如下</p><p>​ScheduledThreadPoolExecutor还使用了<strong>Leader-Follower模式</strong>，leader线程定时等待工作队列中第一个任务，其余线程一般就都无限期等待（如果向工作队列添加的是一个最快需要被执行的任务，可能就有多个定时等待的线程，但leader线程始终都会是最快需要被执行任务的线程）。</p><p><strong>为什么使用Leader-Follower模式：</strong></p><blockquote><p>​避免资源的浪费。定时任务再怎么排序，也只会有一个是最快需要执行的任务（时间相同会根据sequenceNumber排序），只需要设计一个定时等待线程等待这个最快需要执行的任务。当这个最快需要执行的任务触发后，再设计一个新的leader线程等待下一个最近的定时任务。理想的情况下，定时任务线程池只会有一个定时等待的线程（Leader线程），其余线程要么正在运行定时任务，要么全部无限期阻塞（Follower线程），最大程度的避免资源浪费（无限期等待的线程不用想其它的，乖乖等待被其他线程唤醒就行。而定时等待的线程需要在时间到达后被唤醒，至少需要被定时器监视以用来执行唤醒操作）</p></blockquote><ul><li><strong>固定周期</strong>：受执行时常影响，只有当任务结束后才相对于结束时间来计算任务的下次执行时间</li><li><strong>固定频率</strong>：不受任务的执行时常所影响，当任务投递到队列时就可以预判到以后任何执行该任务的时间</li></ul><p>​一个被投递的周期任务首先会封装成ScheduledFutureTask，再根据其下次执行时间放在DelayedWorkQueue的某个位置。如果放在了DelayedWorkQueue的队首，则使用定时任务线程池里的线程超时等待，以便时间到达后开始执行。正常执行完毕则会先根据其是固定周期任务还是固定频率的任务来计算下次执行时间并修赋值到ScheduledFutureTask的time字段，再将这个任务再次入队列，这样递归去执行。执行中如果抛出了异常，则会将ScheduledFutureTask的state修改为异常，之后就不再执行这个任务了</p><h1 id="14-CopyOnWriteArrayList"><a href="#14-CopyOnWriteArrayList" class="headerlink" title="14. CopyOnWriteArrayList"></a>14. CopyOnWriteArrayList</h1><p>​线程安全的List，写时复制List，顾名思义，就是在修改元素时（添加，删除等操作），使用新的数组来添加或删除，原内部数组在设置后就再也不会修改内部的数据结构了。</p><p>​所以，这种数据结构<strong>适合用在很少修改元素，大量读取元素的多线程并发操作的场合</strong></p><p>主要字段和方法</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 数据修改时用到的互斥锁</span><span class="token keyword">final</span> <span class="token keyword">transient</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 数组实现，并使用volatile保持多线程对array的可见性</span><span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 添加元素</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 加互斥锁</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 原数组不会修改，每次都新建一个数组，在将array字段替换为新数组</span>        Object<span class="token punctuation">[</span><span class="token punctuation">]</span> elements <span class="token operator">=</span> <span class="token function">getArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> elements<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        Object<span class="token punctuation">[</span><span class="token punctuation">]</span> newElements <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        newElements<span class="token punctuation">[</span>len<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>        <span class="token function">setArray</span><span class="token punctuation">(</span>newElements<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>g1</title>
      <link href="/2025/01/07/g1/"/>
      <url>/2025/01/07/g1/</url>
      
        <content type="html"><![CDATA[<h1 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h1><p>用了G1，就不需要在指定新生代和老年代的的大小或比例关系了</p><p>大对象：对象大小超过一个Region容量一半的对象</p><ul><li><strong>-XX:+UseG1GC</strong></li><li><strong>-XX:G1HeapRegionSize&#x3D;2M</strong>：一个Region的大小</li><li><strong>-XX:MaxGCPauseMillis&#x3D;80</strong>：允许收集停顿的最大时常（毫秒）</li></ul><pre class="line-numbers language-log"><code class="language-log">2020-11-23T11:40:46.167+0800: 1.503: [GC pause (G1 Evacuation Pause) (young), 0.0048336 secs]   // 下面的Min,Avg,Max,Diff,Sum分别表示GC线程最小启动或耗时时间（后面的也是），平均，最大，最大差值，和总耗时，单位都为ms   [Parallel Time: 3.1 ms, GC Workers: 6] // 本次YGC共6个GC线程，总耗时3.1ms      [GC Worker Start (ms): Min: 1503.0, Avg: 1504.5, Max: 1506.1, Diff: 3.0] // 本次GC线程启动（相对于JVM的启动）      [Ext Root Scanning (ms): Min: 0.0, Avg: 0.2, Max: 0.7, Diff: 0.7, Sum: 1.1] // 本次GC线程的Root集合扫描时间      [Update RS (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0] // 更新Remember Sets 的耗时统计信息（记忆集一般使用来解决跨Region的引用）         [Processed Buffers: Min: 0, Avg: 0.0, Max: 0, Diff: 0, Sum: 0]      [Scan RS (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0] // 每个Region都会有一个RSet，RSet又包含指向这个Region的Cards引用，这个阶段就是扫描RSet中的Cards，从而分辨出Eden哪些对象被老年代引用，从而这些不会被GC      [Code Root Scanning (ms): Min: 0.0, Avg: 0.0, Max: 0.2, Diff: 0.2, Sum: 0.2] // 扫描代码中的root节点（局部变量）      [Object Copy (ms): Min: 0.0, Avg: 1.3, Max: 2.7, Diff: 2.7, Sum: 7.6] // 对象copy，将存活的对象copy到目标Region中      [Termination (ms): Min: 0.0, Avg: 0.0, Max: 0.1, Diff: 0.1, Sum: 0.3]         [Termination Attempts: Min: 1, Avg: 1.2, Max: 2, Diff: 1, Sum: 7]      [GC Worker Other (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.2] // GC线程完成其他任务的时间      [GC Worker Total (ms): Min: 0.0, Avg: 1.6, Max: 3.1, Diff: 3.1, Sum: 9.4] // GC线程整个生命周期总计消耗时间      [GC Worker End (ms): Min: 1506.1, Avg: 1506.1, Max: 1506.1, Diff: 0.0] // GC线程完成任务的停止时间（相对于JVM）   [Code Root Fixup: 0.0 ms]   [Code Root Purge: 0.0 ms]   [Clear CT: 0.1 ms] // 清理Card Table（卡表）   [Other: 1.6 ms]      [Choose CSet: 0.0 ms] // 选择要回收的Region放入CSet（会根据停顿时间来决定）      [Ref Proc: 1.4 ms] // 处理引用对象耗时时间（Weak、Soft、Phantom、JNI等等）      [Ref Enq: 0.0 ms] // 遍历所有引用，将不能回收的放入pending列表      [Redirty Cards: 0.0 ms] // 重置card为dirty      // 大型对象的回收      [Humongous Register: 0.0 ms]       [Humongous Reclaim: 0.0 ms]      [Free CSet: 0.0 ms] // 释放CSet中Region占用的内存空间所耗时间   [Eden: 51.0M(51.0M)->0.0B(46.0M) Survivors: 0.0B->5120.0K Heap: 51.0M(1024.0M)->4815.7K(1024.0M)] [Times: user=0.05 sys=0.00, real=0.01 secs] <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> gc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cms</title>
      <link href="/2025/01/05/cms/"/>
      <url>/2025/01/05/cms/</url>
      
        <content type="html"><![CDATA[<h1 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h1><p>标记，<strong>清除-清除</strong>算法的老年代gc回收器，一次CMS gc会算作两次full gc，分别为初始标记和最终标记（算上的时STW次数），但在多次收集后产生的空间碎片如果影响到了对象的分配，也会才用<strong>标记-整理</strong>算法收集一次</p><p>清除算法会产生空间碎片，如果cms区预留的空闲内存不能满足新对象的分配，那么会触发<strong>Concurrent Mode Failure</strong>，这时会冻结用户线程，临时启用<strong>Serial Old</strong>收集器重新回收老年代的垃圾，全程STW，耗时很长</p><ul><li>初始标记(CMS initial mark): STW，仅标记GCRoots对象的下一个可达对象，很快</li><li>并发标记(CMS concurent mark)</li><li>重新标记(CMS remark): STW，<a href="#%E6%A0%87%E8%AE%B0%E5%AF%B9%E8%B1%A1%E6%97%B6-%E5%B9%B6%E5%8F%91%E7%9A%84%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90">解决并发标记时”那些消失的对象</a></li><li>并发清除(CMS concurrent sweep)</li></ul><h2 id="1-参数"><a href="#1-参数" class="headerlink" title="1.参数"></a>1.参数</h2><ul><li><p><strong>-XX:+UseConcMarkSweepGC</strong>   ： 启用CMS收集器（年轻代默认使用ParNew收集器）</p></li><li><p><strong>–XX:CMSWaitDuration&#x3D;2000</strong> ： cms后台线程的轮询间隔时间（ms单位)</p></li><li><p><strong>-XX:+UseCMSInitiatingOccupancyOnly</strong> : 使用基于设定的阈值进行CMS gc，值为CMSInitiatingOccupancyFraction</p></li><li><p><strong>-XX:CMSInitiatingOccupancyFraction&#x3D;80</strong> : 在UseCMSInitiatingOccupancyOnly参数启用后生效。当CMS区（老年代）占比达到80%后，启用CMS垃圾回收。默认为-1，代表不启用，则老年代垃圾回收阈值算法为：**( (100 - MinHeapFreeRatio) + (CMSTriggerRatio * MinHeapFreeRatio) &#x2F; 100.0) &#x2F; 100.0** &#x3D; 92%</p></li><li><p><strong>-XX:ConcGCThreads&#x3D;2</strong> ：并发gc线程数，默认为（ParallelGCThreads+3）&#x2F; 4。ParallelGCThreads为新生代并行GC线程数，当CPU数量小于8时，ParallelGCThreads的值就是CPU的数量，当CPU数量大于8时，ParallelGCThreads的值等于3+5*cpuCount &#x2F; 8 （可用jstack查看）</p></li></ul><h2 id="2-其他"><a href="#2-其他" class="headerlink" title="2.其他"></a>2.其他</h2><h3 id="2-1cms-gc触发条件总结"><a href="#2-1cms-gc触发条件总结" class="headerlink" title="2.1cms gc触发条件总结"></a>2.1cms gc触发条件总结</h3><ul><li><a href="https://heapdump.cn/article/190389">原文</a></li><li>foreground collector  ：空间分配不够触发</li><li>background collector<ul><li>配置了<strong>ExplicitGCInvokesConcurrent</strong> 参数，且由**System.gc()**调用</li><li>根据统计数据动态计算（未配置<strong>UseCMSInitiatingOccupancyOnly</strong>时）</li><li>根据 Old Gen 情况判断</li><li><strong>jvm的悲观策略</strong>：<strong>Young GC 已经失败或者可能会失败，JVM 就认为需要进行一次 CMS GC</strong></li><li>metaspace扩容且<strong>CMSClassUnloadingEnabled</strong> 启用（默认也是启用的）</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> GC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CloudFlare-CDN缓存清除</title>
      <link href="/2024/06/14/cloudflare-cdn-huan-cun-qing-chu/"/>
      <url>/2024/06/14/cloudflare-cdn-huan-cun-qing-chu/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="CloudFlare-CDN缓存清除"><a href="#CloudFlare-CDN缓存清除" class="headerlink" title="CloudFlare-CDN缓存清除"></a>CloudFlare-CDN缓存清除</h1><p>​搭建个人博客网站时，域名托管到CF，会使用CF的CDN。当你重新修改博客网站的样式css和js文件等再重新部署，一般都不会立马生效，因为CDN里的缓存还在，前端访问用的还是旧css和js文件。这时我们需要主动清除CDN的缓存，来让缓存重新加载，以便让我们修改的样式在网站立马生效</p><h2 id="1-purgeUrl"><a href="#1-purgeUrl" class="headerlink" title="1 purgeUrl"></a>1 purgeUrl</h2><p><img src="/img/cloudflare-purge-url.png"></p><h2 id="2-使用ApiKey清除（不推荐）"><a href="#2-使用ApiKey清除（不推荐）" class="headerlink" title="2 使用ApiKey清除（不推荐）"></a>2 使用ApiKey清除（不推荐）</h2><ul><li>ZONE_ID：区域id，即你在CF上托管的根域名id</li><li>EMAIL：你的邮箱</li><li>API_KEY：可自建apiKey，也可使用CF默认有的GlobalApiKey（<strong>个人资料 -&gt; API令牌 -&gt; API密钥 -&gt; Global API Key</strong>）</li></ul><h3 id="2-1-全部清除"><a href="#2-1-全部清除" class="headerlink" title="2.1 全部清除"></a>2.1 全部清除</h3><pre class="line-numbers language-bash"><code class="language-bash">curl https://api.cloudflare.com/client/v4/zones/<span class="token variable">$ZONE_ID</span>/purge_cache \    -H <span class="token string">'Content-Type: application/json'</span> \    -H <span class="token string">"X-Auth-Email: <span class="token variable">$EMAIL</span>"</span> \    -H <span class="token string">"X-Auth-Key: <span class="token variable">$API_KEY</span>"</span> \    -d <span class="token string">'{"purge_everything": true}'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-批量清除具体文件"><a href="#2-2-批量清除具体文件" class="headerlink" title="2.2 批量清除具体文件"></a>2.2 批量清除具体文件</h3><p>一次性调用有文件数量限制： <strong>Free&#x2F;Pro&#x2F;Business一次上限30个，Enterprise一次上限500个</strong></p><pre class="line-numbers language-bash"><code class="language-bash">curl https://api.cloudflare.com/client/v4/zones/<span class="token variable">$ZONE_ID</span>/purge_cache \    -H <span class="token string">'Content-Type: application/json'</span> \    -H <span class="token string">"X-Auth-Email: <span class="token variable">$EMAIL</span>"</span> \    -H <span class="token string">"X-Auth-Key: <span class="token variable">$API_KEY</span>"</span> \    -d <span class="token string">'{    "files": [        "https://blog.shanzhao.site/css/my.css",        "https://blog.shanzhao.site/libs/others/snow.js"    ]}'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-自定义token清除（推荐）"><a href="#3-自定义token清除（推荐）" class="headerlink" title="3 自定义token清除（推荐）"></a>3 自定义token清除（推荐）</h2><p>自定义token不仅<strong>可以最小化的控制权限，也可以设置token的有效时常</strong>。使用如下方式创建一个专用于清理指定根域名的token</p><p><img src="/img/couldflare-purge-token.png"></p><h3 id="3-1-验证token是否生效"><a href="#3-1-验证token是否生效" class="headerlink" title="3.1 验证token是否生效"></a>3.1 验证token是否生效</h3><pre class="line-numbers language-bash"><code class="language-bash">curl -X GET <span class="token string">"https://api.cloudflare.com/client/v4/user/tokens/verify"</span> \     -H <span class="token string">"Authorization: Bearer <span class="token variable">$API_TOKEN</span>"</span> \     -H <span class="token string">"Content-Type:application/json"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="3-2-全部清除"><a href="#3-2-全部清除" class="headerlink" title="3.2 全部清除"></a>3.2 全部清除</h3><pre class="line-numbers language-bash"><code class="language-bash">curl https://api.cloudflare.com/client/v4/zones/<span class="token variable">$ZONE_ID</span>/purge_cache \    -H <span class="token string">'Content-Type: application/json'</span> \    -H <span class="token string">"Authorization: Bearer <span class="token variable">$API_TOKEN</span>"</span> \    -d <span class="token string">'{"purge_everything": true}'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-批量清除具体文件"><a href="#3-3-批量清除具体文件" class="headerlink" title="3.3 批量清除具体文件"></a>3.3 批量清除具体文件</h3><p>一次性调用有文件数量限制： <strong>Free&#x2F;Pro&#x2F;Business一次上限30个，Enterprise一次上限500个</strong></p><pre class="line-numbers language-bash"><code class="language-bash">curl https://api.cloudflare.com/client/v4/zones/<span class="token variable">$ZONE_ID</span>/purge_cache \    -H <span class="token string">'Content-Type: application/json'</span> \    -H <span class="token string">"Authorization: Bearer <span class="token variable">$API_TOKEN</span>"</span> \    -d <span class="token string">'{    "files": [        "https://blog.shanzhao.site/css/my.css",        "https://blog.shanzhao.site/libs/others/snow.js"    ]}'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-其他"><a href="#4-其他" class="headerlink" title="4 其他"></a>4 其他</h2><p>还有其他的参数，比如tags，hosts，prefixes，但这些都是企业版的用户才能使用，这里就不写了</p><h2 id="5-参考链接"><a href="#5-参考链接" class="headerlink" title="5 参考链接"></a>5 参考链接</h2><ul><li><a href="https://developers.cloudflare.com/api/resources/cache/methods/purge/">官方清除缓存文档</a></li><li><a href="https://dash.cloudflare.com/profile/api-tokens">cloudflare dashboard创建token和查看ApiKey</a></li><li><a href="https://developers.cloudflare.com/fundamentals/setup/find-account-and-zone-ids/">ZoneId获取</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> cloudflare </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cdn缓存清除 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Seata的AT模式分析</title>
      <link href="/2022/03/01/seata-de-at-mo-shi-fen-xi/"/>
      <url>/2022/03/01/seata-de-at-mo-shi-fen-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="Seata的AT模式分析-1-5-0版本"><a href="#Seata的AT模式分析-1-5-0版本" class="headerlink" title="Seata的AT模式分析(1.5.0版本)"></a>Seata的AT模式分析(1.5.0版本)</h1><h2 id="1-增强机制"><a href="#1-增强机制" class="headerlink" title="1 增强机制"></a>1 增强机制</h2><p>SeataAutoConfiguration中的GlobalTransactionScanner，主要用来代理@GlobalTransactional注解和客户端RM和TM的注册</p><h3 id="1-1-GlobalTransactionScanner的实例化"><a href="#1-1-GlobalTransactionScanner的实例化" class="headerlink" title="1.1 GlobalTransactionScanner的实例化"></a>1.1 GlobalTransactionScanner的实例化</h3><h4 id="1-1-1-bean的自动代理"><a href="#1-1-1-bean的自动代理" class="headerlink" title="1.1.1 bean的自动代理"></a>1.1.1 bean的自动代理</h4><p>​<strong>GlobalTransactionScanner继承了AbstractAutoProxyCreator抽象类，具有了自动代理bean的功能</strong>。作为一个BeanPostProcessor，将在postProcessAfterInitialization方法调用时判断该bean是否应该被代理（对于AT模式，就是当前bean的class或method必须有@GlobalTransactional或@GlobalLock注解），最终被GlobalTransactionalInterceptor拦截。</p><h4 id="1-1-2-初始化"><a href="#1-1-2-初始化" class="headerlink" title="1.1.2 初始化"></a>1.1.2 初始化</h4><p>​<strong>GlobalTransactionScanner也实现了InitializingBean接口，在afterPropertiesSet方法中，将会对TM和RM进行初始化</strong></p><h5 id="1-1-2-1-TM初始化"><a href="#1-1-2-1-TM初始化" class="headerlink" title="1.1.2.1 TM初始化"></a>1.1.2.1 TM初始化</h5><ul><li><p>实例化TmNettyRemotingClient对象（会创建好netty客户端的Bootstrap相关配置，等待后续init使用）</p></li><li><p>开始<strong>初始化TmNettyRemotingClient，先注册一些ResponseProcessor，用来处理server端回传的respons</strong>e（因为时TM，所以只会注册和全局事务的begin，commit，rolback等相关response的Processor，具体类型如下）</p><blockquote><p> MessageType.TYPE_SEATA_MERGE_RESULT</p><p> MessageType.TYPE_GLOBAL_BEGIN_RESULT</p><p> MessageType.TYPE_GLOBAL_COMMIT_RESULT</p><p> MessageType.TYPE_GLOBAL_REPORT_RESULT</p><p> MessageType.TYPE_GLOBAL_ROLLBACK_RESULT</p><p> MessageType.TYPE_GLOBAL_STATUS_RESULT</p><p> MessageType.TYPE_REG_CLT_RESULT</p></blockquote></li><li><p>开启一些定时任务，包括与服务端Channel的reconnect任务、<strong>MergedSend任务（处理批量消息发送）</strong>、future的超时检测任务。</p></li><li><p>启动和TM相关的netty客户端的Bootstrap，添加对应的ChannelHandler，包括IdleStateHandler（心跳检测，会进行ping-pong操作）、解码和编码器、<strong>ClientHandler（双向handler，开始真正处理数据，同时也处理IdleStateHandler发来的IdleStateEvent事件，判断后是否进行ping-pong，以此维护长连接）</strong></p></li></ul><h5 id="1-1-2-2-RM初始化"><a href="#1-1-2-2-RM初始化" class="headerlink" title="1.1.2.2 RM初始化"></a>1.1.2.2 RM初始化</h5><ul><li><p>实例化RmNettyRemotingClient对象，和上面类似，也会创建好netty客户端的Bootstrap相关配置</p></li><li><p>开始<strong>初始化RmNettyRemotingClient，也会先注册一些ResponseProcessor，用来处理server端回传的response</strong>（因为时RM，所以只会注册资源（可以理解成数据库）相关的操作，具体类型如下）</p><ul><li><blockquote><p>MessageType.TYPE_BRANCH_COMMIT</p><p>MessageType.TYPE_BRANCH_ROLLBACK</p><p>MessageType.TYPE_RM_DELETE_UNDOLOG</p><p>MessageType.TYPE_SEATA_MERGE_RESUL</p><p>MessageType.TYPE_BRANCH_REGISTER_RESULT</p><p>MessageType.TYPE_BRANCH_STATUS_REPORT_RESULT</p><p>MessageType.TYPE_GLOBAL_LOCK_QUERY_RESULT</p><p>MessageType.TYPE_REG_RM_RESULT</p></blockquote></li></ul></li><li><p>和上面一样，开启RM相关的netty bootstrap并注册相同的ChannelHandler</p></li></ul><h3 id="1-2-相关表"><a href="#1-2-相关表" class="headerlink" title="1.2 相关表"></a>1.2 相关表</h3><ul><li><strong>undo_log</strong>：客户端的表，保存修改数据sql操作前后镜像值，主要用于全局事务回滚来构造回滚sql以回滚数据</li><li><strong>global_session</strong>：服务端表，每一条记录都代表一个全局事务</li><li><strong>branch_session</strong>：服务端表，每一条记录都代表一个从客户端注册的分支事务</li><li><strong>lock_table</strong>：服务端表，客户端在全局事务期间修改的数据，每一条记录了某个数据库每个表的具体某个行的主键值，用在多个全局事务期间解决写冲突。</li></ul><h2 id="2-重要术语"><a href="#2-重要术语" class="headerlink" title="2 重要术语"></a>2 重要术语</h2><h3 id="2-1-RM（Resource-Manager）"><a href="#2-1-RM（Resource-Manager）" class="headerlink" title="2.1 RM（Resource Manager）"></a>2.1 RM（Resource Manager）</h3><p>​资源管理器，管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</p><p>​<strong>作用在seata客户端，代码实现中和DatsSource的代理绑定，负责和数据库相关的操作打交道，默认实现为DefaultResourceManager（仅是一个适配器，针对不同的模式适配了不同的ResourceManager实现。比如AT模式的默认实现是DataSourceManager）</strong>。在Connection的commit中，负责向server端注册当前分支事务；在Connection的rollback中，负责向server端报告当前分支事务的错误状态。同时也处理服务端发送过来的分支事务commit（删除undo_log）或rollback（生成补偿sql并执行）操作。</p><h3 id="2-2-TM（Transaction-Manager）"><a href="#2-2-TM（Transaction-Manager）" class="headerlink" title="2.2 TM（Transaction Manager）"></a>2.2 TM（Transaction Manager）</h3><p>​ 事务管理器，开始全局事务、提交或回滚全局事务。</p><p>​<strong>作用在seata客户端，代码实现中和@GlobalTransactional的拦截打交道，，默认实现为DefaultTransactionManager。负责开启、commit或rollback全局事务（commit和rollback操作只是向server发起这个请求了，具体的还需要TC和RM来执行真正的数据处理）</strong>。三个核心方法如下</p><ul><li><strong>begin</strong>：向server发送开启全局事务的请求。<strong>server端会创建一条global_session数据来表示这个全局事务</strong>，并回传给TM对应的xid</li><li><strong>commit</strong>：向server端发起全局事务的commit。server端具体做法如下（<strong>从第二个操作开始，就会异步处理了，因为这之后的操作基本就是删除些用来支持全局事务的数据，不会再对分支事务修改的数据有影响了</strong>）。<strong>所以，commit操作是很快的，TM只需等待TC删除掉锁信息即可</strong><ul><li>修改global_session状态，<strong>释放锁资源（即删除lock_table对应的记录）</strong></li><li>拿到这个global_session关联的branch_session，依次<strong>触发branch_session的commit（即发送请求到RM，RM会删除掉branch_session对应的undo_log数据）</strong></li><li><strong>server端删除对应的branch_session记录</strong></li><li>全部branch_session操作完成后，TC开始修改global_session状态为完毕然后<strong>删除这个global_session</strong></li><li>返回对应的GlobalStatus状态给TM。至此，全局事务commit完毕</li></ul></li><li><strong>rollback</strong>：向server端发起全局事务的rollback。server端具体做法如下<ul><li>设置对应的global_session状态为关闭，避免新分支的注册</li><li>拿到这个global_session关联的branch_session，依次<strong>触发branch_session的rollback（即发送请求到RM，RM会拿出这个branch_session对应的undo_log数据，并进行undo操作，复原数据）</strong></li><li><strong>server端删除对应的branch_session记录</strong></li><li><strong>全部branch_session操作rollback成功后，TC再释放锁资源（即删除lock_table对应的记录），并删除对应的global_session数据</strong></li><li>返回对应的GlobalStatus状态给TM。至此，全局事务rollback完毕</li></ul></li></ul><h3 id="2-3-TC（Transaction-Coordinator）"><a href="#2-3-TC（Transaction-Coordinator）" class="headerlink" title="2.3 TC（Transaction Coordinator）"></a>2.3 TC（Transaction Coordinator）</h3><p>​事务协调者，作用在seata服务端，维护全局和分支事务的状态，驱动全局事务提交或回滚，<strong>默认实现为DefaultCoordinator</strong>。</p><p>​与RM打交道，实现分支事务的注册等，并在TM发起全局事务的commit和rollback后再驱动分支事务的commit和rollback。</p><p>​和TM打交道，实现全局事务的开启、commit和rollback等操作</p><h3 id="2-4-全局事务的发起者"><a href="#2-4-全局事务的发起者" class="headerlink" title="2.4 全局事务的发起者"></a>2.4 全局事务的发起者</h3><p>​<strong>全局事务的起点，微服务调用链走到@GlobalTransactional时，线程上线文不存在xid（有可能是第一次发起，也有可能时事务传播策略导致新建的全局事务等）。类比spring提供的事务传播策略中的新建事务。只有全局事务的发起者才能开启一个全局事务，并根据是否产生回滚异常来决定是否全局事务的提交或全局事务的回滚</strong></p><h3 id="2-5-全局事务的参与者"><a href="#2-5-全局事务的参与者" class="headerlink" title="2.5 全局事务的参与者"></a>2.5 全局事务的参与者</h3><p>​<strong>处于微服务调用链中全局事务内部，参与到了其他上游服务发起的全局事务（这时线程上下文存在xid）。类比spring提供的事务传播策略中的加入了已存在的事务，所以，全局事务的参与者不能触发全局事务的回滚或提交。只能由RM来报告当前分支事务的状态（触发rollback后，分支事务状态变为PhaseOne_Failed）</strong></p><h3 id="2-6-分支事务和全局事务"><a href="#2-6-分支事务和全局事务" class="headerlink" title="2.6 分支事务和全局事务"></a>2.6 分支事务和全局事务</h3><p>全局事务：整个分布式事务，由多个分支事务组成</p><p>分支事务：分布式事务中整个链路里每个服务单独的事务，不可能跨服务存在。运行在spring事务的支持下，一个本地事务就是一个分支事务。没有被本地事务支持但运行在全局事务下，则一个dml sql就会生成一个分支事务</p><h2 id="三、服务端初始化"><a href="#三、服务端初始化" class="headerlink" title="三、服务端初始化"></a>三、服务端初始化</h2><p>服务端就是一个springboot项目，启动类是<strong>ServerApplication，核心启动方法是io.seata.server.Server#start</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// io.seata.server.Server#start 方法里的一些主要功能（删除了些不重要的）</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 统计相关功能初始化</span>    MetricsManager<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 设置数据保存模式（db，file，或redis）</span>    System<span class="token punctuation">.</span><span class="token function">setProperty</span><span class="token punctuation">(</span>ConfigurationKeys<span class="token punctuation">.</span>STORE_MODE<span class="token punctuation">,</span> parameterParser<span class="token punctuation">.</span><span class="token function">getStoreMode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ThreadPoolExecutor workingThreads <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>NettyServerConfig<span class="token punctuation">.</span><span class="token function">getMinServerPoolSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            NettyServerConfig<span class="token punctuation">.</span><span class="token function">getMaxServerPoolSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> NettyServerConfig<span class="token punctuation">.</span><span class="token function">getKeepAliveTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>            <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>NettyServerConfig<span class="token punctuation">.</span><span class="token function">getMaxTaskQueueSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token keyword">new</span> <span class="token class-name">NamedThreadFactory</span><span class="token punctuation">(</span><span class="token string">"ServerHandlerThread"</span><span class="token punctuation">,</span> NettyServerConfig<span class="token punctuation">.</span><span class="token function">getMaxServerPoolSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor<span class="token punctuation">.</span>CallerRunsPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 创建netty相关对象</span>    NettyRemotingServer nettyRemotingServer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NettyRemotingServer</span><span class="token punctuation">(</span>workingThreads<span class="token punctuation">)</span><span class="token punctuation">;</span>    nettyRemotingServer<span class="token punctuation">.</span><span class="token function">setListenPort</span><span class="token punctuation">(</span>parameterParser<span class="token punctuation">.</span><span class="token function">getPort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 创建TC</span>    DefaultCoordinator coordinator <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultCoordinator</span><span class="token punctuation">(</span>nettyRemotingServer<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 启动一些定时任务，包括 异步全局事务commit操作等</span>    coordinator<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    nettyRemotingServer<span class="token punctuation">.</span><span class="token function">setHandler</span><span class="token punctuation">(</span>coordinator<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//127.0.0.1 and 0.0.0.0 are not valid here.</span>    <span class="token comment" spellcheck="true">// 设置服务端netty的ip和端口</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>NetUtil<span class="token punctuation">.</span><span class="token function">isValidIp</span><span class="token punctuation">(</span>parameterParser<span class="token punctuation">.</span><span class="token function">getHost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        XID<span class="token punctuation">.</span><span class="token function">setIpAddress</span><span class="token punctuation">(</span>parameterParser<span class="token punctuation">.</span><span class="token function">getHost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        XID<span class="token punctuation">.</span><span class="token function">setIpAddress</span><span class="token punctuation">(</span>NetUtil<span class="token punctuation">.</span><span class="token function">getLocalIp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    XID<span class="token punctuation">.</span><span class="token function">setPort</span><span class="token punctuation">(</span>nettyRemotingServer<span class="token punctuation">.</span><span class="token function">getListenPort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 注册消息处理器并构建netty的ServerBootstrap，开启端口的监听</span>    nettyRemotingServer<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="四、客户端初始化"><a href="#四、客户端初始化" class="headerlink" title="四、客户端初始化"></a>四、客户端初始化</h2><p>​客户端初始化主要是通过两个自动代理bean来实现的</p><ul><li><strong>GlobalTransactionScanner</strong>：代理**@GlobalTransactional和@GlobalLock注解标志的类或方法，统一使用GlobalTransactionalInterceptor进行拦截**</li><li><strong>SeataAutoDataSourceProxyCreator</strong>：代理DataSource类。<strong>原来执行sql的流程 DataSource -&gt; Connection -&gt; Statement -&gt; 开始执行sql，变为了DataSourceProxy -&gt; ConnectionProxy -&gt; StatementProxy</strong>（<strong>DataSourceProxy里代理commit相关操作，和server通信。StatementProxy则代理执行sql的逻辑，处理执行前后镜像数据并生成undo数据，以便后续的rollback操作</strong>）</li></ul><h2 id="五、一个完整的全局事务流程（db模式）"><a href="#五、一个完整的全局事务流程（db模式）" class="headerlink" title="五、一个完整的全局事务流程（db模式）"></a>五、一个完整的全局事务流程（db模式）</h2><h3 id="5-1-GlobalTransactional注解拦截"><a href="#5-1-GlobalTransactional注解拦截" class="headerlink" title="5.1 @GlobalTransactional注解拦截"></a>5.1 @GlobalTransactional注解拦截</h3><p>拦截器：GlobalTransactionalInterceptor</p><blockquote><p>​这里有个参数：<strong>client.tm.degradeCheck</strong>（是否开启降级检查，默认为false）。</p><p>​当启用该参数时，会开启一个定时任务，间隔时间受参数<strong>client.tm.degradeCheckPeriod</strong>控制（默认为2000毫秒），向服务端发送全局事务的开启和提交测试，以此来判断服务端的全局事务当前是否支持。</p><p>​如果出现<strong>client.tm.degradeCheckAllowTimes</strong>次连续检查失败，则禁用当前全局事务支持，不走GlobalTransactionalInterceptor的代理逻辑。</p><p>​而当降级后，又需要连续检查成功<strong>client.tm.degradeCheckAllowTimes</strong>次才会再次开启全局事务的支持</p></blockquote><ol><li><p>通过上面的参数检查，判断当前请求是否支持全局事务，当支持全局事务时，优先走@GlobalTransactional逻辑，因为全局事务也包括了数据库锁，其次再走@GlobalLock逻辑。</p></li><li><p>解析@GlobalTransactional注解，获取当前环境的xid（如果存在xid则代表当前全局事务是参与者，发起者为上游服务，创建DefaultGlobalTransaction为参与者角色。不存在则代表当前全局事务是发起者）</p></li><li><p>传播策略的检查和支持，类似spring，锁重试设置，开启全局事务</p></li></ol><h3 id="5-2-全局事务开启"><a href="#5-2-全局事务开启" class="headerlink" title="5.2 全局事务开启"></a>5.2 全局事务开启</h3><p><strong>io.seata.tm.api.GlobalTransaction#begin</strong> 方法</p><ol><li>判断当前全局事务的角色，全局事务的发起者才需要真正的开启全局事务，而全局事务的参与者不需要开启全局事务，只需要等待分支事务提交时加入到当前xid的全局事务就行</li><li>全局事务的发起者此时还未向服务端发起的，所以xid肯定为空，先校验一下</li><li>向服务端发送全局事务开启的请求</li><li>服务端收到这个全局事务的开启请求后，创建GlobalSession（根据ID生成器生成唯一的transactionId和xid），并将GlobalSession转换为GlobalTransactionDO在保存到数据库的global_table表中，至此，全局事务开启，信息保存成功，最后再将xid返回给客户端</li><li>客户端收到服务端传来的xid，将其保存到当前线程的上下文中。并应该在后续的调用其他业务服务时传递该xid，串联起来这个全局事务</li></ol><h3 id="5-3-执行业务代码"><a href="#5-3-执行业务代码" class="headerlink" title="5.3 执行业务代码"></a>5.3 执行业务代码</h3><p>​任何一个SQL的执行操作，无非就是先获取DataSource，在通过DataSource获取Connection，通过Connection获取Statement，Statement准备sql和参数，再执行Statement并处理结果集，返回结果</p><p>​所以，追根溯源，要支持分布式事务，就需要控制DataSource的一系列的行为，<strong>SeataAutoDataSourceProxyCreator</strong>就在这里发挥了作用</p><h4 id="1、数据源的自动代理，SeataAutoDataSourceProxyCreator类，wrapIfNecessary方法"><a href="#1、数据源的自动代理，SeataAutoDataSourceProxyCreator类，wrapIfNecessary方法" class="headerlink" title="1、数据源的自动代理，SeataAutoDataSourceProxyCreator类，wrapIfNecessary方法"></a>1、数据源的自动代理，SeataAutoDataSourceProxyCreator类，wrapIfNecessary方法</h4><p>逻辑：只对DataSource代理，且会进行重复代理的判断，构造切面：SeataAutoDataSourceProxyAdvice。最终将原DataSource和SeataDataSourceProxy的关系放入DataSourceProxyHolder类中，方便后续的取出</p><h4 id="2、数据源方法的切入"><a href="#2、数据源方法的切入" class="headerlink" title="2、数据源方法的切入"></a>2、数据源方法的切入</h4><p><strong>SeataAutoDataSourceProxyAdvice</strong>代理了DataSource类的任何操作，其代理逻辑：</p><blockquote><ol><li>先判断是否需要走切面逻辑（全局锁需要，且存在AT模式的全局事务），不需要走切面逻辑的直接走原逻辑，通过原DataSource完成一系列操作。</li><li>需要走代理逻辑的流程：通过当前<strong>DataSource</strong>拿到对应的<strong>SeataDataSourceProxy</strong>（<strong>DataSourceProxyHolder</strong>发挥作用），走对应代理类的相同方法，获取代理的<strong>Connection（ConnectionProxy）</strong>，创建当前Connection的<strong>ConnectionContext</strong>，用来保存当前Connection的全局事务信息。创建<strong>StatementProxy</strong>， 拦截Statement的execute方法，根据druid或其他工具解析sql。最终会走到<strong>io.seata.rm.datasource.exec.AbstractDMLBaseExecutor#doExecute</strong>这个方法执行</li></ol></blockquote><h4 id="3、Statement的执行"><a href="#3、Statement的执行" class="headerlink" title="3、Statement的执行"></a>3、Statement的执行</h4><ol><li><p>普通的select语句因为不会涉及到数据修改，就不会申请锁资源。所以直接走原Statement直接执行。</p></li><li><p>而其他会修改数据的sql（比如 insert，update，delete，select_for_update等），走代理。具体逻辑：在执行原SQL之前，通过原sql构造出select语句，来查询更新字段的执行前镜像值，封装成TableRecords。之后再执行原SQL，执行后再查询更新字段的执行后镜像值，封装成TableRecords，最后再将两次的TableRecords封装成SQLUndoLog，暂放内存中，等待分支事务commit再写入库</p></li></ol><p><strong>io.seata.rm.datasource.exec.AbstractDMLBaseExecutor#doExecute会对当前Connection是否自动提交做判断，为什么呢？</strong></p><blockquote><p>​假如在一个分布式事务中，我们只使用了seata的@GlobalTransactional注解而没有用spring的@Transactional注解控制本地事务，其实也是支持的。</p><p>​当不存在本地事务时，事务都是走的autoCommit的。seata在这里先判断了一下，如果没开启本地事务，单个语句就为一个事务，seata其实还是设置当前事务为手动提交，设置autoCommit为false（因为还有undo_log的写入），然后走seata流程的分支事务提交。所以，当不存在本地事务，任何一个语句就是一个分支事务。</p><p>​在一个服务中，开启了本地事务的地方算一个分支事务，有相同的xid，而未开启本地事务的代码里，每一个update,delete,insert等语句都算一个分支事务，由seata来控制全局事务的一致性。所以，未开启本地事务但只用seata的全局事务也是可以的，但是性能影响会比较大，因为这里由一个分支事务变成多个分支事务了，每一个分支事务都会涉及到与服务端的通信，数据库锁检查，undo_log的写库等操作。</p></blockquote><h4 id="4、分支事务的提交（rpc通过Netty发送commit到服务端）"><a href="#4、分支事务的提交（rpc通过Netty发送commit到服务端）" class="headerlink" title="4、分支事务的提交（rpc通过Netty发送commit到服务端）"></a>4、分支事务的提交（rpc通过Netty发送commit到服务端）</h4><ol><li><p>锁检查（lock_table表），将变化的数据构造为row_key，一个row_key能唯一确定某一行数据</p></li><li><p>已经被其他全局事务占用了数据锁，则所失败，抛出LockConflictException异常并开始重试，默认重试30次，重试间隔为10ms</p></li><li><p>数据未被其他全局事务上锁，则当前全局事务对数据上锁（写入到lock_table表），创建BranchSession，关联xid，再转换为BranchTransactionDO并保存到branch_table表，在返回给客户端branchId。</p></li><li><p>刷新当前分支事务内存中所有的undo_log到数据库的undo_log表，分支事务commit，清除当前Connection的ConnectionContext里全局事务相关信息。到这里，分支事务就已经commit成功了，且进行了写隔离</p></li></ol><h4 id="5、调用其他业务服务的接口"><a href="#5、调用其他业务服务的接口" class="headerlink" title="5、调用其他业务服务的接口"></a>5、调用其他业务服务的接口</h4><ol><li><p>调用其他服务，需要将xid在服务间传递（当前版本好像还没支持feign的，自己实现也简单，请求头加个TX_XID，把xid传过去就行），其他服务设置了spring的拦截器，获取TX_XID，并绑定到当前线程，等待后续判断</p></li><li><p>其他业务服务的流程和上面一样：解析sql，构造镜像，保存undo_log，锁检查，注册分支事务，commit</p></li></ol><h3 id="5-4-业务代码执行完毕，全局事务的回滚或提交流程"><a href="#5-4-业务代码执行完毕，全局事务的回滚或提交流程" class="headerlink" title="5.4 业务代码执行完毕，全局事务的回滚或提交流程"></a>5.4 业务代码执行完毕，全局事务的回滚或提交流程</h3><h4 id="1、全局事务回滚"><a href="#1、全局事务回滚" class="headerlink" title="1、全局事务回滚"></a>1、全局事务回滚</h4><ol><li><p>业务代码抛出异常，且命中回滚异常，触发全局回滚（io.seata.tm.api.DefaultGlobalTransaction#rollback），但这里<strong>只支持全局事务的发起者调用回滚，全局事务的参与者是不能全局事务回滚的</strong>。所以，只有全局事务的发起者出现了异常并命中回滚策略才会触发全局回滚，全局事务的参与者则不能，所以可能导致参与者回滚了，但不抛异常，发起者没有命中回滚，导致发起者全局事务正常commit了，但部分参与者却回滚了，导致没有全部保证一致性。</p></li><li><p>发送全局事务回滚请求到服务端，回滚逻辑</p></li></ol><blockquote><ol><li>GlobalSession的状态校验</li><li>获取这个GlobalSession的所有BranchSession，遍历触发每一个分支事务的回滚</li><li>分支事务回滚，发送请求给客户端，找到当前分支事务的undo_log，对镜像前后进行比较，不同的需要补偿（update就用update，insert用delete，delete用insert等），还原事务前的数据</li><li>分支事务的undo_log删除，返回状态给服务端</li><li>服务端对状态的判断和处理，删除分支事务（branch_session）</li></ol></blockquote><h4 id="2、全局事务提交"><a href="#2、全局事务提交" class="headerlink" title="2、全局事务提交"></a>2、全局事务提交</h4><ol><li><p>类似全局事务回滚，也只有全局事务的发起者才能真正的提交</p></li><li><p>发送全局事务提交请求到服务端，提交逻辑</p></li></ol><blockquote><ol><li>释放相关的锁资源：遍历当前全局事务的所有分支事务，逐个将每个分支事务关联的锁资源删除（lock_table表相关的记录）</li><li>判断是否支持异步提交（AT模式是支持的，因为现在锁资源已经释放了，不用在担心会影响到其他全局事务，剩下的只需要把相关的undo_log删除即可），将globalSession状态更新为异步提交中，并更新到数据库中（global_table表）去，在直接返回给客户端已提交</li><li>异步提交：由定时任务线程池触发（Server启动时创建的DefaultCoordinator初始化异步提交定时任务下线程池，默认定时任务时间间隔为1秒），查询所有的异步提交状态的global_session，并将其关联的branch_session全部查出来，遍历每个global_session并开始全局事务的提交</li><li>全局事务的真正提交：遍历global_session中关联的每一个branch_session，发送提交任务到对应的客户端（根据resourceId和clientId查找对应客户端的Channel），客户端收到全局事务的commit请求，将请求封装成Phase2Context对象并扔进待提交队列，等待客户端的定时任务线程池提交，然后直接返回给服务端分支事务已提交的状态</li><li>客户端定时任务线程池提交全局事务逻辑：将所有的Phase2Context按资源分组（在seata的AT模式下，一个资源就可以代表一个数据库），具有相同资源的待提交任务处于同一个数据库里，可以用相同的Connection。通过资源管理器获取获取数据源代理，再通过这个数据源代理拿到原Connection（以免这些更新语句又走了代理，创建了undo_log），在批量删除对应的undo_log。</li><li>当所有分支事务提交完成后（undo_log删除完成），最后再server端删除对应的GlobalSession记录</li></ol></blockquote><h3 id="5-5-全局事务结束"><a href="#5-5-全局事务结束" class="headerlink" title="5.5 全局事务结束"></a>5.5 全局事务结束</h3><ol><li><p>如果当前全局事务是嵌套的，需要恢复上一个全局事务的状态（包括全局锁配置：锁失败的重试次数和时间间隔，恢复上一个全局事务的xid）</p></li><li><p>触发回调函数，和清除当前全局事务的钩子函数</p></li></ol><p>至此，全局事务的流程已全部结束</p><h2 id="六、全局事务锁冲突和重试的实现"><a href="#六、全局事务锁冲突和重试的实现" class="headerlink" title="六、全局事务锁冲突和重试的实现"></a>六、全局事务锁冲突和重试的实现</h2><h3 id="6-1-写隔离和锁重试的实现"><a href="#6-1-写隔离和锁重试的实现" class="headerlink" title="6.1 写隔离和锁重试的实现"></a>6.1 写隔离和锁重试的实现</h3><p>​seata在客户端执行更新数据相关的sql时，会记录sql操作前后的镜像值到undo_log中，同时据此准备lockKeys暂存起来，lockKeys就是变化的数据唯一标识（比如表明，主键列的值等）。在客户端的本地事务提交时，先注册当前分支事务（<strong>利用RM的branchRegister接口</strong>）。seata服务端的TC开始尝试注册分支事务，尝试步骤：</p><ul><li><p>先对全局事务进行状态检查</p></li><li><p>利用客户端传来的信息构造BranchSession</p></li><li><p><strong>对BranchSession尝试加锁（AT模式才会）</strong></p></li><li><p><strong>通过对锁信息的一系列检查和转化，到达LockStoreDataBaseDAO#acquireLock(java.util.List&lt;io.seata.core.store.LockDO&gt;)接口</strong></p></li><li><p>查询lock_table中对应row_key存在的数据（这个row_key就是行锁，能唯一标识客户端某个数据库里某个表的某行数据）</p><ul><li><p>如果没查询出来，代表写锁不冲突，将这些锁资源保存在lock_table中，直接返回加锁成功</p></li><li><p>如果查询出来了，且这些数据还是当前全局事务（xid一致），代表重复枷锁而已，只需要将原本不存在的所数据保存到lock_table中，就可返回枷锁成功</p></li><li><p>查询出来，且有其他全局事务占用当前资源，直接返回加锁失败。由io.seata.server.transaction.at.ATCore#branchSessionLock直接抛出异常码为LockKeyConflict的异常，代表写锁冲突</p></li></ul></li><li><p>加锁成功就不说了，直接向下走。<strong>而加锁失败，由服务端的AbstractCallback捕获异常，并转化为对应消息，发送给客户端</strong></p></li><li><p><strong>客户端的ConnectionProxy#recognizeLockKeyConflictException方法检测到是锁冲突异常，又抛出LockConflictException异常</strong></p></li><li><p><strong>客户端的LockRetryPolicy#doRetryOnLockConflict捕获到LockConflictException异常，开始重试（默认重试30次，间隔时间为10毫秒）</strong></p></li><li><p><strong>如果30次还是重试失败，转为LockWaitTimeoutException异常，触发客户端本地事务的回滚</strong></p></li></ul><h2 id="7-思考"><a href="#7-思考" class="headerlink" title="7 思考"></a>7 思考</h2><h3 id="7-1-必须保证全局事务范围大于等于分支事务（spring提供的事务注解等）"><a href="#7-1-必须保证全局事务范围大于等于分支事务（spring提供的事务注解等）" class="headerlink" title="7.1 必须保证全局事务范围大于等于分支事务（spring提供的事务注解等）"></a>7.1 必须保证全局事务范围大于等于分支事务（spring提供的事务注解等）</h3><p>​假如全局事务的范围小于分支事务：全局事务的发起者先是进行全局事务的提交，再进行本地事务的提交。在全局事务提交时，本地事务都还没提交（本地事务提交时才会注册当前分支事务到server端），所以在server端不会有任何当前全局事务发起者客户端的分支事务，在server端触发分支事务提交时也不会发送给当前客户端，所以，对于当前客户端来说全局事务的提交就是个空提交（但对其他全局事务的参与者不是）。而全局事务在server端的提交又是个异步的过程，所以当客户端提交本地事务时，可能会出现以下错误</p><ul><li>全局事务提交完毕<strong>：server的全局事务操作完毕后会删掉GlobalSessiob，所以，当客户端的本地事务提交，向server端注册分支事务时，会导致xid不存在异常（这个xid已经随着全局事务的终结给删掉了）</strong></li><li>全局事务正在提交：<strong>虽然在server端全局事务是异步提交的，但在这之前全局事务的状态会先设为AsyncCommitting（这一步和客户端提交全局事务是同步的）。所以，在客户端向server注册分支事务时，server端会先校验全局事务xid的状态，发现全局事务状态不为Begin，抛出全局事务异常</strong></li></ul><p>​为什么范围可以等于，因为全局事务拦截器的<strong>io.seata.spring.annotation.GlobalTransactionalInterceptor#getPosition接口默认将@GlobalTransactional拦截放在了@Transactional的前面，拦截器也类似栈结构（先进后出）</strong>。先进入@GlobalTransactional拦截方法，再进入@Transactional拦截方法，先从@Transactional拦截方法出，之后再从@GlobalTransactional方法出来。保证了在全局事务提交前，本地事务已经注册了。</p><p><strong>综上，@GlobalTransactional和spring的@Transactional的正确搭配：</strong></p><p>​@GlobalTransactional范围要大于等于@Transactional，最好是两个作用域一样（即可保证事务正常进行，又可减少客户端的分支事务，减少与server端的通信等）</p><h3 id="7-2-全局事务的参与者回滚异常一定让全局事务的发起者感知到"><a href="#7-2-全局事务的参与者回滚异常一定让全局事务的发起者感知到" class="headerlink" title="7.2 全局事务的参与者回滚异常一定让全局事务的发起者感知到"></a>7.2 全局事务的参与者回滚异常一定让全局事务的发起者感知到</h3><p>​由于全局事务的参与者本地rollback时，只会通过RM向服务端报告当前分支是的状态为PhaseOne_Failed。如果参与者本地回滚后，全局事务的发起者不能感知到参与者的回滚，而触发了全局事务发起者的commit，这时在服务端的io.seata.server.coordinator.DefaultCore#doGlobalCommit方法中（全局事务发起者向server端发送全局事务提交），TC获取到全局事务的所有分支事务时，如果某个分支事务状态为PhaseOne_Failed（即这个分支事务本地rollback了），TC也仅仅是删除这个分支事务，不会触发全局回滚，全局事务从整体上来说还是提交，就造成了参发起者commit，这个参与者rollback，分布式事务逻辑上就失败了。</p><p>​所以，参与者的回滚一定要让发起者感知到，并让发起者触发全局事务的回滚，这样，全局事务才是原子性的操作。</p><h3 id="7-3-seata做的一系列程序健壮性支持"><a href="#7-3-seata做的一系列程序健壮性支持" class="headerlink" title="7.3 seata做的一系列程序健壮性支持"></a>7.3 seata做的一系列程序健壮性支持</h3><h4 id="7-3-1-降级检查"><a href="#7-3-1-降级检查" class="headerlink" title="7.3.1 降级检查"></a>7.3.1 降级检查</h4><p>​降级检查是否开启由配置参数client.tm.degradeCheck管理，应用到GlobalTransactionalInterceptor#degradeCheck字段上，且支持热修改（比如consul上修改了这个参数，可以同步到客户端，实现不重启就可以开启或关闭降级检查），默认为false，表示不开启降级检查</p><p>​当开启降级检查时，在GlobalTransactionalInterceptor的构造器里会读取配置参数degradeCheckPeriod和degradeCheckAllowTimes，分别表示降级检查一次的时间间隔和连续超过指定次数后，将关闭或开启全局事务代理模式。再提交一个定时任务，去执行降级检查（代码实现GlobalTransactionalInterceptor#startDegradeCheck里）</p><p>GlobalTransactionalInterceptor#startDegradeCheck逻辑：</p><p>​按指定的degradeCheckPeriod毫秒时间间隔执行这个任务，里面开启一个空的全局事务，并马上提交（测试全局事务是否正常），根据是否通过来利用事件发布和通知机制（DegradeCheckEvent事件），通知对应得事件监听器处理对应得逻辑。监听代码在io.seata.spring.annotation.GlobalTransactionalInterceptor#onDegradeCheck里实现，连续失败degradeCheckAllowTimes次会开启降级，而在降级期间内，若连续成功degradeCheckAllowTimes则会取消降级。降级具体应用在io.seata.spring.annotation.GlobalTransactionalInterceptor#invoke，如果降级开启，则会禁用全局事务</p><h4 id="7-3-2-写锁冲突重试机制"><a href="#7-3-2-写锁冲突重试机制" class="headerlink" title="7.3.2 写锁冲突重试机制"></a>7.3.2 写锁冲突重试机制</h4><p>​参考6.1</p><h4 id="7-3-3-全局事务commit和rollback失败重试机制"><a href="#7-3-3-全局事务commit和rollback失败重试机制" class="headerlink" title="7.3.3 全局事务commit和rollback失败重试机制"></a>7.3.3 全局事务commit和rollback失败重试机制</h4><p>​全局事务提交和回滚的重试机制在io.seata.tm.api.DefaultGlobalTransaction里的commot和rollback里实现。受client.tm.commitRetryCount配置参数控制，默认重试5次。</p><h3 id="7-4-seata的分布式事务隔离级别"><a href="#7-4-seata的分布式事务隔离级别" class="headerlink" title="7.4 seata的分布式事务隔离级别"></a>7.4 seata的分布式事务隔离级别</h3><p>​传统数据库如oracle默认读已提交，mysql则通过mvcc和undo log实现了可重复读隔离级别，而<strong>seata实现的分布式事务也可工作在读已提交的隔离级别下</strong></p><p>如何实现的：</p><blockquote><p>​seata的分支事务进行本地commit操作时，会将改动的的数据构造成lockKeys，在分支事务注册到server时带上这些lockKeys，server端会对这些lockKey进行解析构建，并对其进行上锁，上锁成功的标志是成功将全部lockKeys保存到server短的lock_table表（可上锁的前提是lock_table表没有对应的lockKey数据）。在之后的分支事务的数据修改都会先对这些数据在server端上锁判断，以此实现类似数据库的互斥锁。</p><p>​但是，当分支事务A本地commit后，但此时全局事务还未commit。如果有另一个事务B读取到了事务A修改的数据结果，就会产生脏读（因为这时全局事务还未commit，甚至可能触发rollback操作），解决脏读的办法就是事务B读取使用select for update语句，并且被@GlobalTransactional和@GlobalLock注解拦截。拦截后seata内部会对select for update的操作进行锁判断，生成一个SelectForUpdateExecutor执行器（核心执行方法doExecute代码如下）。所以直到分支事务A对应的全局事务结束释放了锁资源后，事务B才会读到数据并返回，以此实现读已提交</p></blockquote><p>注意<strong>，@GlobalTransactional + select for update</strong>和**@GlobalLock + select for update都可实现select操作的读已提交隔离级别<strong>，</strong>但GlobalLock 更轻量级，它不会注册分支事务和加锁等操作，只会进行锁检查。所以，如果上述事务B不需要运行在全局事务或本地事务的模式先下而又想实现全局事务的读已提交隔离级别，就可使用@GlobalLock + select for update组合**</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// SelectForUpdateExecutor核心执行方法</span><span class="token keyword">public</span> T <span class="token function">doExecute</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>    Connection conn <span class="token operator">=</span> statementProxy<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    DatabaseMetaData dbmd <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">getMetaData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    T rs<span class="token punctuation">;</span>    Savepoint sp <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">boolean</span> originalAutoCommit <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">getAutoCommit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 在这里单独开启事务。如果没有原事务则直接开启，如果有则新建一个savepoint来开启事务</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>originalAutoCommit<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 没有原事务</span>            conn<span class="token punctuation">.</span><span class="token function">setAutoCommit</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>dbmd<span class="token punctuation">.</span><span class="token function">supportsSavepoints</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 有原事务，新建一个savepoint来开启内嵌事务</span>            sp <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">setSavepoint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">SQLException</span><span class="token punctuation">(</span><span class="token string">"not support savepoint. please check your db version"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        LockRetryController lockRetryController <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LockRetryController</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ArrayList<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Object<span class="token operator">>></span> paramAppenderList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String selectPKSQL <span class="token operator">=</span> <span class="token function">buildSelectSQL</span><span class="token punctuation">(</span>paramAppenderList<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// #870</span>                <span class="token comment" spellcheck="true">// execute return</span>                <span class="token comment" spellcheck="true">// executeQuery return ResultSet</span>                <span class="token comment" spellcheck="true">// 执行sql语句，会获取本地锁</span>                rs <span class="token operator">=</span> statementCallback<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>statementProxy<span class="token punctuation">.</span><span class="token function">getTargetStatement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// Try to get global lock of those rows selected</span>                TableRecords selectPKRows <span class="token operator">=</span> <span class="token function">buildTableRecords</span><span class="token punctuation">(</span><span class="token function">getTableMeta</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> selectPKSQL<span class="token punctuation">,</span> paramAppenderList<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 构建lock key</span>                String lockKeys <span class="token operator">=</span> <span class="token function">buildLockKey</span><span class="token punctuation">(</span>selectPKRows<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>StringUtils<span class="token punctuation">.</span><span class="token function">isNullOrEmpty</span><span class="token punctuation">(</span>lockKeys<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// lock key不存在，代表没有锁冲突，直接就break了</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>RootContext<span class="token punctuation">.</span><span class="token function">inGlobalTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> RootContext<span class="token punctuation">.</span><span class="token function">requireGlobalLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                     <span class="token comment" spellcheck="true">// 全局锁的获取和判断必须在@GlobalTransactional or @GlobalLock注解下</span>                    <span class="token comment" spellcheck="true">// 只进行锁检查，不加锁（检查失败内部会抛异常）</span>                    statementProxy<span class="token punctuation">.</span><span class="token function">getConnectionProxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">checkLock</span><span class="token punctuation">(</span>lockKeys<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"Unknown situation!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// 走到这就代表全局锁没有冲突（要查询的数据没有被多个事务同时处理），可直接返回了</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">LockConflictException</span> lce<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 全局锁冲突，本地事务先rollback，释放select .. for update获取到的锁</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>sp <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    conn<span class="token punctuation">.</span><span class="token function">rollback</span><span class="token punctuation">(</span>sp<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    conn<span class="token punctuation">.</span><span class="token function">rollback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// sleep后会再进行重试</span>                <span class="token comment" spellcheck="true">// trigger retry</span>                lockRetryController<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>lce<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 复原现场</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sp <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>JdbcConstants<span class="token punctuation">.</span>ORACLE<span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span><span class="token function">getDbType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    conn<span class="token punctuation">.</span><span class="token function">releaseSavepoint</span><span class="token punctuation">(</span>sp<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SQLException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                LOGGER<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"{} release save point error."</span><span class="token punctuation">,</span> <span class="token function">getDbType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>originalAutoCommit<span class="token punctuation">)</span> <span class="token punctuation">{</span>            conn<span class="token punctuation">.</span><span class="token function">setAutoCommit</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> rs<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式事务 </tag>
            
            <tag> seata </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jvm常用参数</title>
      <link href="/2022/02/04/jvm-chang-yong-can-shu-zheng-li/"/>
      <url>/2022/02/04/jvm-chang-yong-can-shu-zheng-li/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="1-jvm参数整理"><a href="#1-jvm参数整理" class="headerlink" title="1.jvm参数整理"></a>1.jvm参数整理</h2><ul><li><strong>-Xms64m</strong> ：初始堆大小</li><li><strong>-Xmx128m</strong> ：最大堆大小</li><li><strong>-Xmn32m</strong> ：年轻代大小</li><li><strong>-XX:MaxNewSize&#x3D;256m</strong> : 最大新生代大小</li><li><strong>-Xss512k</strong>：栈大小</li><li><strong>-XX:MetaspaceSize&#x3D;256M</strong> ：Metaspace扩容时触发FullGC的初始化阈值(并不是元空间的初始化大小，元空间是不断扩容的，当达到这个值时，就会触发full gc，<a href="https://www.jianshu.com/p/b448c21d2e71">链接</a>）</li><li><strong>-XX:MaxMetaspaceSize&#x3D;512M</strong>：Metaspace最大大小</li><li><strong>-XX:NewRatio&#x3D;2</strong>：老年代和新生代的比例</li><li><strong>-XX:SurvivorRatio&#x3D;8</strong> ：Eden区与一个Survivor区的大小比值（所以<strong>s0:s1:eden&#x3D;1:1:8</strong>）</li><li><strong>-XX:MinHeapFreeRatio&#x3D;40</strong>：空闲堆空间的最小百分比。如果空闲堆空间的比例小于它，则会进行堆扩容</li><li><strong>-XX:MaxHeapFreeRatio&#x3D;70</strong>：空闲堆空间的最大百分比。如果空闲堆空间的比例大于它，则会进行堆缩容</li><li><strong>-XX:-DisableExplicitGC</strong>：禁止显式GC，即禁止程序中System.gc()。个人感觉没必要</li><li><strong>-XX:+HeapDumpOnOutOfMemoryError</strong>：OOM时导出堆快照到文件</li><li><strong>-XX:HeapDumpPath&#x3D;&#x2F;home&#x2F;huskie&#x2F;gc&#x2F;oom.hprof</strong>：OOM时导出文件路径</li><li><strong>-Xloggc:</strong>&#x2F;home&#x2F;ruidong&#x2F;gc.log   gc存储日志</li><li><strong>-XX:OnOutOfMemoryError</strong>：OOM时操作，比如如执行脚本发送邮件</li><li><strong>-XX:+TraceClassLoading</strong>：打印加载类的详细信息</li><li><strong>-XX:+PrintGCDetails</strong>：打印GC详细信息</li><li><strong>-XX:+PrintGCTimeStamps</strong>：打印CG发生的时间戳（相对于项目启动时间）</li><li><strong>-XX:+PrintGCDateStamps</strong>：打印GC发生的时间</li><li><strong>-XX:+PrintHeapAtGC</strong>：每一次GC前和GC后，都打印堆信息</li><li><strong>-XX:+PrintClassHistogram</strong>：按下Ctrl+Break后，打印类的信息</li><li><strong>-XX:+PrintGCApplicationConcurrentTime</strong> ：打印应用程序的运行时间（许多事情会导致JVM暂停所有线程，停在安全点。gc也只是其中的一种，当暂停之后在重启应用线程，则会刷新这个时间（归0），在重新计数）<a href="http://ifeve.com/logging-stop-the-world-pauses-in-jvm/">链接</a></li><li><strong>-XX:+PrintGCApplicationStoppedTime</strong> ：打印应用线程暂停的时间，显示应用线程被暂停了多久和应用线程暂停到安全点花费的时间</li><li><strong>-XX:TargetSurvivorRatio&#x3D;50</strong> ：survivor空间的晋升大小空间百分比（默认为50）</li><li><strong>-XX:MaxTenuringThreshold&#x3D;15</strong>  ：年轻代晋升到老年代的最大年龄阈值(tenuring threshold)。默认值为 15[每次GC，增加1岁，到15岁如果还要存活，放入Old区]。<strong>jvm还会动态的计算晋升阈值，方法：依次从年龄为1的对象大小加起来，一直加到大小超过了 [（TargetSurvivorRatio * survivor_capacity）&#x2F; 100 ]值，这时加起来的最大年龄大小即为这次晋升的临界阈值</strong>（具体算法在：hotspot\src\share\vm\gc_implementation\shared\ageTable.cpp文件里，方法为compute_tenuring_threshold）</li><li><strong>-XX:+PrintTenuringDistribution</strong> ：ygc 时打印当前晋升年龄信息</li></ul><h2 id="2-垃圾收集器"><a href="#2-垃圾收集器" class="headerlink" title="2.垃圾收集器"></a>2.垃圾收集器</h2><h3 id="2-1-新生代"><a href="#2-1-新生代" class="headerlink" title="2.1 新生代"></a>2.1 新生代</h3><h4 id="2-1-1-Serial（hotspot虚拟机在客户端下的默认新生代垃圾收集器）"><a href="#2-1-1-Serial（hotspot虚拟机在客户端下的默认新生代垃圾收集器）" class="headerlink" title="2.1.1 Serial（hotspot虚拟机在客户端下的默认新生代垃圾收集器）"></a>2.1.1 Serial（hotspot虚拟机在客户端下的默认新生代垃圾收集器）</h4><p>单线程新生代收集器，复制算法，整个过程STW</p><p>优势：内存消耗最小</p><p>缺点：不适合大内存多处理器工作，慢</p><h4 id="2-1-2-ParNew"><a href="#2-1-2-ParNew" class="headerlink" title="2.1.2 ParNew"></a>2.1.2 ParNew</h4><p>多线程并行的新生代收集器，复制算法，整个过程STW</p><ul><li><strong>-XX:ParallelGCThreads&#x3D;4</strong> ：并行收集的线程数</li></ul><h4 id="2-1-3-Parallel-Scavenge"><a href="#2-1-3-Parallel-Scavenge" class="headerlink" title="2.1.3  Parallel Scavenge"></a>2.1.3  Parallel Scavenge</h4><ul><li>吞吐量 &#x3D; 运行用户代码时间 &#x2F; ( 运行用户代码时间 + 垃圾收集时间 )</li></ul><p>吞吐量优先的新生代并行多线程收集器，复制算法（<strong>标记-复制</strong>算法）</p><p>三个重要参数：</p><ul><li><strong>XX:MaxGCPauseMillis</strong> ：垃圾收集最大停顿时间，大于0的毫秒数</li><li><strong>-XX:GCTimeRatio</strong>: 大于0小于100的整数（运行用户代码时间比上垃圾回收的时间），默认为99，即允许最大1%的垃圾回收时间</li><li><strong>-XX:+UseAdaptiveSizePolicy</strong>：开启垃圾收集器的自适应调节策略。虚拟机动态调整新生代，Eden区，Survivor区的比例和晋升大小</li></ul><h3 id="2-2-老年代"><a href="#2-2-老年代" class="headerlink" title="2.2 老年代"></a>2.2 老年代</h3><h4 id="2-2-1-CMS"><a href="#2-2-1-CMS" class="headerlink" title="2.2.1 CMS"></a>2.2.1 CMS</h4><p><strong>标记-清除</strong>算法的老年代收集器</p><h4 id="2-2-2-Serial-Old"><a href="#2-2-2-Serial-Old" class="headerlink" title="2.2.2 Serial Old"></a>2.2.2 Serial Old</h4><p>Serial的老年代会收集，<strong>标记-整理</strong>算法</p><h4 id="2-2-3-Parallel-Scavenge-Old"><a href="#2-2-3-Parallel-Scavenge-Old" class="headerlink" title="2.2.3 Parallel Scavenge Old"></a>2.2.3 Parallel Scavenge Old</h4><p>Parallel Scavenge收集器的老年代版本，标记-整理算法</p><h3 id="2-3-整堆"><a href="#2-3-整堆" class="headerlink" title="2.3 整堆"></a>2.3 整堆</h3><h4 id="2-3-1-G1"><a href="#2-3-1-G1" class="headerlink" title="2.3.1 G1"></a>2.3.1 G1</h4><p>garbage-frist收集器</p><h3 id="2-4-垃圾收集器组合"><a href="#2-4-垃圾收集器组合" class="headerlink" title="2.4  垃圾收集器组合"></a>2.4  垃圾收集器组合</h3><h4 id="2-4-1-Serial-SerialOld"><a href="#2-4-1-Serial-SerialOld" class="headerlink" title="2.4.1 Serial + SerialOld"></a>2.4.1 Serial + SerialOld</h4><h4 id="2-4-2-Serial-CMS-jdk8声明废弃，jdk9已被取消"><a href="#2-4-2-Serial-CMS-jdk8声明废弃，jdk9已被取消" class="headerlink" title="2.4.2 Serial + CMS (jdk8声明废弃，jdk9已被取消)"></a>2.4.2 Serial + CMS (jdk8声明废弃，jdk9已被取消)</h4><h4 id="2-4-3-ParNew-CMS-（使用CMS收集器的默认组合"><a href="#2-4-3-ParNew-CMS-（使用CMS收集器的默认组合" class="headerlink" title="2.4.3 ParNew +CMS （使用CMS收集器的默认组合)"></a>2.4.3 ParNew +CMS （使用CMS收集器的默认组合)</h4><h4 id="2-4-4-ParNew-SerialOld-jdk8声明废弃，jdk9已被取消"><a href="#2-4-4-ParNew-SerialOld-jdk8声明废弃，jdk9已被取消" class="headerlink" title="2.4.4 ParNew + SerialOld (jdk8声明废弃，jdk9已被取消)"></a>2.4.4 ParNew + SerialOld (jdk8声明废弃，jdk9已被取消)</h4><h4 id="2-4-5-Parallel-Scavenge-SerialOld"><a href="#2-4-5-Parallel-Scavenge-SerialOld" class="headerlink" title="2.4.5 Parallel Scavenge +  SerialOld"></a>2.4.5 Parallel Scavenge +  SerialOld</h4><h4 id="2-4-6-Parallel-Scavenge-Parallel-Scavenge-Old（jdk8的默认组合）"><a href="#2-4-6-Parallel-Scavenge-Parallel-Scavenge-Old（jdk8的默认组合）" class="headerlink" title="2.4.6 Parallel Scavenge + Parallel Scavenge Old（jdk8的默认组合）"></a>2.4.6 Parallel Scavenge + Parallel Scavenge Old（jdk8的默认组合）</h4><h4 id="2-4-7-G1（jdk9的默认收集器，且CMS被标记为废弃了）"><a href="#2-4-7-G1（jdk9的默认收集器，且CMS被标记为废弃了）" class="headerlink" title="2.4.7 G1（jdk9的默认收集器，且CMS被标记为废弃了）"></a>2.4.7 G1（jdk9的默认收集器，且CMS被标记为废弃了）</h4><h2 id="3-tips"><a href="#3-tips" class="headerlink" title="3.tips"></a>3.tips</h2><ul><li><strong>java -XX:+PrintFlagsFinal -version</strong>  ：查看jvm默认参数。数据太多可配合grep使用</li></ul><h2 id="4-标记对象时-并发的可达性分析"><a href="#4-标记对象时-并发的可达性分析" class="headerlink" title="4. 标记对象时-并发的可达性分析"></a>4. 标记对象时-并发的可达性分析</h2><p>黑色对象：存活对象，且这个对象的全部引用都扫描过（代表不需要再次扫描了）</p><p>灰色对象：存活对象，但这个对象至少存在一个引用未被扫描（它持有的引用没扫描完）</p><p>白色对象：不可达对象，不会被扫描到</p><h4 id="1-问题：对象消失产生的原因（二者缺一不可）"><a href="#1-问题：对象消失产生的原因（二者缺一不可）" class="headerlink" title="1.问题：对象消失产生的原因（二者缺一不可）"></a>1.问题：对象消失产生的原因（二者缺一不可）</h4><blockquote><ol><li>黑色对象重新引用了白色对象</li><li>灰色对象删除了持有的该白色对象的全部引用</li></ol><p>为什么二者缺一不可：首先第一条，既然是重新引用了白色对象，那么代表这个白色对象一定是被引用在灰色对象上的，且这个灰色对象还没扫描到这个白色对象。第二，考虑到扫描灰色对象的工作还没做完，必须在做完前删除掉引用的这个白色对象</p></blockquote><h4 id="2-解决方式（二选一）"><a href="#2-解决方式（二选一）" class="headerlink" title="2.解决方式（二选一）"></a>2.解决方式（二选一）</h4><h5 id="1-增量更新（CMS收集器使用）"><a href="#1-增量更新（CMS收集器使用）" class="headerlink" title="1.增量更新（CMS收集器使用）"></a>1.增量更新（CMS收集器使用）</h5><p>gc线程如果已经扫描完成A对象（黑色），用户线程在这期间又将A对象持有了一个应该被回收的B对象引用（白色）。此时需要记录A对象，将其从黑变为灰，在gc线程扫描完成后再扫描一次A对象</p><h5 id="2-原始快照"><a href="#2-原始快照" class="headerlink" title="2.原始快照"></a>2.原始快照</h5><p>记录删除了白色对象引用的灰色对象，gc线程第一次扫描结束后在扫描这个灰色对象</p><h2 id="5-GCRoots对象"><a href="#5-GCRoots对象" class="headerlink" title="5 GCRoots对象"></a>5 GCRoots对象</h2><ul><li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li><li>本地方法栈(Native 方法)中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>所有被同步锁持有的对象</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java源码篇-锁</title>
      <link href="/2020/04/18/java-yuan-ma-pian-suo/"/>
      <url>/2020/04/18/java-yuan-ma-pian-suo/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="1-ReentrantLock"><a href="#1-ReentrantLock" class="headerlink" title="1 ReentrantLock"></a>1 ReentrantLock</h2><p>​基于AQS实现的一种可重入互斥锁，所以只允许一个线程获取到锁。获取到锁时state设为1，当获取到锁的线程尝试重入时，便会增加state，同理需要将state减到0才会释放锁</p><h3 id="1-1-非公平锁（NonfairSync）"><a href="#1-1-非公平锁（NonfairSync）" class="headerlink" title="1.1 非公平锁（NonfairSync）"></a>1.1 非公平锁（NonfairSync）</h3><h4 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h4><blockquote><ol><li>java.util.concurrent.locks.ReentrantLock.Sync#nonfairTryAcquire：利用CAS尝试设置state，能设置成功，代表获取到锁，成功返回。设置失败，代表已经被其他线程获取了锁，返回失败</li><li>返回失败后将当前线程构造为Node节点，设置到同步队列的链表中进入到<strong>java.util.concurrent.locks.AbstractQueuedSynchronizer#acquireQueued</strong>方法：死循环获取当前Node的前一个节点（<strong>同步队列的首节点是成功获取到锁的节点</strong>），如果前驱结点为首节点，当前Node才有资格获取锁。如果还是获取不到，就调用<strong>java.util.concurrent.locks.LockSupport#park</strong>(java.lang.Object)方法阻塞当前线程，等待其他线程唤醒再去竞争锁</li></ol></blockquote><h4 id="unlock"><a href="#unlock" class="headerlink" title="unlock"></a><strong>unlock</strong></h4><blockquote><ol><li>java.util.concurrent.locks.ReentrantLock.Sync#tryRelease：复原state（将其归0），exclusiveOwnerThread设为null</li><li>java.util.concurrent.locks.AbstractQueuedSynchronizer#release：在tryRelease成功后，使用<strong>java.util.concurrent.locks.LockSupport#unpark</strong>方法唤醒同步队列首节点的下一个节点里的线程，让他再去尝试获取锁</li></ol></blockquote><h3 id="1-2-公平锁（FairSync）"><a href="#1-2-公平锁（FairSync）" class="headerlink" title="1.2 公平锁（FairSync）"></a>1.2 公平锁（FairSync）</h3><h4 id="lock-1"><a href="#lock-1" class="headerlink" title="lock"></a><strong>lock</strong></h4><blockquote><p>​和非公平锁很像，不同的部分就在覆盖了<strong>java.util.concurrent.locks.AbstractQueuedSynchronizer#tryAcquire</strong>这个方法和非公平锁略有不同。在新的线程获取锁失败，并将自己构造为Node节点并放入同步队列链表后，还会通过调用<strong>java.util.concurrent.locks.AbstractQueuedSynchronizer#hasQueuedPredecessors</strong>方法</p></blockquote><h4 id="unlock：和非公平锁一样"><a href="#unlock：和非公平锁一样" class="headerlink" title="unlock：和非公平锁一样"></a><strong>unlock</strong>：和非公平锁一样</h4><h4 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// ReentrantLock的公平锁第一次尝试获取锁</span><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> Thread current <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">hasQueuedPredecessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token comment" spellcheck="true">// 测试当前线程是否是等待最久的线程</span>                <span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> acquires<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">==</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> nextc <span class="token operator">=</span> c <span class="token operator">+</span> acquires<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nextc <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Maximum lock count exceeded"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">setState</span><span class="token punctuation">(</span>nextc<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">/**  * 查询是否有线程等待获取的时间长于当前线程 * 判断是否存在队列中第二个Node(因为首节点是个空节点)，且第二个节点中的线程是否是当前线程 * 也就是说：判断同步队列中当前节点是否有前驱结点 * true:代表当前线程不是等待最久的线程或压根就没有等待的线程 * false:在代表当前线程已经是等待最久的线程（毕竟队列越前面，则代表进去的越久）&lt;p/> * 只有公平锁才需要用到这个方法，来判断当前线程是否等待时间最长 */</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">hasQueuedPredecessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node t <span class="token operator">=</span> tail<span class="token punctuation">;</span>     Node h <span class="token operator">=</span> head<span class="token punctuation">;</span>    Node s<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 用 h != t 来做判断是因为调用这个方法的线程此时还没有进入等待队列</span>    <span class="token comment" spellcheck="true">// 如果 h != t，则代表队列中有线程在等待获取锁</span>    <span class="token keyword">return</span> h <span class="token operator">!=</span> t <span class="token operator">&amp;&amp;</span>        <span class="token punctuation">(</span><span class="token punctuation">(</span>s <span class="token operator">=</span> h<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">||</span> s<span class="token punctuation">.</span>thread <span class="token operator">!=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-3-总结"><a href="#1-3-总结" class="headerlink" title="1.3 总结"></a>1.3 总结</h3><h4 id="1-3-1-为什么叫公平锁和非公平锁"><a href="#1-3-1-为什么叫公平锁和非公平锁" class="headerlink" title="1.3.1 为什么叫公平锁和非公平锁"></a>1.3.1 为什么叫公平锁和非公平锁</h4><p>​根据上面的分析，<strong>公平锁在获取锁是总是会先判断当前线程是否是等待最久的线程</strong>。<strong>所以，就算是同步队列存在大量Node，且有线程第一次在获取锁，那么，下一次获取到锁的线程也一定是同步队列的首节点的下一个节点，即必须排队。（首节点就是当前获取到锁的节点，只有获取成功了，同步才会更新首节点）</strong></p><p>​<strong>非公平锁中：对于已经进入同步队列的线程来说，也只能首节点的下一个节点里的线程能尝试获取锁。但对于还未构造成Node加入到同步队列的线程来说，这个线程和首节点的下一个节点里的线程能竞争获取锁</strong>，所以非公平。<strong>但对于已经进入同步队列的线程来说，前驱结点是一定比后面的节点先获取到锁的</strong></p><h4 id="1-3-2-各自优势"><a href="#1-3-2-各自优势" class="headerlink" title="1.3.2 各自优势"></a>1.3.2 各自优势</h4><ul><li>公平锁：防止线程饥饿，分散性很好，适合线程等待时间敏感的场景</li><li>非公平锁：更快。一是<strong>获取锁是不用判断当前线程是否是等待最久的线程</strong>。二是<strong>上下文交换没有公平锁频繁</strong>。在存在大量锁竞争的前提下，可以肯定，公平锁上下文切换很频繁，获取锁后的线程再次获取锁时是一定会阻塞的。而非公平锁则不一样，下一次获取到锁的线程仍可能是上一次获取到锁的线程，没有上下文切换</li></ul><h2 id="2-Condition"><a href="#2-Condition" class="headerlink" title="2 Condition"></a>2 Condition</h2><p>等待通知接口，代替Object原生的wait和notify，其具体实现为AQS里的ConditionObject（定义在AQS里的非静态内部类，所以使用了AQS部分方法来实现其功能）。<strong>只有获取到锁的线程才能调用Condition的阻塞和唤醒方法</strong>。三个核心组件如下</p><ul><li>等待队列：使用 Node 节点串联，与 AQS 同步队列共用 Node 结构 </li><li>状态转换：Node 在等待队列和同步队列之间的转换 </li><li>线程控制：包括阻塞、唤醒、中断处理等机制</li></ul><p>主要字段</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 等待队列中的首节点</span><span class="token keyword">private</span> <span class="token keyword">transient</span> Node firstWaiter<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 等待队列中的尾节点</span><span class="token keyword">private</span> <span class="token keyword">transient</span> Node lastWaiter<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-1-Condition-await"><a href="#2-1-Condition-await" class="headerlink" title="2.1 Condition#await"></a>2.1 Condition#await</h3><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><blockquote><ul><li>首先将当前线程构造为等待节点，并加入到等待队列的末尾</li><li>其次释放锁资源（能够await的线程一定是获取到锁的），同时唤醒同步队列的第二个节点，让其尝试获取锁</li><li>死循环判断当前节点是否为同步节点（等待节点在等待队列里，是一定要阻塞的。同步节点在同步队列里，是可以并被唤醒并尝试获取锁的），await到这里线程就阻塞了</li><li>当被唤醒后，当前节点一定被加入了同步队列，再尝试获取锁，如果能获取到，代表就可以返回了。如果获取不到，就表示当前同步块被其他线程暂用了，也还是阻塞。不过下一次被唤醒后就会通过同步队列的唤醒方式来尝试获取锁</li></ul></blockquote><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 响应中断</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 构建等待节点并加入等待队列</span>    Node node <span class="token operator">=</span> <span class="token function">addConditionWaiter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 先检查当前线程是否已获取到锁，否则抛异常。然后完全释放锁并且唤醒同步队列中的第二个节点</span>    <span class="token keyword">int</span> savedState <span class="token operator">=</span> <span class="token function">fullyRelease</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> interruptMode <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 死循环判断当前节点是否在等待队列中</span>    <span class="token comment" spellcheck="true">// 等待队列中的节点一定要阻塞，而同步队列中的节点是可以被唤醒的</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isOnSyncQueue</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        LockSupport<span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>interruptMode <span class="token operator">=</span> <span class="token function">checkInterruptWhileWaiting</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 当signal后，需要重新获取锁，要复原现场，需要重新持有上一次所持有的所有的state值</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">acquireQueued</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> savedState<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> interruptMode <span class="token operator">!=</span> THROW_IE<span class="token punctuation">)</span>        interruptMode <span class="token operator">=</span> REINTERRUPT<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>nextWaiter <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// clean up if cancelled</span>        <span class="token function">unlinkCancelledWaiters</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>interruptMode <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 当前节点有中断</span>        <span class="token function">reportInterruptAfterWait</span><span class="token punctuation">(</span>interruptMode<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** *   将当前线程构造为一个等待节点，并加入到等待队列的尾部，并通过nextWaiter字段建立联系 &lt;br/> *  注意：等待队列建立关联用的是nextWaiter字段，不是prev和next字段 */</span><span class="token keyword">private</span> Node <span class="token function">addConditionWaiter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node lastW <span class="token operator">=</span> lastWaiter<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 尾节点</span>    <span class="token comment" spellcheck="true">// If lastWaiter is cancelled, clean out.</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>lastW <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> lastW<span class="token punctuation">.</span>waitStatus <span class="token operator">!=</span> Node<span class="token punctuation">.</span>CONDITION<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">unlinkCancelledWaiters</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        lastW <span class="token operator">=</span> lastWaiter<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    Node node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Node<span class="token punctuation">.</span>CONDITION<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>lastW <span class="token operator">==</span> null<span class="token punctuation">)</span>        firstWaiter <span class="token operator">=</span> node<span class="token punctuation">;</span>    <span class="token keyword">else</span>        lastW<span class="token punctuation">.</span>nextWaiter <span class="token operator">=</span> node<span class="token punctuation">;</span>    lastWaiter <span class="token operator">=</span> node<span class="token punctuation">;</span>    <span class="token keyword">return</span> node<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// ====================以下为AQS中的方法===================</span><span class="token comment" spellcheck="true">// 判断这个节点是否在同步队列上</span><span class="token comment" spellcheck="true">// false -> 这个节点在等待队列上</span><span class="token comment" spellcheck="true">// true -> 这个节点在同步队列上</span><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">isOnSyncQueue</span><span class="token punctuation">(</span>Node node<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>waitStatus <span class="token operator">==</span> Node<span class="token punctuation">.</span>CONDITION <span class="token operator">||</span> node<span class="token punctuation">.</span>prev <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// If has successor, it must be on queue</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">findNodeFromTail</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*** 当前节点尝试获取锁* 返回true -> 获取锁的过程有中断*/</span><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token keyword">final</span> Node node<span class="token punctuation">,</span> <span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">boolean</span> failed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">boolean</span> interrupted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">final</span> Node prevNode <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">predecessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 只有当前节点的前驱结点为首节点，当前节点里的线程才有资格获取锁</span>            <span class="token comment" spellcheck="true">// 只可能有一个线程获取成功（即获取锁），所以设置首节点不需要同步了</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>prevNode <span class="token operator">==</span> head <span class="token operator">&amp;&amp;</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">setHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>                prevNode<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// help GC</span>                failed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> interrupted<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>prevNode<span class="token punctuation">,</span> node<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                interrupted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>failed<span class="token punctuation">)</span>            <span class="token function">cancelAcquire</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-Condition-signal和signalAll"><a href="#2-2-Condition-signal和signalAll" class="headerlink" title="2.2 Condition#signal和signalAll"></a>2.2 Condition#signal和signalAll</h3><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>singal的目的很简单，就是将等待队列的首节点转移到同步队列的尾节点，signalAll则是将等待队列中的所有节点都转移到同步节点。<strong>signal方法本身不能唤醒线程，只是让这些节点里的线程有资格被唤醒</strong>，可以将signal和排队买票做类比</p><ul><li>等待队列相当于候补区</li><li>signal 相当于叫号，让候补区的人去正式排队区（同步队列）</li><li>但叫号本身并不会直接让人拿到票，还需要排队区的人按顺序获取票（锁）</li></ul><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">doSignal</span><span class="token punctuation">(</span>Node first<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">do</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 将首节点的nextWaiter转移到首节点，如果nextWaiter为空，则表示队列中只有一个节点，且首尾相同</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>firstWaiter <span class="token operator">=</span> first<span class="token punctuation">.</span>nextWaiter<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>            lastWaiter <span class="token operator">=</span> null<span class="token punctuation">;</span>        first<span class="token punctuation">.</span>nextWaiter <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// gc处理</span>    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">transferForSignal</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>             <span class="token punctuation">(</span>first <span class="token operator">=</span> firstWaiter<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 将当前的等待节点转换为同步节点，并加入到同步队列的末尾</span><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">transferForSignal</span><span class="token punctuation">(</span>Node node<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> Node<span class="token punctuation">.</span>CONDITION<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    Node p <span class="token operator">=</span> <span class="token function">enq</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> ws <span class="token operator">=</span> p<span class="token punctuation">.</span>waitStatus<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> ws<span class="token punctuation">,</span> Node<span class="token punctuation">.</span>SIGNAL<span class="token punctuation">)</span><span class="token punctuation">)</span>        LockSupport<span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 前驱节点被取消了，或者设置为SIGNAL失败</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3-总结"><a href="#2-3-总结" class="headerlink" title="2.3 总结"></a>2.3 总结</h3><p>​Condition实现了等待通知，当一个线程进入同步块后，就可以调用await，释放自己获取的锁资源，将自己阻塞。内部实现是<strong>首先将当前线程构造成一个等待节点，加入ConditionObject的等待队列的末尾，再释放锁资源，之后唤醒同步队列的第二个节点让其尝试获取锁</strong>。而当其他进入同步块的线程调用signal后，会将等待队列的首节点转移到同步队列，并将其变成同步节点，最后再使用同步队列的唤醒机制等待被唤醒。</p><p>​所以signal并不能直接唤醒一个await的线程，最佳使用案例就是消费者发送者机制，比如阻塞队列。</p><h2 id="3-CountDownLatch"><a href="#3-CountDownLatch" class="headerlink" title="3 CountDownLatch"></a>3 CountDownLatch</h2><p>CountDownLatch为共享锁实现，只能使用一次。用来“卡点”，阻塞的线程需要等待其他线程准备好了后（countDown直到AQS里的state为0），才继续被唤醒执行后面的代码。</p><p>在CountDownLatch中，AQS里的state值并不表示可获取到锁的次数，而是<strong>java.util.concurrent.CountDownLatch#countDown</strong> state值的次数后会释放所有调用了**java.util.concurrent.CountDownLatch#await()**的线程</p><p>内部的同步器Sync主要方法</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**    获取共享锁，只有AQS的state为0才能获取到    通过这个接口就可以猜到，当state为0时（拉下了所有门闩），总会返回1，代表获取锁成功。    并依次传播下去递归调用这个方法，直到同步队列的所有Node里的线程全部唤醒，这就是CountDownLatch的原理*/</span><span class="token keyword">protected</span> <span class="token keyword">int</span> <span class="token function">tryAcquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 释放共享锁，state第一次被减为0才释放成功，也就表示了CountDownLatch只能用一次</span><span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryReleaseShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> releases<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Decrement count; signal when transition to zero</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> nextc <span class="token operator">=</span> c<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> nextc<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> nextc <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>await方法会阻塞当前线程，直到其他线程“拉下所有门闩”。阻塞的线程会构造为共享节点加入同步队列，只有队首节点的下一个节点才有资格尝试获取锁，获取不到就LockSupport#park</p><p>countDown会将state值减小1，当state将为0时，释放同步队列里的第二个共享节点里的线程。当这个线程释放后，就能成功获取到锁了，将这个事件传播下去，一次唤醒同步队列里的所有共享节点。至此，所有被阻塞的线程都被唤醒且会成功获取到锁，最终从await方法里返回</p><h2 id="4-Semaphore"><a href="#4-Semaphore" class="headerlink" title="4 Semaphore"></a>4 Semaphore</h2><p><strong>信号量，共享锁实现。可以利用构造器指定令牌（permits）的数量。当线程到达时，获取（acquire）指定数量的令牌，当没有可用令牌（premits为0）时，阻塞线程，等待令牌的释放（release）再被唤醒后继续执行。基于此，即可实现共享锁（permits大于1），也可实现不可重入的互斥锁（permits为1）</strong></p><p>也分为公平锁和分公平锁，其判断方式完全和ReentrantLock一致。</p><p>​<strong>非公平锁允许准备进入同步块的线程（还未加入同步队列）和同步队列中的第二个节点竞争获取锁。而公平锁则只允许同步队列中第二个节点里的线程能尝试获取锁。</strong></p><p>​<strong>其实现方式就是将state设为我们允许并发运行的线程数量，每当一个线程获取到锁后，将state - 1，如果state为0则阻塞所有准备进入同步块的线程，并将其构造为共享节点加入同步队列。每当有线程从同步块退出时，将state + 1，并根据是否非公平来唤醒同步队列的第二个节点来尝试获取锁</strong></p>]]></content>
      
      
      <categories>
          
          <category> jdk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AQS实现类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java源码篇-AQS</title>
      <link href="/2020/04/17/java-yuan-ma-pian-aqs/"/>
      <url>/2020/04/17/java-yuan-ma-pian-aqs/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="Java源码篇-AQS"><a href="#Java源码篇-AQS" class="headerlink" title="Java源码篇-AQS"></a>Java源码篇-AQS</h1><h2 id="1-LockSupport"><a href="#1-LockSupport" class="headerlink" title="1 LockSupport"></a>1 LockSupport</h2><h3 id="1-1-总结"><a href="#1-1-总结" class="headerlink" title="1.1 总结"></a>1.1 总结</h3><p>Java中实现<strong>当前线程的阻塞和定时阻塞</strong>，并提供<strong>唤醒指定线程</strong>的工具，在内部使用sun.misc.Unsafe来实现这一系列的操作。在AQS中普遍被使用</p><ul><li><strong>阻塞当前线程</strong>：通过 <code>park()</code> 方法使当前线程进入等待状态。</li><li><strong>定时阻塞</strong>：通过 <code>parkNanos(long nanos)</code> 或 <code>parkUntil(long deadline)</code> 方法使当前线程在指定时间内等待。</li><li><strong>唤醒指定线程</strong>：通过 <code>unpark(Thread thread)</code> 方法唤醒指定的处于等待状态的线程。</li></ul><h3 id="1-2-核心代码"><a href="#1-2-核心代码" class="headerlink" title="1.2 核心代码"></a>1.2 核心代码</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 唤醒指定的线程（如果该线程被park了） * 如果线程先被unpark（解除等待）了，那么该线程下一次调用park(进入等待)则不起作用，也就不会被阻塞 */</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">unpark</span><span class="token punctuation">(</span>Thread thread<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>thread <span class="token operator">!=</span> null<span class="token punctuation">)</span>        UNSAFE<span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 阻塞当前线程，并设置一个blocker（俗称阻塞器，这个只是用来jstack查看，并不能通过notifyAll来唤醒阻塞的线程） * blocker只能用来调试和诊断，并不影响线程的阻塞和唤醒 */</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">park</span><span class="token punctuation">(</span>Object blocker<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Thread t <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">setBlocker</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> blocker<span class="token punctuation">)</span><span class="token punctuation">;</span>    UNSAFE<span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> 0L<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">setBlocker</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 定时等待，阻塞当前线程指定的纳秒数，当时间到达时就自动唤醒（定时任务会调用） */</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">parkNanos</span><span class="token punctuation">(</span><span class="token keyword">long</span> nanos<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nanos <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>        UNSAFE<span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> nanos<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 定时等待，阻塞当前线程直到指定的时间戳（deadline）到来就自动唤醒（定时任务会调用） */</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">parkUntil</span><span class="token punctuation">(</span><span class="token keyword">long</span> deadline<span class="token punctuation">)</span> <span class="token punctuation">{</span>    UNSAFE<span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> deadline<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-AbstractQueuedSynchronizer"><a href="#2-AbstractQueuedSynchronizer" class="headerlink" title="2 AbstractQueuedSynchronizer"></a>2 AbstractQueuedSynchronizer</h2><blockquote><p>​Node是AQS的核心内部类，它是构建同步器的基础数据结构，通过不同的配置可以实现同步队列，也可实现等待队列</p></blockquote><h3 id="2-1-同步队列"><a href="#2-1-同步队列" class="headerlink" title="2.1 同步队列"></a>2.1 同步队列</h3><p>​<strong>当线程尝试获取锁时，未获取到锁的线程会被构造成一个Node，利用CAS放入同步尾部作为尾节点，等待被唤醒。同步队列关联的是整个锁，一对一的关系。而同步队列中的Node又根据nextWaiter字段判断当前Node是共享节点还是独占节点</strong></p><ul><li><p>Node之间通过<strong>prev和next指针构成双向链表</strong></p></li><li><p><strong>头节点(head)代表当前持有锁的线程</strong></p></li><li><p>包含waitStatus字段标记节点状态</p><ul><li><strong>CANCELLED(1): 线程已取消</strong></li><li><strong>SIGNAL(-1): 后继节点需要唤醒</strong></li><li><strong>CONDITION(-2): 节点在等待队列中</strong></li><li>PROPAGATE(-3): 共享锁需要向后传播</li><li>0: 初始状态</li></ul></li><li><p>使用nextWaiter区分共享&#x2F;互斥模式</p><ul><li><p><strong>共享节点：共享锁的实现（Semaphore、CountDownLatch等）。nextWaiter字段为固定的Node#SHARED。释放当前节点的线程后，还具有向后传播的能力（根据state的值判断是否需要释放后继共享节点里的线程）</strong></p></li><li><p><strong>互斥节点：互斥锁的实现（ReentrantLock等），nextWaiter字段为Node#EXCLUSIVE（即null），只会释放当前节点里的线程</strong></p></li></ul></li></ul><h3 id="2-2-等待队列"><a href="#2-2-等待队列" class="headerlink" title="2.2 等待队列"></a>2.2 等待队列</h3><p>​当已经获取到锁的线程触发<strong>java.util.concurrent.locks.Condition#await()<strong>方法阻塞自己，让出锁时。</strong>会将当前线程构造成一个Node（等待节点，状态为CONDITION），利用CAS放入等待队列尾部。等待队列关联的是Condition。所以，当ReentrantLock构造多个Condition时，就有多个等待队列，ReentrantLock和等待队列可以为一对多，而Condition和等待队列时一对一</strong>。而<strong>当其他线程获取当前锁（ReentrantLock）的线程调用java.util.concurrent.locks.Condition#signal等方法时，便会将等待队列的首节点转入到同步队列的尾节点，并重新设置Node的状态</strong></p><ul><li><p>单向链表结构，只使用nextWaiter指针</p></li><li><p><strong>nextWaiter字段为等待队列中下一个等待节点的指针</strong></p></li><li><p>当调用signal()时，节点从等待队列转移到同步队列过程中的状态变化如下</p><ol><li>CONDITION -&gt; 0</li><li>入队同步队列</li><li>等待获取锁</li></ol></li></ul><h3 id="2-3-核心代码"><a href="#2-3-核心代码" class="headerlink" title="2.3 核心代码"></a>2.3 核心代码</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 同步队列专属的头尾节点。</span><span class="token comment" spellcheck="true">// 因为只有在同步队列里的线程才需要被唤醒。等待队列里的线程如果要被唤醒，需要先加入到同步队列</span><span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> Node head<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> Node tail<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 核心，可获取到锁的次数</span><span class="token comment" spellcheck="true">// - ReentrantLock: 表示重入次数</span><span class="token comment" spellcheck="true">// - Semaphore: 表示剩余许可数</span><span class="token comment" spellcheck="true">// - CountDownLatch: 表示剩余计数</span><span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> state<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 自旋的阈值（纳秒）。当超时等待时间小于这个值时，就不会再暂停线程，而是自旋。因为这个时间已经很少了，考虑到阻塞线程后上线文切换会消耗时间，就没必要再阻塞了</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> spinForTimeoutThreshold <span class="token operator">=</span> 1000L<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 获取到独占锁的线程</span><span class="token keyword">private</span> <span class="token keyword">transient</span> Thread exclusiveOwnerThread<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**    留给子类实现的尝试获取共享锁的方法，共享锁获取，返回AQS里state的剩余值     1：返回值 > 0，代表当前线程获取成功，且state还有剩余值，表示可以继续传播给下一个共享节点线程，让其尝试获取锁     2：返回值 = 0，代表当前线程获取成功，但state值刚好被用完，那么下一个共享节点线程就不应该被唤醒了（因为这时已经获取不到state的剩余值了）    3：返回值 &lt; 0，代表当前线程都没获取成功，直接获取失败，阻塞等待被其他线程唤醒后在尝试获取*/</span><span class="token keyword">protected</span> <span class="token keyword">int</span> <span class="token function">tryAcquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UnsupportedOperationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 获取共享锁</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">doAcquireSharedInterruptibly</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span>    <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    <span class="token keyword">final</span> Node node <span class="token operator">=</span> <span class="token function">addWaiter</span><span class="token punctuation">(</span>Node<span class="token punctuation">.</span>SHARED<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> failed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">final</span> Node p <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">predecessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> head<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 首节点的下个节点才有资格获取锁（首节点就是获取到锁的节点）</span>                <span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token function">tryAcquireShared</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 至少当前线程获取成功了，但可能state值已经被用完了</span>                    <span class="token comment" spellcheck="true">// 获取成功，传播给下一个共享Node，根据state的剩余值来判断是否需要唤醒下一个共享Node里的线程</span>                    <span class="token function">setHeadAndPropagate</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>                    p<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// help GC</span>                    failed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> node<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 不能获取到锁线程就park</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>failed<span class="token punctuation">)</span>            <span class="token function">cancelAcquire</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 释放共享锁（Semaphore会使用）</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">doReleaseShared</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 必要的循环</span>      <span class="token comment" spellcheck="true">// 1. CAS操作可能失败需要重试</span>    <span class="token comment" spellcheck="true">// 2. 在设置head的过程中可能有新的节点入队</span>    <span class="token comment" spellcheck="true">// 3. 传播机制要求必须确保传播状态正确设置</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Node h <span class="token operator">=</span> head<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// h != tail 检查确保队列中还有后继节点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> h <span class="token operator">!=</span> tail<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> ws <span class="token operator">=</span> h<span class="token punctuation">.</span>waitStatus<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">==</span> Node<span class="token punctuation">.</span>SIGNAL<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> Node<span class="token punctuation">.</span>SIGNAL<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// loop to recheck cases</span>                <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>                     <span class="token operator">!</span><span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> Node<span class="token punctuation">.</span>PROPAGATE<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// loop on failed CAS</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">==</span> head<span class="token punctuation">)</span>                   <span class="token comment" spellcheck="true">// loop if head changed</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*    将目标节点（参数node）设为同步队列的尾部（使用CAS来解决并发问题）。    所以，在这整个过程中，链表中除首节点外其余节点的prev在任何时刻都不会为空；        但除尾节点外其余节点的next字段有可能为空 （刚好走完第②步，还没走到第③步）*/</span><span class="token keyword">private</span> Node <span class="token function">enq</span><span class="token punctuation">(</span><span class="token keyword">final</span> Node node<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Node t <span class="token operator">=</span> tail<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 初始化同步队列，设置一个空Node为首尾节点</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetHead</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                tail <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            node<span class="token punctuation">.</span>prev <span class="token operator">=</span> t<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 先将目标节点的prev设置程原尾节点 ①</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetTail</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// CAS设置尾节点 ②</span>                t<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 设置成功了，才把原尾节点的next设为目标节点（现尾节点）③</span>                <span class="token keyword">return</span> t<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 唤醒目标节点（参数node）的最近下一个可唤醒节点中的线程</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span>Node node<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> ws <span class="token operator">=</span> node<span class="token punctuation">.</span>waitStatus<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> ws<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 首节点的下个节点唤醒失败时，就从尾节点向前遍历，直到找到距首节点最近的可唤醒的节点</span>    <span class="token comment" spellcheck="true">// 目的是避免并发时（节点入队列和唤醒），倒数第二个节点（甚至不止）的next字段为空，导致拿不到其实已经入队列里的后续节点</span>    Node s <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> null <span class="token operator">||</span> s<span class="token punctuation">.</span>waitStatus <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        s <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Node t <span class="token operator">=</span> tail<span class="token punctuation">;</span> t <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> t <span class="token operator">!=</span> node<span class="token punctuation">;</span> t <span class="token operator">=</span> t<span class="token punctuation">.</span>prev<span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span>waitStatus <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>                s <span class="token operator">=</span> t<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">!=</span> null<span class="token punctuation">)</span>        LockSupport<span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// ============内部的Node数据结构=================</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 共享锁</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> Node SHARED <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 互斥锁</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> Node EXCLUSIVE <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//  取消获取锁</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> CANCELLED <span class="token operator">=</span>  <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> SIGNAL    <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 等待condition唤醒（等待队列才会用到这个状态）</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> CONDITION <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> PROPAGATE <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 当前节点的状态</span>    <span class="token keyword">volatile</span> <span class="token keyword">int</span> waitStatus<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 同步队列专用</span>    <span class="token keyword">volatile</span> Node prev<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 同步队列专用</span>    <span class="token keyword">volatile</span> Node next<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 等待线程</span>    <span class="token keyword">volatile</span> Thread thread<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 1. 当前Node为同步队列中的共享节点时：SHARED</span>    <span class="token comment" spellcheck="true">// 2. 当前Node为同步队列中的独占节点时：null</span>    <span class="token comment" spellcheck="true">// 3. 当前Node为等待队列中的节点时：下一个等待节点的指针</span>    Node nextWaiter<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 判断当前节点是互斥锁，还是共享锁</span>    <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">isShared</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> nextWaiter <span class="token operator">==</span> SHARED<span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 当前节点的前驱结点</span>    <span class="token keyword">final</span> Node <span class="token function">predecessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> NullPointerException <span class="token punctuation">{</span>        Node p <span class="token operator">=</span> prev<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> null<span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token keyword">return</span> p<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> jdk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LockSupport </tag>
            
            <tag> AQS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java源码篇-Map</title>
      <link href="/2020/04/09/java-yuan-ma-pian-map/"/>
      <url>/2020/04/09/java-yuan-ma-pian-map/</url>
      
        <content type="html"><![CDATA[<h1 id="Java源码篇-Map"><a href="#Java源码篇-Map" class="headerlink" title="Java源码篇-Map"></a>Java源码篇-Map</h1><h2 id="1-HashMap"><a href="#1-HashMap" class="headerlink" title="1 HashMap"></a>1 HashMap</h2><h3 id="1-1-重点字段"><a href="#1-1-重点字段" class="headerlink" title="1.1 重点字段"></a>1.1 重点字段</h3><pre class="line-numbers language-java"><code class="language-java"> <span class="token comment" spellcheck="true">/** * 数组默认长度 */</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_INITIAL_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// aka 16</span><span class="token comment" spellcheck="true">/** * 最大容量（即数组最大长度） */</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAXIMUM_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">30</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 默认加载因子 * 加载因子（loadFactor）是哈希表中用于控制数组存放数据疏密程度的参数。 * 当loadFactor越趋近于1时，数组中存放的数据（entry）越多，哈希冲突的概率增加， * 导致单个桶中的链表长度可能增加，进而影响查找元素的效率。反之，当loadFactor越小， * 数组中存放的数据越少，数据分布越稀疏，数组的利用率降低。 * * 默认的loadFactor值为0.75f，是官方经过权衡后给出的一个较为理想的平衡点， * 旨在兼顾查找效率和空间利用率。 */</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">float</span> DEFAULT_LOAD_FACTOR <span class="token operator">=</span> <span class="token number">0.75f</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 树化阈值。当桶(bucket)上的结点数大于这个值时会转成红黑树 */</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TREEIFY_THRESHOLD <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 链表化阈值（当桶(bucket)上的结点数小于这个值时树转链表） */</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> UNTREEIFY_THRESHOLD <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 桶中结构树化对应的table的最小长度 */</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MIN_TREEIFY_CAPACITY <span class="token operator">=</span> <span class="token number">64</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 扩容阈值（threshold） * threshold = loadFactor * 数组长度 * 当HashMap中元素的数量超过threshold时，会触发数组的扩容操作。 * 扩容是为了减少哈希冲突，保持查找效率。 */</span><span class="token keyword">int</span> threshold<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2-核心方法"><a href="#1-2-核心方法" class="headerlink" title="1.2 核心方法"></a>1.2 核心方法</h3><h4 id="1-2-1-put"><a href="#1-2-1-put" class="headerlink" title="1.2.1 put"></a>1.2.1 put</h4><h5 id="1-初始化数组"><a href="#1-初始化数组" class="headerlink" title="1 初始化数组"></a>1 <strong>初始化数组</strong></h5><ul><li>如果是第一次添加元素，先初始化数组（即分配内存空间）。</li><li>计算键的哈希值并确定索引位置，然后将键值对放入对应的桶（bucket）中。</li></ul><h5 id="2-目标桶为空"><a href="#2-目标桶为空" class="headerlink" title="2 目标桶为空"></a>2 <strong>目标桶为空</strong></h5><ul><li>如果计算索引后，数组中对应的桶为空，则直接将键值对放入该桶中。</li></ul><h5 id="3-目标桶不为空"><a href="#3-目标桶不为空" class="headerlink" title="3 目标桶不为空"></a>3 <strong>目标桶不为空</strong></h5><ul><li><strong>根节点匹配</strong>：<ul><li>如果桶中的根节点（第一个节点）与待插入节点的键 <code>equals</code>，则直接替换根节点的值。</li></ul></li><li><strong>树化节点</strong>：<ul><li>如果根节点是树形节点（即红黑树节点），则调用红黑树的插入方法将节点放入树中。</li></ul></li><li><strong>链表遍历</strong>：<ul><li>如果根节点是链表节点，则遍历链表：<ul><li>如果找到与待插入节点键 <code>equals</code> 的节点，则替换其值。</li><li>如果遍历到链表末尾仍未找到匹配的节点，则将新节点插入链表末尾。</li><li><strong>树化条件</strong>：<ul><li>如果链表长度（包括待插入节点）达到 8 且数组长度大于等于 64，则将链表转换为红黑树。</li><li>如果链表长度达到 8 但数组长度小于 64，则仅进行数组扩容，不进行树化。</li></ul></li></ul></li></ul></li></ul><h4 id="1-2-2-resize"><a href="#1-2-2-resize" class="headerlink" title="1.2.2 resize"></a>1.2.2 resize</h4><p><strong>HashMap 数组的长度始终为 2 的次幂，且扩容时长度加倍。这样设计的主要目的是为了方便扩容时的索引计算。</strong>以下为具体的扩容过程</p><h5 id="1-创建新数组"><a href="#1-创建新数组" class="headerlink" title="1 创建新数组"></a>1 <strong>创建新数组</strong></h5><ul><li>先创建一个长度为原数组 2 倍的新数组。</li></ul><h5 id="2-迁移数据"><a href="#2-迁移数据" class="headerlink" title="2 迁移数据"></a>2 <strong>迁移数据</strong></h5><ul><li><p>遍历原数组中的每个桶（bucket）：</p><ul><li><p><strong>如果桶为空或只有一个元素</strong>：</p><ul><li>直接计算该元素在新数组中的索引，并将其放入新数组。</li></ul></li><li><p><strong>如果桶中有链表结构</strong>：</p><ul><li><p>遍历链表中的每个节点（Node），计算其在新数组中的索引。</p></li><li><p>由于新数组长度是原数组的 2 倍，且长度始终为 2 的次幂，因此新索引的计算方法为：</p><pre class="line-numbers language-java"><code class="language-java">newIndex <span class="token operator">=</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>新索引的结果只有两种可能：</p><ul><li><strong>与原索引相同</strong>：如果 key 的哈希值在高一位为 0。</li><li><strong>等于原索引加上原数组长度</strong>：如果 key 的哈希值在高一位为 1。</li></ul></li><li><p>根据计算结果，将节点放入新数组的对应位置。</p></li></ul></li></ul></li></ul><h5 id="3-链表拆分"><a href="#3-链表拆分" class="headerlink" title="3 链表拆分"></a>3 <strong>链表拆分</strong></h5><ul><li>如果原桶中的链表被拆分为两个链表（一个保持原索引，另一个为原索引加上原数组长度），则分别将它们放入新数组的对应位置。</li></ul><h4 id="1-2-3-部分核心代码"><a href="#1-2-3-部分核心代码" class="headerlink" title="1.2.3 部分核心代码"></a>1.2.3 部分核心代码</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">final</span> V <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">,</span>             <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span>  Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> rootNode<span class="token punctuation">;</span> <span class="token keyword">int</span> tableLength<span class="token punctuation">,</span> index<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>tableLength <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 添加第一个元素</span>      tableLength <span class="token operator">=</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>rootNode <span class="token operator">=</span> tab<span class="token punctuation">[</span>index <span class="token operator">=</span> <span class="token punctuation">(</span>tableLength <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 数组上对于的索引为空，代表这个kv可以直接放到这</span>      tab<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">else</span> <span class="token punctuation">{</span>      Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span> K k<span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>rootNode<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>          <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> rootNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// bucket上的元素equals要放进来的kv，直接覆盖</span>          e <span class="token operator">=</span> rootNode<span class="token punctuation">;</span>      <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>rootNode <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// bucket上已经是红黑树结构了，直接存放为红黑树结构</span>          e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>rootNode<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 向链表的末尾添加</span>          <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> rootNode<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 到链表末尾了</span>                  rootNode<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">>=</span> TREEIFY_THRESHOLD <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// -1 for 1st</span>                  <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 链表的长度（算上bucket）已经大于等于了8，转换为红黑树</span>                      <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token punctuation">}</span>                  <span class="token keyword">break</span><span class="token punctuation">;</span>              <span class="token punctuation">}</span>              <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                  <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 遍历链表时有equals，直接替换</span>                  <span class="token keyword">break</span><span class="token punctuation">;</span>              <span class="token punctuation">}</span>              rootNode <span class="token operator">=</span> e<span class="token punctuation">;</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// existing mapping for key</span>          <span class="token comment" spellcheck="true">// e不为空，代表是覆盖的情况，不是新增</span>          V oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent <span class="token operator">||</span> oldValue <span class="token operator">==</span> null<span class="token punctuation">)</span>              e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>          <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token operator">++</span>modCount<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>size <span class="token operator">></span> threshold<span class="token punctuation">)</span>      <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span>evict<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * resize方法，只展示了部分核心代码 * 数组的初始化或扩容，扩容是加倍的 */</span><span class="token keyword">final</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldTab <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 旧数组存在元素</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> oldCap<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// bucket存在元素</span>                oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 这个bucket没有链表，只需要将它重新计算下在新数组的索引，并放入对于的bucket中</span>                    newTab<span class="token punctuation">[</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> <span class="token punctuation">(</span>newCap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 红黑树结构</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>e<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> newTab<span class="token punctuation">,</span> j<span class="token punctuation">,</span> oldCap<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// preserve order</span>                    <span class="token comment" spellcheck="true">/* 旧数组的桶在新数组的索引位的节点 */</span>                    <span class="token comment" spellcheck="true">// 索引大小没有变化</span>                    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> loHead <span class="token operator">=</span> null<span class="token punctuation">,</span> loTail <span class="token operator">=</span> null<span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 索引扩大了旧数组的长度（即新索引位：旧索引位+旧数组长度）</span>                    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> hiHead <span class="token operator">=</span> null<span class="token punctuation">,</span> hiTail <span class="token operator">=</span> null<span class="token punctuation">;</span>                    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">;</span>                    <span class="token keyword">do</span> <span class="token punctuation">{</span>                        next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// e.hash &amp; oldCap == 0 就代表e的hash值（转换为2进制）高一位为0，</span>                        <span class="token comment" spellcheck="true">// 与（新的容量-1）相与后，其在数组的索引位置不变</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> oldCap<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">==</span> null<span class="token punctuation">)</span>                                loHead <span class="token operator">=</span> e<span class="token punctuation">;</span>                            <span class="token keyword">else</span>                                loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>                            loTail <span class="token operator">=</span> e<span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 这里则高一位为1，与新的容量 &amp; 后，</span>                             <span class="token comment" spellcheck="true">// 其在新数组的索引位置会增加新容量的扩大值（即原容量的大小）</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">==</span> null<span class="token punctuation">)</span>                                hiHead <span class="token operator">=</span> e<span class="token punctuation">;</span>                            <span class="token keyword">else</span>                                hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>                            hiTail <span class="token operator">=</span> e<span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>                        newTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> loHead<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>                        newTab<span class="token punctuation">[</span>j <span class="token operator">+</span> oldCap<span class="token punctuation">]</span> <span class="token operator">=</span> hiHead<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> newTab<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-3-线程不安全"><a href="#1-3-线程不安全" class="headerlink" title="1.3 线程不安全"></a>1.3 线程不安全</h3><blockquote><ul><li>当两个线程同时put数据时，且被put的两个数据能定位到HashMap数组的相同那个bucket位置上，就可能产生一个覆盖掉另一个的可能，造成一个数据消失。</li><li>多个线程同时修改 HashMap的结构时（如插入、删除或扩容），可能会导致部分数据丢失。比如线程A插入，而线程B正在扩容，最终导致A线程插入的数据丢失</li><li>没有volatile或锁的同步机制，会导致一个线程的修改对另一个线程不可见</li></ul></blockquote><h2 id="2-LinkedHashMap"><a href="#2-LinkedHashMap" class="headerlink" title="2 LinkedHashMap"></a>2 LinkedHashMap</h2><p><code>LinkedHashMap</code> 是 <code>HashMap</code> 的子类，它不仅实现了 <code>Map</code> 接口，还具有排序功能。其排序行为由 <code>accessOrder</code> 字段控制</p><h3 id="2-1-核心字段"><a href="#2-1-核心字段" class="headerlink" title="2.1 核心字段"></a>2.1 核心字段</h3><ul><li><code>head</code>：链表的头节点，指向最早插入或访问的节点。</li><li><code>tail</code>：链表的尾节点，指向最近插入或访问的节点。</li><li><code>accessOrder</code>（默认 <code>false</code>）：<ul><li><code>false</code>：按照<strong>插入顺序排序</strong>，越晚插入的元素越排在链表末尾。</li><li><code>true</code>：按照<strong>访问顺序排序</strong>，最近访问的元素会被移动到链表末尾。<strong>可用于实现 LRU 缓存。</strong></li></ul></li></ul><h3 id="2-2-排序实现原理"><a href="#2-2-排序实现原理" class="headerlink" title="2.2 排序实现原理"></a>2.2 排序实现原理</h3><h4 id="2-2-1-双向链表"><a href="#2-2-1-双向链表" class="headerlink" title="2.2.1 双向链表"></a>2.2.1 双向链表</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 继承了HashMap.Node的Entry内部结构</span><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">HashMap<span class="token punctuation">.</span>Node</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 具有链表结构的Entry</span>    <span class="token comment" spellcheck="true">// 前驱节点和后继节点</span>    Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> before<span class="token punctuation">,</span> after<span class="token punctuation">;</span>    <span class="token function">Entry</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-2-添加元素"><a href="#2-2-2-添加元素" class="headerlink" title="2.2.2 添加元素"></a>2.2.2 添加元素</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 重写了HashMap的newNode方法，在构造新节点时将其添加到链表末尾</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token function">newNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将新节点链接到链表末尾</span>    <span class="token function">linkNodeLast</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> p<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-3-访问节点移动到末尾"><a href="#2-2-3-访问节点移动到末尾" class="headerlink" title="2.2.3 访问节点移动到末尾"></a>2.2.3 访问节点移动到末尾</h4><p>如果 <code>accessOrder</code> 为 <code>true</code>，<code>LinkedHashMap</code> 会在访问节点时（如调用 <code>get</code> 方法）触发 <code>afterNodeAccess</code> 方法，将最近访问的节点移动到链表末尾，基于此<strong>可以实现LRU缓存</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 重写的HashMap#afterNodeAccess方法，</span><span class="token keyword">void</span> <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    LinkedHashMap<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> last<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>accessOrder <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>last <span class="token operator">=</span> tail<span class="token punctuation">)</span> <span class="token operator">!=</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// accessOrder为true，e不为tail</span>        <span class="token comment" spellcheck="true">// 重排序当前元素，将当前节点设为新的tail（保持最近一次被访问的节点在最后面）</span>        LinkedHashMap<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p <span class="token operator">=</span>            <span class="token punctuation">(</span>LinkedHashMap<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>e<span class="token punctuation">,</span> b <span class="token operator">=</span> p<span class="token punctuation">.</span>before<span class="token punctuation">,</span> a <span class="token operator">=</span> p<span class="token punctuation">.</span>after<span class="token punctuation">;</span>        p<span class="token punctuation">.</span>after <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// e为head，更新头节点</span>            head <span class="token operator">=</span> a<span class="token punctuation">;</span>        <span class="token keyword">else</span>            b<span class="token punctuation">.</span>after <span class="token operator">=</span> a<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// e不为tail</span>            a<span class="token punctuation">.</span>before <span class="token operator">=</span> b<span class="token punctuation">;</span>        <span class="token keyword">else</span>            last <span class="token operator">=</span> b<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>last <span class="token operator">==</span> null<span class="token punctuation">)</span>            head <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            p<span class="token punctuation">.</span>before <span class="token operator">=</span> last<span class="token punctuation">;</span>            last<span class="token punctuation">.</span>after <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        tail <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token operator">++</span>modCount<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-ConcurrentHashMap"><a href="#3-ConcurrentHashMap" class="headerlink" title="3 ConcurrentHashMap"></a>3 ConcurrentHashMap</h2><p><code>ConcurrentHashMap</code> 是一个线程安全的 <code>Map</code> 实现，通过 **CAS 和 <strong>分段锁</strong> 机制实现高效的并发操作。其数据结构与 <code>HashMap</code> 类似，采用 <strong>数组 + 链表 + 红黑树</strong> 的形式：</p><ul><li>当链表长度超过 8 时，链表会转换为红黑树。</li><li>当红黑树节点数小于 6 时，红黑树会退化为链表。</li></ul><h3 id="3-1-put方法"><a href="#3-1-put方法" class="headerlink" title="3.1 put方法"></a>3.1 put方法</h3><p><strong>死循环put元素</strong>，直到操作成功才退出</p><ul><li>数组还没初始化，开始数组的初始化</li><li>数组的bucket还未被占用，CAS占用（成功了就break，失败了就代表已经被其他节点占用了，进行下一次循环进入其他if分支）</li><li><strong>当前桶为<code>ForwardingNode</code>，表示有线程正在进行扩容操作，则先帮助扩容，等扩容完毕在继续put</strong></li><li>bucket被占用，锁住根节点，开始构造到链表的为尾节点。添加到尾节点后，在判断当前链表长度是否超过8，否则就转换为红黑树</li></ul><h3 id="3-2-扩容（重点）"><a href="#3-2-扩容（重点）" class="headerlink" title="3.2 扩容（重点）"></a>3.2 扩容（重点）</h3><p>​核心是通过 <strong>多线程协作</strong> 和 <strong>分段迁移</strong> 的方式进行高效的数据迁移，同时尽量减少对读写操作的影响</p><h4 id="3-2-1-扩容触发时机"><a href="#3-2-1-扩容触发时机" class="headerlink" title="3.2.1 扩容触发时机"></a>3.2.1 扩容触发时机</h4><ul><li>当 <code>ConcurrentHashMap</code> 中的元素数量超过 <strong>阈值（threshold）</strong> 时触发</li><li>阈值计算公式：<code>阈值 = 数组长度 * 负载因子（loadFactor，默认 0.75）</code>。</li></ul><h4 id="3-2-2-具体步骤"><a href="#3-2-2-具体步骤" class="headerlink" title="3.2.2 具体步骤"></a>3.2.2 具体步骤</h4><ul><li><p>首先创建一个新的数据，为元素组大小的2倍。将其设置到nextTable字段</p></li><li><p>通过CAS设置transferIndex（初始设为旧数组的长度，即是从旧数组末尾开始向前遍历转移数据的）</p></li><li><p>每个线程通过CAS从transferIndex获取一段连续长度为stride（步长）的桶，stride计算如下</p><ul><li><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 计算步长：即扩容时每个线程每次最小处理的数组连续长度</span><span class="token comment" spellcheck="true">// cpu为1，则由这个线程全部处理；cpu数量大于1，每个核心负责的步长为 数组长度/(8 * cpu核数) ，不过如果计算出步长小于16，则会被设置为16。确保线程的工作量均衡</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>stride <span class="token operator">=</span> <span class="token punctuation">(</span>NCPU <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>n <span class="token operator">>>></span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">/</span> NCPU <span class="token operator">:</span> n<span class="token punctuation">)</span> <span class="token operator">&lt;</span> MIN_TRANSFER_STRIDE<span class="token punctuation">)</span><span class="token punctuation">{</span>  stride <span class="token operator">=</span> MIN_TRANSFER_STRIDE<span class="token punctuation">;</span><span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>开始迁移数据，到这一步了每个线程就只会迁移自己所负责的步长索引数据，不会冲突</p><ul><li>空桶：则放置一个 <code>ForwardingNode</code>，表示该桶已迁移</li><li>桶为<code>ForwardingNode</code>：当前桶已迁移。因为整体是从后向前迁移的，可推测当前线程负责的这段步长索引一定已处理完毕，即这段步长内这个桶后面的所有桶也都已经被处理完成了，需要重新计算它下一次该负责的新步长索引</li><li>桶未迁移：则操作加锁，对桶中的链表或红黑树进行迁移，迁移完成后，再将当前桶放置为<code>ForwardingNode</code>节点</li></ul></li><li><p>当最后一个线程迁移完毕后，则更新table为新数据和sizeCtl，表示扩容完成</p></li></ul><h4 id="3-2-3-相关思考"><a href="#3-2-3-相关思考" class="headerlink" title="3.2.3 相关思考"></a>3.2.3 相关思考</h4><ul><li><p>步长计算安全嘛？</p><blockquote><p>​安全，通过CAS设置公共变量transferIndex（初始值为table.length），同时该变量为volatile，它的变化能立马被其他线程感知到，可以保证每个线程处理的步长索引不会重复和交叉</p></blockquote></li><li><p>其他线程如何感知并帮助扩容？</p><blockquote><p>​通过判断桶节点为ForwardingNode，则表示正在扩容，此时这个线程则帮助扩容，计算自己需要处理的步长索引来转移数据到新数组中。每处理完一个桶也将其设为ForwardingNode节点</p></blockquote></li><li><p>get方法并没有加锁，如果桶已被转移怎么获取到数据？</p><blockquote><p>​首先扩容是读写分离的，扩容时不会对桶本身做任何修改（即不会修改Node的内部指针数据），所以如果拿到原桶数据，则能直接遍历获取数据。而如果拿到的是ForwardingNode，它本身也提供了find方法，会到新数组中去找到需要的数据</p></blockquote></li><li><p>扩容完成如何处理？</p><blockquote><p>​每个线程完成自己负责区间的迁移后，会更新<code>sizeCtl</code>字段中的扩容线程数计数，判断确定最后一个完成迁移的线程会将新数组赋值给table并重新计算<code>sizeCtl</code>的阈值</p></blockquote></li><li><p>最后需要注意，在操作数组中的桶时，都会获取这个桶节点的锁（put和resize等等修改方法），锁是相同的，所以不必担心某一个桶的相关数据被多个线程同时处理（put，resize等）</p></li></ul><h4 id="3-2-4-核心代码"><a href="#3-2-4-核心代码" class="headerlink" title="3.2.4 核心代码"></a>3.2.4 核心代码</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">,</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> nextTab<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">,</span> stride<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 计算步长：即扩容时每个线程每次最小处理的数组连续长度</span>    <span class="token comment" spellcheck="true">// cpu为1，则由这个线程全部处理；cpu数量大于1，每个核心负责的步长为 数组长度/(8 * cpu核数) ，不过如何计算出步长小于16，则会被设置为16。确保线程的工作量均衡</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>stride <span class="token operator">=</span> <span class="token punctuation">(</span>NCPU <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>n <span class="token operator">>>></span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">/</span> NCPU <span class="token operator">:</span> n<span class="token punctuation">)</span> <span class="token operator">&lt;</span> MIN_TRANSFER_STRIDE<span class="token punctuation">)</span>        stride <span class="token operator">=</span> MIN_TRANSFER_STRIDE<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// subdivide range</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nextTab <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// initiating</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// 创建新数组，2次幂便于扩容计算新索引位置</span>            Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> nt <span class="token operator">=</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span>n <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            nextTab <span class="token operator">=</span> nt<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// try to cope with OOME</span>            sizeCtl <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        nextTable <span class="token operator">=</span> nextTab<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 表示从数组末尾开始分配迁移任务</span>        transferIndex <span class="token operator">=</span> n<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> nextn <span class="token operator">=</span> nextTab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    ForwardingNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> fwd <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ForwardingNode</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">(</span>nextTab<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 当前线程是否需要继续在旧数组上截取一段桶来处理数据，默认是</span>    <span class="token keyword">boolean</span> advance <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 扩容完毕的标志</span>    <span class="token keyword">boolean</span> finishing <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// to ensure sweep before committing nextTab</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> bound <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// i 是当前线程正在处理的桶的索引，bound 是当前线程负责的迁移任务的起始索引（也就是在处理中则 i>bound）</span>        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> f<span class="token punctuation">;</span> <span class="token keyword">int</span> fh<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 检查当前线程负责的步长内的桶是否处理完毕。处理完毕，则选取下一段当前现场该处理的步长索引段</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>advance<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> nextIndex<span class="token punctuation">,</span> nextBound<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span>i <span class="token operator">>=</span> bound <span class="token operator">||</span> finishing<span class="token punctuation">)</span>                advance <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>nextIndex <span class="token operator">=</span> transferIndex<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                i <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                advance <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>U<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span>                     <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> TRANSFERINDEX<span class="token punctuation">,</span> nextIndex<span class="token punctuation">,</span>                      nextBound <span class="token operator">=</span> <span class="token punctuation">(</span>nextIndex <span class="token operator">></span> stride <span class="token operator">?</span>                                   nextIndex <span class="token operator">-</span> stride <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                bound <span class="token operator">=</span> nextBound<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// i初始化为旧数组最后一个索引位置</span>                i <span class="token operator">=</span> nextIndex <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>                advance <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> i <span class="token operator">>=</span> n <span class="token operator">||</span> i <span class="token operator">+</span> n <span class="token operator">>=</span> nextn<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 当前线程扩容完毕处理</span>            <span class="token keyword">int</span> sc<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>finishing<span class="token punctuation">)</span> <span class="token punctuation">{</span>                nextTable <span class="token operator">=</span> null<span class="token punctuation">;</span>                table <span class="token operator">=</span> nextTab<span class="token punctuation">;</span>                sizeCtl <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token punctuation">(</span>n <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>U<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> SIZECTL<span class="token punctuation">,</span> sc <span class="token operator">=</span> sizeCtl<span class="token punctuation">,</span> sc <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>sc <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token function">resizeStamp</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> RESIZE_STAMP_SHIFT<span class="token punctuation">)</span>                    <span class="token keyword">return</span><span class="token punctuation">;</span>                finishing <span class="token operator">=</span> advance <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                i <span class="token operator">=</span> n<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// recheck before commit</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>f <span class="token operator">=</span> <span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 空桶，CAS放置ForwardingNode，让其他线程可以感知到，以帮助扩容</span>            advance <span class="token operator">=</span> <span class="token function">casTabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> null<span class="token punctuation">,</span> fwd<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fh <span class="token operator">=</span> f<span class="token punctuation">.</span>hash<span class="token punctuation">)</span> <span class="token operator">==</span> MOVED<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 当前桶已被处理</span>            <span class="token comment" spellcheck="true">// 到这了就说明这段步长索引处理完毕，需要重新计算新步长索引</span>            advance <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// already processed</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 桶加锁，开始转移当前桶的链表或红黑树到新的数组里</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">==</span> f<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 获取成功，再次校验桶节点是否变化，未变才继续操作（避免被其他刚释放了这个锁的线程给修改了）</span>                    <span class="token comment" spellcheck="true">// 桶数据转移到新数组去，和HashMap类似计算新数组中的索引</span>                    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> ln<span class="token punctuation">,</span> hn<span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>fh <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">int</span> runBit <span class="token operator">=</span> fh <span class="token operator">&amp;</span> n<span class="token punctuation">;</span>                        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> lastRun <span class="token operator">=</span> f<span class="token punctuation">;</span>                        <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p <span class="token operator">=</span> f<span class="token punctuation">.</span>next<span class="token punctuation">;</span> p <span class="token operator">!=</span> null<span class="token punctuation">;</span> p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token keyword">int</span> b <span class="token operator">=</span> p<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> n<span class="token punctuation">;</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">!=</span> runBit<span class="token punctuation">)</span> <span class="token punctuation">{</span>                                runBit <span class="token operator">=</span> b<span class="token punctuation">;</span>                                lastRun <span class="token operator">=</span> p<span class="token punctuation">;</span>                            <span class="token punctuation">}</span>                        <span class="token punctuation">}</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>runBit <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            ln <span class="token operator">=</span> lastRun<span class="token punctuation">;</span>                            hn <span class="token operator">=</span> null<span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        <span class="token keyword">else</span> <span class="token punctuation">{</span>                            hn <span class="token operator">=</span> lastRun<span class="token punctuation">;</span>                            ln <span class="token operator">=</span> null<span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p <span class="token operator">=</span> f<span class="token punctuation">;</span> p <span class="token operator">!=</span> lastRun<span class="token punctuation">;</span> p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token keyword">int</span> ph <span class="token operator">=</span> p<span class="token punctuation">.</span>hash<span class="token punctuation">;</span> K pk <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">;</span> V pv <span class="token operator">=</span> p<span class="token punctuation">.</span>val<span class="token punctuation">;</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ph <span class="token operator">&amp;</span> n<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>                                ln <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">(</span>ph<span class="token punctuation">,</span> pk<span class="token punctuation">,</span> pv<span class="token punctuation">,</span> ln<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token keyword">else</span>                                hn <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">(</span>ph<span class="token punctuation">,</span> pk<span class="token punctuation">,</span> pv<span class="token punctuation">,</span> hn<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        <span class="token function">setTabAt</span><span class="token punctuation">(</span>nextTab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> ln<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token function">setTabAt</span><span class="token punctuation">(</span>nextTab<span class="token punctuation">,</span> i <span class="token operator">+</span> n<span class="token punctuation">,</span> hn<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 转移完后，旧数组的桶放置ForwardingNode，表示当前桶已处理完毕并表示为扩容中</span>                        <span class="token function">setTabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> fwd<span class="token punctuation">)</span><span class="token punctuation">;</span>                        advance <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token keyword">instanceof</span> <span class="token class-name">TreeBin</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        TreeBin<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> t <span class="token operator">=</span> <span class="token punctuation">(</span>TreeBin<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>f<span class="token punctuation">;</span>                        TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> lo <span class="token operator">=</span> null<span class="token punctuation">,</span> loTail <span class="token operator">=</span> null<span class="token punctuation">;</span>                        TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> hi <span class="token operator">=</span> null<span class="token punctuation">,</span> hiTail <span class="token operator">=</span> null<span class="token punctuation">;</span>                        <span class="token keyword">int</span> lc <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> hc <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                        <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> t<span class="token punctuation">.</span>first<span class="token punctuation">;</span> e <span class="token operator">!=</span> null<span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token keyword">int</span> h <span class="token operator">=</span> e<span class="token punctuation">.</span>hash<span class="token punctuation">;</span>                            TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span>                                <span class="token punctuation">(</span>h<span class="token punctuation">,</span> e<span class="token punctuation">.</span>key<span class="token punctuation">,</span> e<span class="token punctuation">.</span>val<span class="token punctuation">,</span> null<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>h <span class="token operator">&amp;</span> n<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>prev <span class="token operator">=</span> loTail<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>                                    lo <span class="token operator">=</span> p<span class="token punctuation">;</span>                                <span class="token keyword">else</span>                                    loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">;</span>                                loTail <span class="token operator">=</span> p<span class="token punctuation">;</span>                                <span class="token operator">++</span>lc<span class="token punctuation">;</span>                            <span class="token punctuation">}</span>                            <span class="token keyword">else</span> <span class="token punctuation">{</span>                                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>prev <span class="token operator">=</span> hiTail<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>                                    hi <span class="token operator">=</span> p<span class="token punctuation">;</span>                                <span class="token keyword">else</span>                                    hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">;</span>                                hiTail <span class="token operator">=</span> p<span class="token punctuation">;</span>                                <span class="token operator">++</span>hc<span class="token punctuation">;</span>                            <span class="token punctuation">}</span>                        <span class="token punctuation">}</span>                        ln <span class="token operator">=</span> <span class="token punctuation">(</span>lc <span class="token operator">&lt;=</span> UNTREEIFY_THRESHOLD<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">untreeify</span><span class="token punctuation">(</span>lo<span class="token punctuation">)</span> <span class="token operator">:</span>                            <span class="token punctuation">(</span>hc <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">TreeBin</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">(</span>lo<span class="token punctuation">)</span> <span class="token operator">:</span> t<span class="token punctuation">;</span>                        hn <span class="token operator">=</span> <span class="token punctuation">(</span>hc <span class="token operator">&lt;=</span> UNTREEIFY_THRESHOLD<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">untreeify</span><span class="token punctuation">(</span>hi<span class="token punctuation">)</span> <span class="token operator">:</span>                            <span class="token punctuation">(</span>lc <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">TreeBin</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">(</span>hi<span class="token punctuation">)</span> <span class="token operator">:</span> t<span class="token punctuation">;</span>                        <span class="token function">setTabAt</span><span class="token punctuation">(</span>nextTab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> ln<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token function">setTabAt</span><span class="token punctuation">(</span>nextTab<span class="token punctuation">,</span> i <span class="token operator">+</span> n<span class="token punctuation">,</span> hn<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 转移完后，旧数组的桶放置ForwardingNode，表示当前桶已处理完毕并表示为扩容中</span>                        <span class="token function">setTabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> fwd<span class="token punctuation">)</span><span class="token punctuation">;</span>                        advance <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4-为什么key和value不允许为null，而HashMap可以呢？"><a href="#3-4-为什么key和value不允许为null，而HashMap可以呢？" class="headerlink" title="3.4 为什么key和value不允许为null，而HashMap可以呢？"></a>3.4 为什么key和value不允许为null，而HashMap可以呢？</h3><blockquote><p>​<strong>ConcurrentHashMap如果允许key和value为null，会产生二义性</strong>。即不能确定map里本身没有这个数据，还是说有这个数据，但这个数据存的是null值。</p><p>​为什么HashMap可以允许呢？因为它不会产生二义性，使用<strong>HashMap设计用于单线程下，假设我们获取key为A的数据返回了null，之后还马上可以通过containsKey来判断到底是不存在A还是A就为null（因为是单线程，不用担心其他线程会修改数据）</strong></p><p>​但ConcurrentHashMap是线程安全的，也就是默认会在多线程下修改数据。假设ConcurrentHashMap支持设置null，这时线程A获取key为null的数据返回了null，此时我们不确定A在不在ConcurrentHashMap里，需要用containsKey来判断key为null是否存在于ConcurrentHashMap里。但多线程的情况下，B线程在A线程containsKey操作前添加了key为null的数据，导致A线程containsKey返回了true，导致和第一步预期不同（第一步可能是不存在key为null的数据）</p><p>​综上：<strong>ConcurrentHashMap，它是为并发而生的，它是要用在并发场景中的。假如允许使用 map.get(key)返回 null ，这时是没办法通过 map.containsKey来准确的检测，因为在检测过程中可能会被其他线程锁修改，而导致检测结果并不可靠。所以直接禁用了null，好处就是返回null一定能表示key不存在，而不是有其他的含义，让语义更明确了</strong></p><p>​所以这个设计选择反映了<strong>并发编程的一个重要原则：通过适当的限制来换取更好的可靠性和简单性</strong>。虽然失去了存储null值的能力，但换来了更清晰的语义和更好的并发安全性。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> jdk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Map </tag>
            
            <tag> ConcurrentHashMap </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
