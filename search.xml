<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CloudFlare-CDN缓存清除</title>
      <link href="/2024/06/14/cloudflare-cdn-huan-cun-qing-chu/"/>
      <url>/2024/06/14/cloudflare-cdn-huan-cun-qing-chu/</url>
      
        <content type="html"><![CDATA[<hr><p>​给出了一些api用于清除Cloudflare的CDN缓存方式</p> <span id="more"></span><h1 id="CloudFlare-CDN缓存清除"><a href="#CloudFlare-CDN缓存清除" class="headerlink" title="CloudFlare-CDN缓存清除"></a>CloudFlare-CDN缓存清除</h1><p>​搭建个人博客网站时，域名托管到CF，会使用CF的CDN。当你重新修改博客网站的样式css和js文件等再重新部署，一般都不会立马生效，因为CDN里的缓存还在，前端访问用的还是旧css和js文件。这时我们需要主动清除CDN的缓存，来让缓存重新加载，以便让我们修改的样式在网站立马生效</p><h2 id="1-purgeUrl"><a href="#1-purgeUrl" class="headerlink" title="1 purgeUrl"></a>1 purgeUrl</h2><p><img src="/img/cloudflare-purge-url.png"></p><h2 id="2-使用ApiKey清除（不推荐）"><a href="#2-使用ApiKey清除（不推荐）" class="headerlink" title="2 使用ApiKey清除（不推荐）"></a>2 使用ApiKey清除（不推荐）</h2><ul><li>ZONE_ID：区域id，即你在CF上托管的根域名id</li><li>EMAIL：你的邮箱</li><li>API_KEY：可自建apiKey，也可使用CF默认有的GlobalApiKey（<strong>个人资料 -&gt; API令牌 -&gt; API密钥 -&gt; Global API Key</strong>）</li></ul><h3 id="2-1-全部清除"><a href="#2-1-全部清除" class="headerlink" title="2.1 全部清除"></a>2.1 全部清除</h3><pre class="line-numbers language-bash"><code class="language-bash">curl https://api.cloudflare.com/client/v4/zones/<span class="token variable">$ZONE_ID</span>/purge_cache \    -H <span class="token string">'Content-Type: application/json'</span> \    -H <span class="token string">"X-Auth-Email: <span class="token variable">$EMAIL</span>"</span> \    -H <span class="token string">"X-Auth-Key: <span class="token variable">$API_KEY</span>"</span> \    -d <span class="token string">'{"purge_everything": true}'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-批量清除具体文件"><a href="#2-2-批量清除具体文件" class="headerlink" title="2.2 批量清除具体文件"></a>2.2 批量清除具体文件</h3><p>一次性调用有文件数量限制： <strong>Free&#x2F;Pro&#x2F;Business一次上限30个，Enterprise一次上限500个</strong></p><pre class="line-numbers language-bash"><code class="language-bash">curl https://api.cloudflare.com/client/v4/zones/<span class="token variable">$ZONE_ID</span>/purge_cache \    -H <span class="token string">'Content-Type: application/json'</span> \    -H <span class="token string">"X-Auth-Email: <span class="token variable">$EMAIL</span>"</span> \    -H <span class="token string">"X-Auth-Key: <span class="token variable">$API_KEY</span>"</span> \    -d <span class="token string">'{    "files": [        "https://blog.shanzhao.site/css/my.css",        "https://blog.shanzhao.site/libs/others/snow.js"    ]}'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-自定义token清除（推荐）"><a href="#3-自定义token清除（推荐）" class="headerlink" title="3 自定义token清除（推荐）"></a>3 自定义token清除（推荐）</h2><p>自定义token不仅<strong>可以最小化的控制权限，也可以设置token的有效时常</strong>。使用如下方式创建一个专用于清理指定根域名的token</p><p><img src="/img/couldflare-purge-token.png"></p><h3 id="3-1-验证token是否生效"><a href="#3-1-验证token是否生效" class="headerlink" title="3.1 验证token是否生效"></a>3.1 验证token是否生效</h3><pre class="line-numbers language-bash"><code class="language-bash">curl -X GET <span class="token string">"https://api.cloudflare.com/client/v4/user/tokens/verify"</span> \     -H <span class="token string">"Authorization: Bearer <span class="token variable">$API_TOKEN</span>"</span> \     -H <span class="token string">"Content-Type:application/json"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="3-2-全部清除"><a href="#3-2-全部清除" class="headerlink" title="3.2 全部清除"></a>3.2 全部清除</h3><pre class="line-numbers language-bash"><code class="language-bash">curl https://api.cloudflare.com/client/v4/zones/<span class="token variable">$ZONE_ID</span>/purge_cache \    -H <span class="token string">'Content-Type: application/json'</span> \    -H <span class="token string">"Authorization: Bearer <span class="token variable">$API_TOKEN</span>"</span> \    -d <span class="token string">'{"purge_everything": true}'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-批量清除具体文件"><a href="#3-3-批量清除具体文件" class="headerlink" title="3.3 批量清除具体文件"></a>3.3 批量清除具体文件</h3><p>一次性调用有文件数量限制： <strong>Free&#x2F;Pro&#x2F;Business一次上限30个，Enterprise一次上限500个</strong></p><pre class="line-numbers language-bash"><code class="language-bash">curl https://api.cloudflare.com/client/v4/zones/<span class="token variable">$ZONE_ID</span>/purge_cache \    -H <span class="token string">'Content-Type: application/json'</span> \    -H <span class="token string">"Authorization: Bearer <span class="token variable">$API_TOKEN</span>"</span> \    -d <span class="token string">'{    "files": [        "https://blog.shanzhao.site/css/my.css",        "https://blog.shanzhao.site/libs/others/snow.js"    ]}'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-其他"><a href="#4-其他" class="headerlink" title="4 其他"></a>4 其他</h2><p>还有其他的参数，比如tags，hosts，prefixes，但这些都是企业版的用户才能使用，这里就不写了</p><h2 id="5-参考链接"><a href="#5-参考链接" class="headerlink" title="5 参考链接"></a>5 参考链接</h2><ul><li><a href="https://developers.cloudflare.com/api/resources/cache/methods/purge/">官方清除缓存文档</a></li><li><a href="https://dash.cloudflare.com/profile/api-tokens">cloudflare dashboard创建token和查看ApiKey</a></li><li><a href="https://developers.cloudflare.com/fundamentals/setup/find-account-and-zone-ids/">ZoneId获取</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> cloudflare </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cdn缓存清除 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-容器初始化</title>
      <link href="/2021/01/08/spring-rong-qi-chu-shi-hua/"/>
      <url>/2021/01/08/spring-rong-qi-chu-shi-hua/</url>
      
        <content type="html"><![CDATA[<hr><p>​整体分析了BeanFactory和ApplicationContext的区别。并从Spring Bean创建流程源码分析了bean的创建流程并对其进行总结，并分析了三级缓存的作用</p><span id="more"></span><h1 id="Spring-容器的初始化（5-1-x）"><a href="#Spring-容器的初始化（5-1-x）" class="headerlink" title="Spring-容器的初始化（5.1.x）"></a>Spring-容器的初始化（5.1.x）</h1><h2 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h2><p>​<code>BeanFactory</code> 是 Spring 最基础的 IoC 容器接口，仅提供了 Bean 的获取与管理能力。而 <code>DefaultListableBeanFactory</code> 是其默认实现类，它通过实现多个关键接口，构建出完整的 IoC 容器功能体系。</p><p>以下是 <code>DefaultListableBeanFactory</code> 实现的主要接口以及其对应的职责：</p><table><thead><tr><th align="center">主要接口</th><th align="left">主要功能</th></tr></thead><tbody><tr><td align="center"><strong>AliasRegistry</strong></td><td align="left">提供 Bean 的别名注册和解析能力。允许一个 Bean 在容器中有多个名字，是 Spring IoC 容器灵活命名机制的基础。</td></tr><tr><td align="center"><strong>BeanDefinitionRegistry</strong></td><td align="left">管理 Bean 的定义信息（<code>BeanDefinition</code>），提供注册、删除、查询等能力。是容器启动期间加载和维护元数据的关键接口。</td></tr><tr><td align="center"><strong>SingletonBeanRegistry</strong></td><td align="left">管理单例 Bean 的注册与缓存机制，控制 Bean 的生命周期。所有单例 Bean 都存储在 <code>singletonObjects</code> 缓存中。</td></tr><tr><td align="center"><strong>AutowireCapableBeanFactory</strong></td><td align="left">提供创建 Bean 实例、属性注入、初始化回调、AOP 代理等高级功能。<br />通常用于手动创建并管理 Bean 的生命周期，比如调用 <code>createBean()</code>、<code>autowireBean()</code> 等。</td></tr><tr><td align="center"><strong>ConfigurableListableBeanFactory</strong></td><td align="left">是 <code>BeanFactory</code> 的高级配置接口，支持访问所有已注册的 <code>BeanDefinition</code>，还可以注册 <code>BeanPostProcessor</code>组件。<br /><strong>常用于容器初始化后对 BeanFactory 进行增强或定制</strong>。</td></tr><tr><td align="center"><strong>HierarchicalBeanFactory</strong></td><td align="left">支持父子容器结构，允许子容器从父容器中查找 Bean，提升模块化和隔离能力。<br /> 是实现 <code>ApplicationContext</code> 之间嵌套结构的基础。</td></tr><tr><td align="center"><strong>FactoryBeanRegistrySupport</strong>  （继承自 <code>AbstractAutowireCapableBeanFactory</code>）</td><td align="left">支持 <code>FactoryBean</code> 机制的关键实现类，负责识别并缓存 <code>FactoryBean</code> 创建的产品对象。<br /> 比如，当你定义了一个实现 <code>FactoryBean&lt;T&gt;</code> 的类时，容器最终会获取到 <code>T</code> 类型的对象，而不是工厂本身。</td></tr></tbody></table><h2 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h2><p>ApplicationContext不仅实现了BeanFactory接口，还多了许多拓展接口，其余接口如下</p><table><thead><tr><th>其他接口</th><th>主要功能</th></tr></thead><tbody><tr><td><strong>EnvironmentCapable</strong></td><td>获取Environment，可读取各种配置</td></tr><tr><td><strong>MessageSource</strong></td><td>国际化消息解析</td></tr><tr><td><strong>ApplicationEventPublisher</strong></td><td>支持事件发布&#x2F;监听机制</td></tr><tr><td><strong>ResourcePatternResolver</strong></td><td>支持资源加载，比如 classpath 等路径资源</td></tr></tbody></table><p>​在注解驱动的环境下，常用的 <code>ApplicationContext</code> 实现类为 <code>AnnotationConfigApplicationContext</code>。该类内部封装了一个 <code>DefaultListableBeanFactory</code> 实例，作为底层的 Bean 注册与管理中心，从而继承了 <code>BeanFactory</code> 的全部能力。</p><p>​而其<strong>refresh</strong>方法更是容器启动流程的核心。<strong>Bean的解析、注册，各种后置处理器的准备、使用，国际化和事件发布、各种监听器均在这个方法中完成，可以说是整个Spring的核心</strong></p><h2 id="bean创建流程源码（只保留了重要的部分）"><a href="#bean创建流程源码（只保留了重要的部分）" class="headerlink" title="bean创建流程源码（只保留了重要的部分）"></a>bean创建流程源码（只保留了重要的部分）</h2><h3 id="AbstractBeanFactory-doGetBean"><a href="#AbstractBeanFactory-doGetBean" class="headerlink" title="AbstractBeanFactory#doGetBean"></a>AbstractBeanFactory#doGetBean</h3><p>org.springframework.beans.factory.support.AbstractBeanFactory#doGetBean方法部分关键代码</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 获取真实的beanName，参数name可能是bean的别名和FactoryBean格式（前面有&amp;）</span>String beanName <span class="token operator">=</span> <span class="token function">transformedBeanName</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>Object bean<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Eagerly check singleton cache for manually registered singletons.</span><span class="token comment" spellcheck="true">// 为了解决循环引用，在这里就必须可以从二级或三级缓存中拿bean（尽管此时这个bean实例化了，还未填充数据和初始化）</span>Object sharedInstance <span class="token operator">=</span> <span class="token function">getSingleton</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>sharedInstance <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> args <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>  bean <span class="token operator">=</span> <span class="token function">getObjectForBeanInstance</span><span class="token punctuation">(</span>sharedInstance<span class="token punctuation">,</span> name<span class="token punctuation">,</span> beanName<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 循环创建多例bean抛出异常</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isPrototypeCurrentlyInCreation</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BeanCurrentlyInCreationException</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 先获取父容器</span>  BeanFactory parentBeanFactory <span class="token operator">=</span> <span class="token function">getParentBeanFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 父BeanFactory存在且当前的BeanFactory不存在BeanDefinition，就会去父BeanFactory递归查找</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>parentBeanFactory <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">containsBeanDefinition</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 在父容器中获取bean，能获取到就直接返回了</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token punctuation">}</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>typeCheckOnly<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 标记bean为已创建</span>    <span class="token function">markBeanAsCreated</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">try</span> <span class="token punctuation">{</span>    RootBeanDefinition mbd <span class="token operator">=</span> <span class="token function">getMergedLocalBeanDefinition</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">checkMergedBeanDefinition</span><span class="token punctuation">(</span>mbd<span class="token punctuation">,</span> beanName<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    String<span class="token punctuation">[</span><span class="token punctuation">]</span> dependsOn <span class="token operator">=</span> mbd<span class="token punctuation">.</span><span class="token function">getDependsOn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>dependsOn <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 有dependsOn的bean，则优先创建这些bean</span>      <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// Create bean instance.</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">isSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 单例bean的创建</span>      sharedInstance <span class="token operator">=</span> <span class="token function">getSingleton</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>          <span class="token keyword">return</span> <span class="token function">createBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">BeansException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// bean创建失败，执行destory相关方法并直接抛出异常</span>          <span class="token function">destroySingleton</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">throw</span> ex<span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      bean <span class="token operator">=</span> <span class="token function">getObjectForBeanInstance</span><span class="token punctuation">(</span>sharedInstance<span class="token punctuation">,</span> name<span class="token punctuation">,</span> beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">isPrototype</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 创建多例bean</span>      Object prototypeInstance <span class="token operator">=</span> null<span class="token punctuation">;</span>      <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token function">beforePrototypeCreation</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>        prototypeInstance <span class="token operator">=</span> <span class="token function">createBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token function">afterPrototypeCreation</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      bean <span class="token operator">=</span> <span class="token function">getObjectForBeanInstance</span><span class="token punctuation">(</span>prototypeInstance<span class="token punctuation">,</span> name<span class="token punctuation">,</span> beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 特殊的scope里bean的创建。创建在session，request等scope里面的bean</span>      String scopeName <span class="token operator">=</span> mbd<span class="token punctuation">.</span><span class="token function">getScope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      Scope scope <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>scopes<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>scopeName<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">// 获取并放入对应的Scope中，在返回bean</span>      Object scopedInstance <span class="token operator">=</span> scope<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token function">beforePrototypeCreation</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>          <span class="token keyword">return</span> <span class="token function">createBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">finally</span> <span class="token punctuation">{</span>          <span class="token function">afterPrototypeCreation</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      bean <span class="token operator">=</span> <span class="token function">getObjectForBeanInstance</span><span class="token punctuation">(</span>scopedInstance<span class="token punctuation">,</span> name<span class="token punctuation">,</span> beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">BeansException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">cleanupAfterBeanCreationFailure</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">throw</span> ex<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// Check if required type matches the type of the actual bean instance.</span><span class="token keyword">if</span> <span class="token punctuation">(</span>requiredType <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>requiredType<span class="token punctuation">.</span><span class="token function">isInstance</span><span class="token punctuation">(</span>bean<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    T convertedBean <span class="token operator">=</span> <span class="token function">getTypeConverter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">convertIfNecessary</span><span class="token punctuation">(</span>bean<span class="token punctuation">,</span> requiredType<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>convertedBean <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BeanNotOfRequiredTypeException</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> requiredType<span class="token punctuation">,</span> bean<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> convertedBean<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span> bean<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="DefaultSingletonBeanRegistry-getSingleton"><a href="#DefaultSingletonBeanRegistry-getSingleton" class="headerlink" title="DefaultSingletonBeanRegistry#getSingleton"></a>DefaultSingletonBeanRegistry#getSingleton</h4><p>从三级缓存中获取bean</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">protected</span> Object <span class="token function">getSingleton</span><span class="token punctuation">(</span>String beanName<span class="token punctuation">,</span> <span class="token keyword">boolean</span> allowEarlyReference<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 先从一级缓存中直接获取</span>        Object singletonObject <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>singletonObjects<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 单例bean还没创建好但是正在创建的情况（说明已经有循环引用了）</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>singletonObject <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> <span class="token function">isSingletonCurrentlyInCreation</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 二级缓存中获取</span>            singletonObject <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>earlySingletonObjects<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>singletonObject <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> allowEarlyReference<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>singletonObjects<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    singletonObject <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>singletonObjects<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>singletonObject <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 一级缓存为空，从二级中取</span>                        singletonObject <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>earlySingletonObjects<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>singletonObject <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 二级缓存为空，再从三级缓存中获取</span>                            ObjectFactory<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> singletonFactory <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>singletonFactories<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>singletonFactory <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                                <span class="token comment" spellcheck="true">// 三级缓存不为空，取出该bean，放入二级缓存，同时从三级缓存中删除</span>                                singletonObject <span class="token operator">=</span> singletonFactory<span class="token punctuation">.</span><span class="token function">getObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token keyword">this</span><span class="token punctuation">.</span>earlySingletonObjects<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> singletonObject<span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token keyword">this</span><span class="token punctuation">.</span>singletonFactories<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token punctuation">}</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> singletonObject<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="AbstractAutowireCapableBeanFactory-doCreateBean"><a href="#AbstractAutowireCapableBeanFactory-doCreateBean" class="headerlink" title="AbstractAutowireCapableBeanFactory#doCreateBean"></a>AbstractAutowireCapableBeanFactory#doCreateBean</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 实例化bean。先创建出一个空壳的bean，各种field和方法都没有填充和调用</span>BeanWrapper instanceWrapper <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">isSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  instanceWrapper <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>factoryBeanInstanceCache<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span>instanceWrapper <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>  instanceWrapper <span class="token operator">=</span> <span class="token function">createBeanInstance</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 已实例化的bean</span>Object bean <span class="token operator">=</span> instanceWrapper<span class="token punctuation">.</span><span class="token function">getWrappedInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// bean 的class type</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> beanType <span class="token operator">=</span> instanceWrapper<span class="token punctuation">.</span><span class="token function">getWrappedClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>beanType <span class="token operator">!=</span> NullBean<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  mbd<span class="token punctuation">.</span>resolvedTargetType <span class="token operator">=</span> beanType<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 单例+允许循环引用+当前bean正在创建。就需要将bean包装后放入三级缓存中</span><span class="token keyword">boolean</span> earlySingletonExposure <span class="token operator">=</span> <span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">isSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>allowCircularReferences <span class="token operator">&amp;&amp;</span>    <span class="token function">isSingletonCurrentlyInCreation</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>earlySingletonExposure<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 将已实例化但还未填充属性的bean放入三级缓存，供其他依赖此bean的bean使用</span>  <span class="token function">addSingletonFactory</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token function">getEarlyBeanReference</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> bean<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//  准备初始化bean</span>Object exposedObject <span class="token operator">=</span> bean<span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 填充bean的字段（依赖的字段bean）</span>  <span class="token function">populateBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> instanceWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// bean完全填充好属性后，开始调用各种初始化方法和BeanPostProcessor接口</span>  exposedObject <span class="token operator">=</span> <span class="token function">initializeBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> exposedObject<span class="token punctuation">,</span> mbd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment" spellcheck="true">// 省略异常</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment" spellcheck="true">// 注册destroy相关方法</span><span class="token function">registerDisposableBeanIfNecessary</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> bean<span class="token punctuation">,</span> mbd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> exposedObject<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="AbstractAutowireCapableBeanFactory-populateBean"><a href="#AbstractAutowireCapableBeanFactory-populateBean" class="headerlink" title="AbstractAutowireCapableBeanFactory#populateBean"></a>AbstractAutowireCapableBeanFactory#populateBean</h4><p>填充bean的字段</p><pre class="line-numbers language-java"><code class="language-java">PropertyValues pvs <span class="token operator">=</span> <span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">hasPropertyValues</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> mbd<span class="token punctuation">.</span><span class="token function">getPropertyValues</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 根据autowireMode来判断注入方式</span><span class="token comment" spellcheck="true">// 1. xml显示配置的autowire</span><span class="token comment" spellcheck="true">// 2. 配置了@Bean注解的autowire字段（这个字段默认不会走下面的代码注入）</span><span class="token keyword">int</span> resolvedAutowireMode <span class="token operator">=</span> mbd<span class="token punctuation">.</span><span class="token function">getResolvedAutowireMode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>resolvedAutowireMode <span class="token operator">==</span> AUTOWIRE_BY_NAME <span class="token operator">||</span> resolvedAutowireMode <span class="token operator">==</span> AUTOWIRE_BY_TYPE<span class="token punctuation">)</span> <span class="token punctuation">{</span>  MutablePropertyValues newPvs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MutablePropertyValues</span><span class="token punctuation">(</span>pvs<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Add property values based on autowire by name if applicable.</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>resolvedAutowireMode <span class="token operator">==</span> AUTOWIRE_BY_NAME<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">autowireByName</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> bw<span class="token punctuation">,</span> newPvs<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Add property values based on autowire by type if applicable.</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>resolvedAutowireMode <span class="token operator">==</span> AUTOWIRE_BY_TYPE<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">autowireByType</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> bw<span class="token punctuation">,</span> newPvs<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  pvs <span class="token operator">=</span> newPvs<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// ==================== 以下就是@Autowired和@Resource注入方式的处理</span><span class="token comment" spellcheck="true">// 是否存在InstantiationAwareBeanPostProcessor处理器（主要是注解解析PostProcessor）</span><span class="token keyword">boolean</span> hasInstAwareBpps <span class="token operator">=</span> <span class="token function">hasInstantiationAwareBeanPostProcessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">boolean</span> needsDepCheck <span class="token operator">=</span> <span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">getDependencyCheck</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> AbstractBeanDefinition<span class="token punctuation">.</span>DEPENDENCY_CHECK_NONE<span class="token punctuation">)</span><span class="token punctuation">;</span>PropertyDescriptor<span class="token punctuation">[</span><span class="token punctuation">]</span> filteredPds <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>hasInstAwareBpps<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>pvs <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>    pvs <span class="token operator">=</span> mbd<span class="token punctuation">.</span><span class="token function">getPropertyValues</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 获取InstantiationAwareBeanPostProcessor处理器，并调用其postProcessProperties方法</span>  <span class="token comment" spellcheck="true">// 基于注解的依赖注入会用到</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span>BeanPostProcessor bp <span class="token operator">:</span> <span class="token function">getBeanPostProcessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>bp <span class="token keyword">instanceof</span> <span class="token class-name">InstantiationAwareBeanPostProcessor</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      InstantiationAwareBeanPostProcessor ibp <span class="token operator">=</span> <span class="token punctuation">(</span>InstantiationAwareBeanPostProcessor<span class="token punctuation">)</span> bp<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 注解相关的自动注入</span>      PropertyValues pvsToUse <span class="token operator">=</span> ibp<span class="token punctuation">.</span><span class="token function">postProcessProperties</span><span class="token punctuation">(</span>pvs<span class="token punctuation">,</span> bw<span class="token punctuation">.</span><span class="token function">getWrappedInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>      pvs <span class="token operator">=</span> pvsToUse<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="AbstractAutowireCapableBeanFactory-initializeBean"><a href="#AbstractAutowireCapableBeanFactory-initializeBean" class="headerlink" title="AbstractAutowireCapableBeanFactory#initializeBean"></a>AbstractAutowireCapableBeanFactory#initializeBean</h4><p>初始化bean</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 三种aware(BeanName，BeanClassLoader，BeanFactory)</span><span class="token function">invokeAwareMethods</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> bean<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 名叫wrappedBean，表示这些方法返回的bean可能是被包装后的，比如aop相关</span>Object wrappedBean <span class="token operator">=</span> bean<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>mbd <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token operator">!</span>mbd<span class="token punctuation">.</span><span class="token function">isSynthetic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// BeanPostProcessor接口实例回调（在bean的初始化方法调用之前调用）</span>  <span class="token comment" spellcheck="true">// 例如：@PostConstruct注解的实现</span>  wrappedBean <span class="token operator">=</span> <span class="token function">applyBeanPostProcessorsBeforeInitialization</span><span class="token punctuation">(</span>wrappedBean<span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// InitializingBean方法和init-method方法</span><span class="token function">invokeInitMethods</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> wrappedBean<span class="token punctuation">,</span> mbd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>mbd <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token operator">!</span>mbd<span class="token punctuation">.</span><span class="token function">isSynthetic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// BeanPostProcessor#postProcessAfterInitialization接口实例回调。</span>  <span class="token comment" spellcheck="true">// 在bean的初始化方法调用完成之后调用，说明bean以及初始化完毕，可以实现其他扩展功能了</span>  <span class="token comment" spellcheck="true">//比如AOP的实现、 @Scheduled注解实现等</span>  wrappedBean <span class="token operator">=</span> <span class="token function">applyBeanPostProcessorsAfterInitialization</span><span class="token punctuation">(</span>wrappedBean<span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> wrappedBean<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三级缓存"><a href="#三级缓存" class="headerlink" title="三级缓存"></a>三级缓存</h2><ul><li>一级缓存（<strong>DefaultSingletonBeanRegistry#singletonObjects</strong>）：存放的是完全初始化好的bean，包括已实例化、填充内部依赖的bean，运行完初始化方法（@PostConstruct、afterPropertiesSet方法、指定的init-method方法）</li><li>二级缓存（<strong>DefaultSingletonBeanRegistry#earlySingletonObjects</strong>）：存放bean缓存（如果能被AOP，就是AOP对象），但还未填充属性和允许初始化方法</li><li>三级缓存（<strong>DefaultSingletonBeanRegistry#singletonFactories</strong>）：存放bean的ObjectFactory工厂对象，使用这个工厂对象，可提前暴露出bean的引用（专用来提前暴露AOP对象的方法）</li></ul><h3 id="为什么要使用三级缓存"><a href="#为什么要使用三级缓存" class="headerlink" title="为什么要使用三级缓存"></a><strong>为什么要使用三级缓存</strong></h3><p>​<strong>三级缓存专门来解决AOP对象的暴露问题</strong>。</p><p>​如果没用AOP是可以只用一级缓存和二级缓存就解决的。但如果使用了AOP且没有三级缓存，那么必须在实例化后就马上完成AOP代理，但这和spring的设计初衷不同，AOP代理的完成时使用了bean的后置处理器<strong>AnnotationAwareAspectJAutoProxyCreator</strong>来完成的，也就是在初始化bean后执行的bean后置处理器方法（<strong>AbstractAutowireCapableBeanFactory#initializeBean</strong>），就不可能再实例化bean后进行代理，所以才有了三级缓存，仅用来提前暴露AOP对象</p><h3 id="三层级缓存真能完美解决吗？"><a href="#三层级缓存真能完美解决吗？" class="headerlink" title="三层级缓存真能完美解决吗？"></a>三层级缓存真能完美解决吗？</h3><p>如果有3个bean分别为A、B、C，A依赖B和C，B只依赖A，C什么都不依赖，但提供一个方法sayHello使用。</p><p>​当开始实例化A时，实例化A后将其工厂对象放入三级缓存中，开始填充A属性，发现了B需要填充，开始实例化B，实例化B对象过程中又需要填充其属性A，这时能从三级缓存中取出了A的引用（但此时A不完整），如果B对象有一个初始化方法（@PostConstruct），调用A对象里的C对象的sayHello方法，但由于A此时只是个空壳，就会抛出空指针异常。</p><p>​总的来说，就是在循环引用期间的调用初始化方法时，调用了尚未完全创建好的bean（空壳bean）的某个字段的方法，导致抛出NPE，导致服务启动失败</p><h2 id="关键流程总结"><a href="#关键流程总结" class="headerlink" title="关键流程总结"></a>关键流程总结</h2><ol><li>实例化bean：创建bean的空壳对象</li><li>将其工厂对象（ObjectFactory）放入三级缓存（根据<strong>AbstractAutowireCapableBeanFactory#allowCircularReferences</strong>字段决定）</li><li>填充依赖bean（<strong>AbstractAutowireCapableBeanFactory#populateBean</strong>）：进行@Autowired和@Resource等注解的字段注入。如果这些依赖的 Bean 还没创建，会触发递归创建</li><li>初始化bean（<strong>AbstractAutowireCapableBeanFactory#initializeBean</strong>）<ul><li>4.1 调用<strong>BeanPostProcessor#postProcessBeforeInitialization方法</strong>（初始化前的hook）</li><li>4.2 调用各种初始化方法（**@PostConstruct、afterPropertiesSet方法、指定的init-method方法**）</li><li>4.3 调用<strong>BeanPostProcessor#postProcessAfterInitialization</strong>（初始化后的hook，<strong>AOP相关实现</strong>）</li></ul></li><li>注册destory相关方法（<strong>AbstractBeanFactory#registerDisposableBeanIfNecessary</strong>）</li><li>完成创建，放入一级缓存。同时移除三级缓存和二级缓存中的相关对象</li></ol>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM参数</title>
      <link href="/2020/12/18/jvm-can-shu/"/>
      <url>/2020/12/18/jvm-can-shu/</url>
      
        <content type="html"><![CDATA[<p>JVM常用参数整理和垃圾收集器组合</p> <span id="more"></span><h1 id="JVM参数和垃圾收集器组合"><a href="#JVM参数和垃圾收集器组合" class="headerlink" title="JVM参数和垃圾收集器组合"></a>JVM参数和垃圾收集器组合</h1><h2 id="jvm参数整理"><a href="#jvm参数整理" class="headerlink" title="jvm参数整理"></a>jvm参数整理</h2><ul><li><strong>-Xms64m</strong> ：初始堆大小</li><li><strong>-Xmx128m</strong> ：最大堆大小</li><li><strong>-Xmn32m</strong> ：年轻代大小</li><li><strong>-XX:MaxNewSize&#x3D;256m</strong> : 最大新生代大小</li><li><strong>-Xss512k</strong>：栈大小</li><li><strong>-XX:MetaspaceSize&#x3D;256M</strong> ：Metaspace扩容时触发FullGC的初始化阈值(并不是元空间的初始化大小，元空间是不断扩容的，当达到这个值时，就会触发full gc，<a href="https://www.jianshu.com/p/b448c21d2e71">链接</a>）</li><li><strong>-XX:MaxMetaspaceSize&#x3D;512M</strong>：Metaspace最大大小</li><li><strong>-XX:NewRatio&#x3D;2</strong>：老年代和新生代的比例</li><li><strong>-XX:SurvivorRatio&#x3D;8</strong> ：Eden区与一个Survivor区的大小比值（所以<strong>s0:s1:eden&#x3D;1:1:8</strong>）</li><li><strong>-XX:MinHeapFreeRatio&#x3D;40</strong>：空闲堆空间的最小百分比。如果空闲堆空间的比例小于它，则会进行堆扩容</li><li><strong>-XX:MaxHeapFreeRatio&#x3D;70</strong>：空闲堆空间的最大百分比。如果空闲堆空间的比例大于它，则会进行堆缩容</li><li><strong>-XX:-DisableExplicitGC</strong>：禁止显式GC，即禁止程序中System.gc()。个人感觉没必要</li><li><strong>-XX:+HeapDumpOnOutOfMemoryError</strong>：OOM时导出堆快照到文件</li><li><strong>-XX:HeapDumpPath&#x3D;&#x2F;home&#x2F;huskie&#x2F;gc&#x2F;oom.hprof</strong>：OOM时导出文件路径</li><li><strong>-Xloggc:</strong>&#x2F;home&#x2F;ruidong&#x2F;gc.log   存储gc日志的路径</li><li><strong>-XX:OnOutOfMemoryError</strong>：OOM时操作，比如如执行脚本发送邮件</li><li><strong>-XX:+TraceClassLoading</strong>：打印加载类的详细信息</li><li><strong>-XX:+PrintGCDetails</strong>：打印GC详细信息</li><li><strong>-XX:+PrintGCTimeStamps</strong>：打印CG发生的时间戳（相对于项目启动时间）</li><li><strong>-XX:+PrintGCDateStamps</strong>：打印GC发生的时间</li><li><strong>-XX:+PrintHeapAtGC</strong>：每一次GC前和GC后，都打印堆信息</li><li><strong>-XX:+PrintClassHistogram</strong>：按下Ctrl+Break后，打印类的信息</li><li><strong>-XX:+PrintGCApplicationConcurrentTime</strong> ：打印应用程序的运行时间（许多事情会导致JVM暂停所有线程，停在安全点。gc也只是其中的一种，当暂停之后在重启应用线程，则会刷新这个时间（归0），在重新计数）<a href="http://ifeve.com/logging-stop-the-world-pauses-in-jvm/">链接</a></li><li><strong>-XX:+PrintGCApplicationStoppedTime</strong> ：打印应用线程暂停的时间，显示应用线程被暂停了多久和应用线程暂停到安全点花费的时间</li><li><strong>-XX:TargetSurvivorRatio&#x3D;50</strong> ：survivor空间的晋升大小空间百分比（默认为50）</li><li><strong>-XX:MaxTenuringThreshold&#x3D;15</strong>  ：年轻代晋升到老年代的最大年龄阈值(tenuring threshold)。默认值为 15[每次GC，增加1岁，到15岁如果还要存活，放入Old区]。<strong>jvm还会动态的计算晋升阈值，方法：依次从年龄为1的对象大小加起来，一直加到大小超过了 [（TargetSurvivorRatio * survivor_capacity）&#x2F; 100 ]值，这时加起来的最大年龄大小即为这次晋升的临界阈值</strong>（具体算法在：hotspot\src\share\vm\gc_implementation\shared\ageTable.cpp文件里，方法为compute_tenuring_threshold）</li><li><strong>-XX:+PrintTenuringDistribution</strong> ：ygc 时打印当前晋升年龄信息</li></ul><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><h3 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h3><h4 id="Serial（hotspot虚拟机在客户端下的默认新生代垃圾收集器）"><a href="#Serial（hotspot虚拟机在客户端下的默认新生代垃圾收集器）" class="headerlink" title="Serial（hotspot虚拟机在客户端下的默认新生代垃圾收集器）"></a>Serial（hotspot虚拟机在客户端下的默认新生代垃圾收集器）</h4><p>单线程新生代收集器，复制算法，整个过程STW</p><p>优势：内存消耗最小</p><p>缺点：不适合大内存多处理器工作，慢</p><h4 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h4><p>多线程并行的新生代收集器，复制算法，整个过程STW</p><ul><li><strong>-XX:ParallelGCThreads&#x3D;4</strong> ：并行收集的线程数</li></ul><h4 id="Parallel-Scavenge"><a href="#Parallel-Scavenge" class="headerlink" title="Parallel Scavenge"></a>Parallel Scavenge</h4><ul><li>吞吐量 &#x3D; 运行用户代码时间 &#x2F; ( 运行用户代码时间 + 垃圾收集时间 )</li></ul><p>吞吐量优先的新生代并行多线程收集器，复制算法（<strong>标记-复制</strong>算法）</p><p>三个重要参数：</p><ul><li><strong>XX:MaxGCPauseMillis</strong> ：垃圾收集最大停顿时间，大于0的毫秒数</li><li><strong>-XX:GCTimeRatio</strong>: 大于0小于100的整数（运行用户代码时间比上垃圾回收的时间），默认为99，即允许最大1%的垃圾回收时间</li><li><strong>-XX:+UseAdaptiveSizePolicy</strong>：开启垃圾收集器的自适应调节策略。虚拟机动态调整新生代，Eden区，Survivor区的比例和晋升大小</li></ul><h3 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h3><h4 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h4><p><strong>标记-清除</strong>算法的老年代收集器</p><h4 id="Serial-Old"><a href="#Serial-Old" class="headerlink" title="Serial Old"></a>Serial Old</h4><p>Serial的老年代会收集，<strong>标记-整理</strong>算法</p><h4 id="Parallel-Scavenge-Old"><a href="#Parallel-Scavenge-Old" class="headerlink" title="Parallel Scavenge Old"></a>Parallel Scavenge Old</h4><p>Parallel Scavenge收集器的老年代版本，标记-整理算法</p><h3 id="整堆"><a href="#整堆" class="headerlink" title="整堆"></a>整堆</h3><h4 id="G1（garbage-frist收集器）"><a href="#G1（garbage-frist收集器）" class="headerlink" title="G1（garbage-frist收集器）"></a>G1（garbage-frist收集器）</h4><h2 id="垃圾收集器组合"><a href="#垃圾收集器组合" class="headerlink" title="垃圾收集器组合"></a>垃圾收集器组合</h2><ul><li>Serial + SerialOld</li><li>Serial + CMS (jdk8声明废弃，jdk9已被取消)</li><li>ParNew +CMS （使用CMS收集器的默认组合)</li><li>ParNew + SerialOld (jdk8声明废弃，jdk9已被取消)</li><li>Parallel Scavenge +  SerialOld</li><li>Parallel Scavenge + Parallel Scavenge Old（jdk8的默认组合）G1（jdk9的默认收集器，且CMS被标记为废弃了）</li></ul><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><ul><li><strong>java -XX:+PrintFlagsFinal -version</strong>  ：查看jvm默认参数。数据太多可配合grep使用</li></ul><h2 id="GCRoots对象"><a href="#GCRoots对象" class="headerlink" title="GCRoots对象"></a>GCRoots对象</h2><ul><li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li><li>本地方法栈(Native 方法)中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>所有被同步锁持有的对象</li></ul>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM参数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>G1</title>
      <link href="/2020/11/25/g1/"/>
      <url>/2020/11/25/g1/</url>
      
        <content type="html"><![CDATA[<hr><p>​简单总结了G1和其常用参数，并分析了的G1日志</p><span id="more"></span><h1 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h1><p>​G1（Garbage First）是 JDK 7 引入，并在 JDK 9 默认启用的服务端垃圾回收器。它的核心理念是将整个 Java 堆划分为多个大小相等的 <strong>Region</strong>，打破了传统“新生代 &#x2F; 老年代”的物理分区模式，转而以 Region 为基本单位进行垃圾管理与回收。</p><ul><li><strong>整堆收集</strong>：G1 是一个真正的 <strong>整堆并行压缩收集器</strong>，新生代和老年代都可以并行回收。</li><li><strong>并发标记</strong>：采用 <strong>三色标记法 + SATB + 写屏障机制</strong>，保证并发标记期间的准确性。</li><li><strong>可预测的停顿时间</strong>：用户可设置 <code>-XX:MaxGCPauseMillis</code> 控制最大停顿时间，G1 会在这个目标下选择哪些 Region 进入回收集（CSet）。</li></ul><h2 id="常用参数设置"><a href="#常用参数设置" class="headerlink" title="常用参数设置"></a>常用参数设置</h2><ul><li><strong>-XX:+UseG1GC</strong></li><li><strong>-XX:G1HeapRegionSize&#x3D;2M</strong>：一个Region的大小</li><li><strong>-XX:MaxGCPauseMillis&#x3D;80</strong>：允许收集停顿的最大时常（毫秒）</li><li><strong>-XX:InitiatingHeapOccupancyPercent&#x3D;45</strong> ：老年代占用到 45% 时触发并发标记周期（默认45）</li><li><strong>不要再设置-xmn和-XX:NewRatio</strong></li></ul><h2 id="Region划分"><a href="#Region划分" class="headerlink" title="Region划分"></a>Region划分</h2><ul><li>整个堆被分成多个 <strong>Region</strong>（默认 2048 个），每个 Region 的大小为 <strong>1MB ~ 32MB</strong>，并且必须是 2 的幂次方。</li><li>每个 Region 会被动态标记为不同用途：<ul><li><code>E</code>：Eden 区（新生代分配对象）</li><li><code>S</code>：Survivor 区（新生代存活对象）</li><li><code>O</code>：Old 区（长生命周期对象）</li><li><code>H</code>：Humongous 区（大对象，直接分配在老年代）</li></ul></li></ul><p>​大对象（如数组、长字符串等）若超过一个 Region 一半大小，会被当作 Humongous 对象，分配连续的多个 Region。由于这些对象移动成本高，<strong>G1 默认不会移动 Humongous 对象</strong>，而是直接将它们标记为老年代区域。</p><h2 id="Remembered-Set（RSet）"><a href="#Remembered-Set（RSet）" class="headerlink" title="Remembered Set（RSet）"></a>Remembered Set（RSet）</h2><p>​由于 G1 会独立地对某些 Region 进行回收，它必须知道<strong>老年代是否引用了某个新生代对象</strong>。这正是 <strong>Remembered Set（记忆集）</strong> 的作用：</p><ul><li>每个 Region 都维护了一个对应的 <strong>RSet</strong>，记录有哪些其它 Region 的对象引用了自己。</li><li>在回收某个 Region 时，G1 只需要扫描这个 RSet，而不必全堆扫描，大幅降低了跨代引用处理的成本。</li></ul><blockquote><p>简单说：<strong>RSet 让分区式回收变得可能而高效。</strong></p></blockquote><h2 id="Card-Table（卡表）"><a href="#Card-Table（卡表）" class="headerlink" title="Card Table（卡表）"></a>Card Table（卡表）</h2><p>RSet 的实现依赖于 <strong>Card Table + 写屏障</strong>：</p><ul><li>Java 堆被进一步划分为更小的单位：<strong>Card</strong>，默认每个 Card 是 512 字节。</li><li>JVM 在写引用字段时会触发 <strong>写屏障（Write Barrier）</strong>，将对应 Card 标记为 dirty，并记录引用变更。</li><li>在 GC 时，这些 dirty Card 会被用于更新 RSet，确保引用信息完整。</li></ul><blockquote><p>卡表是写屏障的基础，RSet 是分区引用追踪的核心，三者协同构成 G1 的并发收集体系。</p></blockquote><h2 id="日志解析"><a href="#日志解析" class="headerlink" title="日志解析"></a>日志解析</h2><pre class="line-numbers language-log"><code class="language-log">2020-11-23T11:40:46.167+0800: 1.503: [GC pause (G1 Evacuation Pause) (young), 0.0048336 secs]   // 下面的Min,Avg,Max,Diff,Sum分别表示GC线程最小启动或耗时时间（后面的也是），平均，最大，最大差值，和总耗时，单位都为ms   [Parallel Time: 3.1 ms, GC Workers: 6] // 本次YGC共6个GC线程，总耗时3.1ms      [GC Worker Start (ms): Min: 1503.0, Avg: 1504.5, Max: 1506.1, Diff: 3.0] // 本次GC线程启动（相对于JVM的启动）      [Ext Root Scanning (ms): Min: 0.0, Avg: 0.2, Max: 0.7, Diff: 0.7, Sum: 1.1] // 本次GC线程的GC Roots扫描时间      [Update RS (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0] // 更新Remember Sets 的耗时统计信息（记忆集一般使用来解决跨Region的引用）         [Processed Buffers: Min: 0, Avg: 0.0, Max: 0, Diff: 0, Sum: 0]      [Scan RS (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0] // 每个Region都会有一个RSet，RSet又包含指向这个Region的Cards引用，这个阶段就是扫描RSet中的Cards，从而分辨出Eden哪些对象被老年代引用，从而这些不会被GC      [Code Root Scanning (ms): Min: 0.0, Avg: 0.0, Max: 0.2, Diff: 0.2, Sum: 0.2] // 扫描代码中的root节点（局部变量）      [Object Copy (ms): Min: 0.0, Avg: 1.3, Max: 2.7, Diff: 2.7, Sum: 7.6] // 对象copy，将存活的对象copy到目标Region中      [Termination (ms): Min: 0.0, Avg: 0.0, Max: 0.1, Diff: 0.1, Sum: 0.3]         [Termination Attempts: Min: 1, Avg: 1.2, Max: 2, Diff: 1, Sum: 7]      [GC Worker Other (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.2] // GC线程完成其他任务的时间      [GC Worker Total (ms): Min: 0.0, Avg: 1.6, Max: 3.1, Diff: 3.1, Sum: 9.4] // GC线程整个生命周期总计消耗时间      [GC Worker End (ms): Min: 1506.1, Avg: 1506.1, Max: 1506.1, Diff: 0.0] // GC线程完成任务的停止时间（相对于JVM）   [Code Root Fixup: 0.0 ms]   [Code Root Purge: 0.0 ms]   [Clear CT: 0.1 ms] // 清理Card Table（卡表）   [Other: 1.6 ms]      [Choose CSet: 0.0 ms] // 选择要回收的Region放入CSet（会根据停顿时间来决定）      [Ref Proc: 1.4 ms] // 处理引用对象耗时时间（Weak、Soft、Phantom、JNI等等）      [Ref Enq: 0.0 ms] // 遍历所有引用，将不能回收的放入pending列表      [Redirty Cards: 0.0 ms] // 重置card为dirty      // 大型对象的回收      [Humongous Register: 0.0 ms]       [Humongous Reclaim: 0.0 ms]      [Free CSet: 0.0 ms] // 释放CSet中Region占用的内存空间所耗时间   [Eden: 51.0M(51.0M)->0.0B(46.0M) Survivors: 0.0B->5120.0K Heap: 51.0M(1024.0M)->4815.7K(1024.0M)] [Times: user=0.05 sys=0.00, real=0.01 secs] <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>G1 不再物理区分年轻代和老年代，转而统一使用多个 Region 管理整个堆。</p></li><li><p>支持 <strong>并发标记 + 并发回收 + 可预测停顿</strong>，是整堆压缩收集器。</p></li><li><p>使用 <strong>Remembered Set + Card Table + 写屏障</strong> 高效维护跨代引用关系。</p></li><li><p>避免 Full GC 的目标是：通过周期性并发标记、预测性选择 CSet 来进行碎片整理。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> G1 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈谈ThreadLocal为什么被设计为弱引用</title>
      <link href="/2020/11/21/tan-tan-threadlocal-wei-shi-me-bei-she-ji-wei-ruo-yin-yong/"/>
      <url>/2020/11/21/tan-tan-threadlocal-wei-shi-me-bei-she-ji-wei-ruo-yin-yong/</url>
      
        <content type="html"><![CDATA[<hr><p>分析了ThreadLocal为什么要被设计为弱引用，并给出了ThreadLocal的建议使用方法</p><span id="more"></span><h1 id="谈谈ThreadLocal为什么被设计为弱引用"><a href="#谈谈ThreadLocal为什么被设计为弱引用" class="headerlink" title="谈谈ThreadLocal为什么被设计为弱引用"></a>谈谈ThreadLocal为什么被设计为弱引用</h1><p>​ThreadLocal在用作ThreadLocalMap的key时，是被设计为弱引用的。</p><p>​ThreadLocalMap的内部类Entry被设计为实现了WeakReference，Entry用来存放数据。在构造Entry对象时，将传进来的ThreadLocal对象包装成了真正的弱引用对象，而Entry对象和内部的value对象本身是强引用的。</p><p>弱引用的解释：</p><blockquote><p>​只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。</p></blockquote><p>​简单理解就是当垃圾回收时，该对象只被WeakReference对象的弱引用字段（T reference）所引用，而未被任何强类型的对象引用，那么，该弱引用的对象就会被回收。</p><p>​注意：WeakReference引用本身是强引用，它内部的（T reference）才是真正的弱引用字段，WeakReference就是一个装弱引用的容器而已。</p><h2 id="1-回收测试示例"><a href="#1-回收测试示例" class="headerlink" title="1 回收测试示例"></a>1 回收测试示例</h2><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocalDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        <span class="token function">firstStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread thread <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 在这里打断点，观察thread对象里的ThreadLocalMap数据</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 通过是否获取返回值观察A对象里的local对象是否被回收</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> A <span class="token function">firstStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        A a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"value: "</span><span class="token operator">+</span> a<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> a<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{</span>        <span class="token keyword">private</span> ThreadLocal<span class="token operator">&lt;</span>String<span class="token operator">></span> local <span class="token operator">=</span> ThreadLocal<span class="token punctuation">.</span><span class="token function">withInitial</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"in class A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> String <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> local<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span><span class="token punctuation">{</span>            local<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/img/soil/weakNotClear.png" alt="ThreadLocal被强引用持有，不会被回收"></p><p align="center" style="color: #888;">ThreadLocal 被强引用持有，不会被回收</p><p><img src="/img/soil/weakClear.png" alt="ThreadLocal只被弱引用持有，gc后被回收了"></p><p align="center" style="color: #888;">ThreadLocal只被弱引用持有，gc后被回收了</p><p>​如上面的代码，当构造一个A对象时，内部的local对象也构造了，之后调用get和set方法对local对象取值和设置值，当A对象不可达时，垃圾收集器就会回收A。</p><p>​现在我们假设ThreadLocalMap的Entey里的key（ThreadLocal对象）不是弱引用的，且已经调用了A的对象的get或set方法，那么垃圾收集器回收A对象时，一定不会回收里面的local对象，为什么？</p><blockquote><p>因为Entey已近持有了local对象的引用，我们没有设置引用类型，那这个引用就默认是个强引用。</p><p><strong>Thread -&gt; ThreadLocal.ThreadLocalMap -&gt; Entry[] -&gt; Enrty -&gt; key（threadLocal对象）和value</strong></p></blockquote><p>​引用链如上面所示，这<strong>个引用链全是强引用，当这个线程还未结束时，他持有的强引用，包括递归下去的所有强引用都不会被垃圾回收器回收</strong>。</p><p>​那么回到正常情况，ThreadLocalMap里Entey的key是弱引用，在本例中也就是local对象在这里是弱引用，当对象A回收时，由于local对象只剩下被弱引用key所引用，所以local对象也会被回收。</p><h2 id="2-重点来了，key为什么被设计为弱引用？？"><a href="#2-重点来了，key为什么被设计为弱引用？？" class="headerlink" title="2 重点来了，key为什么被设计为弱引用？？"></a>2 重点来了，key为什么被设计为弱引用？？</h2><p>​回归本质，ThreadLocalMap是用来存放对象的，在一次线程的执行栈中，存放数据后方便我们在任意的地方取得我们想要的值而不被其他线程干扰。ThreadLocalMap本身并没有为外界提供取出和存放数据的API，我们所能获得数据的方式只有通过ThreadLocal类提供的API来间接的从ThreadLocalMap取出数据，所以，当我们用不了key（ThreadLocal对象）的API也就无法从ThreadLocalMap里取出指定的数据。</p><p>​<strong>在上面的例子中，A对象被回收了，这些get和set方法也访问不到了，也就没法从ThreadLocalMap里取出数据了。没法利用API取出数据，那这个Entry对象还有用吗？？所以最好的方法是在A对象被回收后，系统自动回收对应的Entry对象，但是让Entry对象或其中的value对象做为弱引用都是非常不合理的（这两个要是使用弱引用，都可能造成数据意外丢失）。所以，让key（threadLocal对象）为弱引用，自动被垃圾回收，key就变为null了，下次，我们就可以通过Entry不为null，而key为null来判断该Entry对象该被清理掉了。</strong></p><p>​至于ThreadLocalMap为什么不给外界提供API来操作数据，我觉得是因为这个Map对于一个线程只有一份，任何地方都在用，为了<strong>提供更方便的API</strong>和<strong>为了我们不破换其他框架保存到里面的数据（数据不被污染</strong>），所以才用ThreadLocal作为key和API来操作数据。</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><p>​综上，Entry的key被设计为弱引用就是<strong>为了让程序自动的对访问不到的数据进行回收提醒</strong>。所以，在访问不到的数据被回收之前，内存泄漏确实是存在的，但是我们不用担心，就算我们不调用remove，ThreadLocalMap在内部的set，get和扩容时都会清理掉泄漏的Entry，内存泄漏完全没必要过于担心</p><p>所以，<strong>ThreadLocal的建议使用方法</strong>：</p><ul><li><p>设计为static的，被class对象给强引用，线程存活期间就不会被回收，也不用remove，完全不用担心内存泄漏</p></li><li><p>非static的，放置在长对象（比如被spring管理的对象）的内部，也不会被回收</p></li></ul><p>​个人也觉得没必要让创建的ThreadLocal对象生命周期过短，ThreadLocal被设计出来本身就是用来跨方法栈获取当前线程的数据或者无锁的获取线程安全的数据，空间交换了线程安全的上锁时间。只要让ThreadLocal具有线程的生命周期，就完全没必要使用remove方法，也完全不用担心内存泄漏的问题。</p><p>​另外说一点，HashMap是使用拉链法解决hash冲突的，ThreadLocalMap是使用线性探测解决hash冲突的（内部只维护Entey数组，没有链表）。所以，源码中在清除泄漏的Entry时，会进行rehash，防止数组的当前位置为null后，有hash冲突的Entry访问不到的问题。</p>]]></content>
      
      
      <categories>
          
          <category> jdk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ThreadLocal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMS</title>
      <link href="/2020/09/19/cms/"/>
      <url>/2020/09/19/cms/</url>
      
        <content type="html"><![CDATA[<hr><p>​主要分析了CMS收集器的算法实现和收集流程，和部分关键参数对CMS的影响，以及三色标记如何解决对象漏标问题。并在最后总结了CMS的优缺点</p><span id="more"></span><h1 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h1><p>​CMS（Concurrent Mark-Sweep）是一种基于<strong>标记-清除算法</strong>实现的老年代垃圾回收器，<strong>以获取最短停顿时间为目标</strong>，适合对响应时间敏感的应用（如 Web 系统）。其核心思想是尽可能地让 GC 工作与用户线程并发执行，降低停顿时间。</p><p>​一次CMS gc会算作两次full gc，分别为初始标记和最终标记（算上的时STW次数），但在多次收集后产生的空间碎片如果影响到了对象的分配，也会才用<strong>标记-整理</strong>算法收集一次</p><p>​清除算法会产生空间碎片，如果cms区预留的空闲内存不能满足新对象的分配，那么会触发<strong>Concurrent Mode Failure</strong>，这时会冻结用户线程，临时启用<strong>Serial Old</strong>收集器重新回收老年代的垃圾，全程STW，耗时很长</p><ul><li>初始标记(CMS initial mark): STW，仅标记GCRoots对象的下一个可达对象，很快</li><li>并发标记(CMS concurent mark)</li><li>重新标记(CMS remark): STW，解决并发标记时”那些消失的对象“</li><li>并发清除(CMS concurrent sweep)</li></ul><h2 id="1-参数"><a href="#1-参数" class="headerlink" title="1.参数"></a>1.参数</h2><ul><li><p><strong>-XX:+UseConcMarkSweepGC</strong>   ： 启用CMS收集器（年轻代默认使用ParNew收集器）</p></li><li><p><strong>–XX:CMSWaitDuration&#x3D;2000</strong> ： cms后台线程的轮询间隔时间（ms单位)</p></li><li><p><strong>-XX:+UseCMSInitiatingOccupancyOnly</strong> : 使用基于设定的阈值进行CMS gc，值为CMSInitiatingOccupancyFraction</p></li><li><p><strong>-XX:CMSInitiatingOccupancyFraction&#x3D;80</strong> : 在UseCMSInitiatingOccupancyOnly参数启用后生效。当CMS区（老年代）占比达到80%后，启用CMS垃圾回收。默认为-1，代表不启用，则老年代垃圾回收阈值算法为：**( (100 - MinHeapFreeRatio) + (CMSTriggerRatio * MinHeapFreeRatio) &#x2F; 100.0) &#x2F; 100.0** &#x3D; 92%</p></li><li><p><strong>-XX:ConcGCThreads&#x3D;2</strong> ：并发gc线程数，默认为（ParallelGCThreads+3）&#x2F; 4。ParallelGCThreads为新生代并行GC线程数，当CPU数量小于8时，ParallelGCThreads的值就是CPU的数量，当CPU数量大于8时，ParallelGCThreads的值等于3+5*cpuCount &#x2F; 8 （可用jstack查看）</p></li></ul><h2 id="2-三色标记"><a href="#2-三色标记" class="headerlink" title="2 三色标记"></a>2 三色标记</h2><h3 id="2-1-含义"><a href="#2-1-含义" class="headerlink" title="2.1 含义"></a>2.1 含义</h3><table><thead><tr><th>颜色</th><th>含义</th></tr></thead><tbody><tr><td><strong>白色</strong></td><td>尚未被标记的对象，<strong>可能是垃圾</strong></td></tr><tr><td><strong>灰色</strong></td><td>被标记为可达，但<strong>其内部引用的对象还没有全部扫描完</strong></td></tr><tr><td><strong>黑色</strong></td><td>可达，且其所有引用的对象也都已经被标记（扫描完）</td></tr></tbody></table><p>​在三色标记开始时，<strong>所有对象初始状态都是白色</strong>。GC 从 GCRoots 出发，只能扫描到 GCRoots 可达的对象。<strong>每当扫描到一个新对象时，它会先被标记为灰色</strong>（表示已经被发现但尚未处理完）。<strong>当该对象的所有引用对象也都被扫描并标记后，它就会被染为黑色</strong>（表示处理完毕，不可回收）。</p><p>而对于那些<strong>不可达的对象</strong>，由于没有任何路径从 GCRoots 可以触达它们，因此它们<strong>不会被扫描</strong>，颜色保持为白色，最终被识别为垃圾对象。</p><p>因此，在三色标记结束时，只会存在<strong>黑色和白色两类对象</strong>：</p><ul><li><strong>黑色对象</strong>：可达、已完全处理，<strong>不能被回收</strong></li><li><strong>白色对象</strong>：不可达、未被处理，<strong>将被回收</strong></li></ul><h3 id="2-2-问题"><a href="#2-2-问题" class="headerlink" title="2.2 问题"></a>2.2 问题</h3><ul><li>浮动垃圾：被标记为黑色的对象还会继续存活。但如果我们的用户线程此时对黑色对象丢弃引用，这个黑色对象就不可达了，就应该在本次垃圾清理中被回收。但这个影响不大，下次GC可进行处理</li><li><strong>对象漏标</strong>：<strong>在并发标记阶段，应用线程可能会修改对象引用关系，导致本应可达的对象未被正确扫描，仍然保持白色，最终被误回收。</strong>有如下两种情况<ul><li>对黑色对象A（此时A已完全扫描完毕）内部赋值一个白色对象B。B产生了漏标</li><li>对灰色对象C（此时C内部还未扫描完）内部暂时断开了一个对象D使其变为白色，并在扫描完成后重新将D赋值到C中</li></ul></li></ul><h3 id="2-3-增量更新（Incremental-Update）"><a href="#2-3-增量更新（Incremental-Update）" class="headerlink" title="2.3 增量更新（Incremental Update）"></a>2.3 增量更新（Incremental Update）</h3><p>顾名思义，表示增加了引用。增量更新关注的是<strong>引用新增</strong>的情况，尤其是解决以下对象漏标场景：</p><blockquote><p>黑色对象 A 在并发标记后，新增引用了一个未被标记的白色对象 B。</p></blockquote><p>在这种情况下，为了避免漏标，<strong>写屏障机制会将 A 重新标记为灰色</strong>，使其在“重新标记（Remark）”阶段重新被扫描一次，从而发现并标记 B，确保其不会被错误回收。<strong>总结就是黑色对象A一旦新插入了白色对象B的引用之后，A就变回灰色对象了</strong>。</p><p>​<strong>CMS 使用增量更新策略</strong>，因为它是老年代回收器，老年代中的对象多数是长寿命的，结构稳定，<strong>引用新增比引用删除更常见</strong>。但增量更新<strong>只能处理“新增引用”，无法处理“引用删除”导致的漏标，因此并不完美</strong>。这也是 CMS 在 JDK9 被标记为过时的重要原因之一。</p><h3 id="2-4-原始快照（Snapshot-At-The-Beginning，SATB）"><a href="#2-4-原始快照（Snapshot-At-The-Beginning，SATB）" class="headerlink" title="2.4 原始快照（Snapshot-At-The-Beginning，SATB）"></a>2.4 原始快照（Snapshot-At-The-Beginning，SATB）</h3><p>​<strong>保存一份并发标记开始时的引用快照</strong>，当后续并发标记过程中对这些引用删除时，都会被记录到SATB缓冲区，标记结束后SATB缓冲区的对象被重新标记为存活。</p><p>​<strong>原始快照只处理对灰色对象C删除白色对象D的情况（将D记录到SATB缓冲区），重新标记阶段会在将D标为活跃。但不处理黑色新增引用，需要依赖其他机制保证（一般都是依赖写屏障，将B直接标为存活）</strong></p><p>​<strong>G1使用原始快照能完全避免对象漏标</strong>，因为它就是用写屏障直接标记白色对象为存活的方式来处理给黑色对象新增的白色对象这种漏标情况。即<strong>SATB处理删除，写屏障兜底新增</strong>。虽不可避免的会增加浮动垃圾，但肯定不会漏标</p><h2 id="3-cms-gc触发条件"><a href="#3-cms-gc触发条件" class="headerlink" title="3 cms gc触发条件"></a>3 cms gc触发条件</h2><ul><li><a href="https://heapdump.cn/article/190389">原文</a></li><li>foreground collector  ：空间分配不够触发</li><li>background collector<ul><li>显式调用 <code>System.gc()</code>，且配置了 <code>-XX:+ExplicitGCInvokesConcurrent</code></li><li>未配置 <code>UseCMSInitiatingOccupancyOnly</code> 时，JVM 会根据运行统计数据动态判断</li><li>OldGen 达到某个使用阈值（静态或动态计算）</li><li>Young GC <strong>失败或预计失败</strong>，JVM 触发 CMS 作为<strong>悲观策略</strong></li><li>元空间（Metaspace）扩容触发，且 <code>CMSClassUnloadingEnabled=true</code>（默认开启）</li></ul></li></ul><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><ul><li>CMS 是一种低停顿老年代收集器，适合延迟敏感型系统。</li><li>优点是并发执行、停顿低，缺点如下<ul><li>空间碎片严重</li><li>需要预留足够空间，否则触发Concurrent Mode Failure 会退化为Serial GC，非常耗时</li><li><strong>只用了增量更新，没有完全解决漏标</strong></li><li>会产生浮动垃圾</li></ul></li><li>推荐配合 <code>CMSInitiatingOccupancyFraction</code> 与 <code>UseCMSInitiatingOccupancyOnly</code> 控制触发阈值，防止内存不足时被动触发 Full GC。</li></ul>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMS </tag>
            
            <tag> 三色标记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java源码篇-线程池</title>
      <link href="/2020/05/12/java-yuan-ma-pian-xian-cheng-chi/"/>
      <url>/2020/05/12/java-yuan-ma-pian-xian-cheng-chi/</url>
      
        <content type="html"><![CDATA[<p>​对jdk的ThreadPoolExecutor和ScheduledThreadPoolExecutor进行了详细的源码分析</p> <span id="more"></span><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="1-ThreadPoolExecutor"><a href="#1-ThreadPoolExecutor" class="headerlink" title="1 ThreadPoolExecutor"></a>1 ThreadPoolExecutor</h2><h3 id="1-1-重要字段"><a href="#1-1-重要字段" class="headerlink" title="1.1 重要字段"></a>1.1 重要字段</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//状态控制器，初始值： 1110 0000 0000 0000 0000 0000 0000 0000</span><span class="token keyword">private</span> <span class="token keyword">final</span> AtomicInteger ctl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token function">ctlOf</span><span class="token punctuation">(</span>RUNNING<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> COUNT_BITS <span class="token operator">=</span> Integer<span class="token punctuation">.</span>SIZE <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 29位</span><span class="token comment" spellcheck="true">// 0001 1111 1111 1111 1111 1111 1111 1111</span><span class="token comment" spellcheck="true">// 1110 0000 0000 0000 0000 0000 0000 0000 取反后</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> CAPACITY   <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>                                                            <span class="token comment" spellcheck="true">// 运行中：111 00000000000000000000000000000</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> RUNNING    <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 不再接受新任务的入队列，但已经入队列还未还未的任务还可以继续执行</span><span class="token comment" spellcheck="true">// 000 00000000000000000000000000000</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> SHUTDOWN   <span class="token operator">=</span>  <span class="token number">0</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 不接受新任务入队列，也不处理队列中的任务，中断正在处理任务的worker</span><span class="token comment" spellcheck="true">// 001 00000000000000000000000000000</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> STOP       <span class="token operator">=</span>  <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 全部完成，任务终止，worker数为0</span><span class="token comment" spellcheck="true">// 010 00000000000000000000000000000</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TIDYING    <span class="token operator">=</span>  <span class="token number">2</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 011 00000000000000000000000000000</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TERMINATED <span class="token operator">=</span>  <span class="token number">3</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 计算线程池的状态</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span>     <span class="token punctuation">{</span> <span class="token keyword">return</span> c <span class="token operator">&amp;</span> <span class="token operator">~</span>CAPACITY<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 后29位为0，前3为跟随c</span><span class="token comment" spellcheck="true">// 计算线程池有多少工作线程</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> c <span class="token operator">&amp;</span> CAPACITY<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 前3位为0，后面29为跟随 c</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">ctlOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> rs<span class="token punctuation">,</span> <span class="token keyword">int</span> wc<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> rs <span class="token operator">|</span> wc<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 任务队列</span><span class="token keyword">private</span> <span class="token keyword">final</span> BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> workQueue<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 主锁</span><span class="token keyword">private</span> <span class="token keyword">final</span> ReentrantLock mainLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 工作线程的Set</span><span class="token keyword">private</span> <span class="token keyword">final</span> HashSet<span class="token operator">&lt;</span>Worker<span class="token operator">></span> workers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span>Worker<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">final</span> Condition termination <span class="token operator">=</span> mainLock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 池已经创建的线程最大数（一个动态值，线程池整个周期同时存在的最多线程数）</span><span class="token keyword">private</span> <span class="token keyword">int</span> largestPoolSize<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 完成的任务数</span><span class="token keyword">private</span> <span class="token keyword">long</span> completedTaskCount<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 创建线程的工厂</span><span class="token keyword">private</span> <span class="token keyword">volatile</span> ThreadFactory threadFactory<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 拒绝策略</span><span class="token keyword">private</span> <span class="token keyword">volatile</span> RejectedExecutionHandler handler<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 非核心线程数的保持时间</span><span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 是否允许核心线程过期</span><span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> allowCoreThreadTimeOut<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 核心线程数</span><span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> corePoolSize<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 最大线程数</span><span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p> ​ThreadPoolExecutor利用一个int类型的数来同时保存当前线程池状态和工作线程的数量，高3为用来表示当前线程的状态，低29为用来保存工作线程的数量。通过位运算实现状态和数量的原子性操作，避免单独维护两个变量时的竞态条件</p><p>​ThreadPoolExecutor内部的Worker就是工作线程的抽象，每一个Worker都是一个工作线程。同时，Worker又继承了AQS可以充当锁的角色，目的是更好的<strong>让外部知道当前worker是否正在运行，以帮助回收或中断Worker</strong>。worker运行时（获取到任务后开始运行）会加锁，通过测试当前worker是否加上锁或者是否可以获得当前worker的锁，便可知道worker是否繁忙，有助于worker的清理</p></blockquote><h3 id="1-2-核心方法"><a href="#1-2-核心方法" class="headerlink" title="1.2 核心方法"></a>1.2 核心方法</h3><h4 id="1-2-1-shutdown（平滑关闭）"><a href="#1-2-1-shutdown（平滑关闭）" class="headerlink" title="1.2.1 shutdown（平滑关闭）"></a>1.2.1 shutdown（平滑关闭）</h4><p>​将当前线程池状态设为SHUTDOWN状态，再中断空闲的Worker（判断Worker是否空闲就通过它的锁方法）。<strong>所以，执行了这个方法后，正在执行的任务不会被中断，且已经存在workQueue中的Runnable也可以被执行，但是不能放入新的Runnable</strong></p><h4 id="1-2-2-shutdownNow（立即关闭）"><a href="#1-2-2-shutdownNow（立即关闭）" class="headerlink" title="1.2.2 shutdownNow（立即关闭）"></a>1.2.2 shutdownNow（立即关闭）</h4><p>​将当前线程池状态设为STOP状态，将所有Worker设置为中断位，且倒出workQueue中的所有Runnable。<strong>所以，执行了这个方法后，正在运行的任务如果检测了中断位就会立即退出，如果没检测就还是会执行完，而已经存在workQueue中的Runnable将不会被执行，会将这些Runnable返回给调用者，让调用者处理</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 平滑关闭线程池： * 1. 将线程池状态设为SHUTDOWN，此时： *    - 继续执行已提交的任务（包括正在执行的和队列中的） *    - 拒绝新任务提交（execute()会抛出RejectedExecutionException） * 2. 仅中断空闲Worker（通过tryLock()判断） *  * 注意：正在执行的任务不会被中断，调用者需确保任务有合理的终止逻辑 */</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> ReentrantLock mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>    mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token function">checkShutdownAccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 检查每个worker线程是否可以修改</span>        <span class="token function">advanceRunState</span><span class="token punctuation">(</span>SHUTDOWN<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// CAS操作更新状态为SHUTDOWN</span>        <span class="token function">interruptIdleWorkers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// interrupt所有空闲的worker</span>    <span class="token function">onShutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// hook for ScheduledThreadPoolExecutor</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">tryTerminate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 立即关闭线程池： * 1. 将线程池状态设为STOP，此时： *    - 中断所有Worker（无论是否在执行任务） *    - 丢弃队列中未执行的任务 *    - 拒绝新任务提交 * 2. 返回被丢弃的任务列表供调用者处理 *  * 注意： * - 正在执行的任务是否停止取决于任务是否响应中断 * - 典型使用场景：需要快速释放资源的紧急关闭 */</span><span class="token keyword">public</span> List<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> <span class="token function">shutdownNow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> tasks<span class="token punctuation">;</span>    <span class="token keyword">final</span> ReentrantLock mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>    mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token function">checkShutdownAccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">advanceRunState</span><span class="token punctuation">(</span>STOP<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 设置当前线程池状态为STOP</span>        <span class="token function">interruptWorkers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// interrupt所有Worker</span>        tasks <span class="token operator">=</span> <span class="token function">drainQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将任务队列中的task全部丢弃给方法调用者</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">tryTerminate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> tasks<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 尝试终止线程池的最终状态转换： * 1. 检查是否满足终止条件（3种直接返回的情况）： *    - RUNNING状态：还有任务在执行 *    - 已经是TIDYING/TERMINATED状态：避免重复操作 *    - SHUTDOWN状态但队列不空：等待任务处理完成 * 2. 如果仍有活跃Worker，尝试中断单个空闲Worker * 3. 最终状态转换： *    SHUTDOWN/STOP -> TIDYING -> TERMINATED */</span><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">tryTerminate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 三种情况下直接退出</span>        <span class="token comment" spellcheck="true">// 1.线程池处于Running状态，还在运行</span>        <span class="token comment" spellcheck="true">// 2.线程池状态大于TIDYING，代表当前线程池已经终结</span>        <span class="token comment" spellcheck="true">// 3.shutdown状态，并且任务队列不为空，代表需等待这些任务完成</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isRunning</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">||</span>            <span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> TIDYING<span class="token punctuation">)</span> <span class="token operator">||</span>            <span class="token punctuation">(</span><span class="token function">runStateOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">==</span> SHUTDOWN <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// Eligible to terminate</span>            <span class="token function">interruptIdleWorkers</span><span class="token punctuation">(</span>ONLY_ONE<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">final</span> ReentrantLock mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>        mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> <span class="token function">ctlOf</span><span class="token punctuation">(</span>TIDYING<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token function">terminated</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// hook方法</span>                <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                    ctl<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token function">ctlOf</span><span class="token punctuation">(</span>TERMINATED<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    termination<span class="token punctuation">.</span><span class="token function">signalAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// else retry on failed CAS</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-2-3-execute（投递任务）"><a href="#1-2-3-execute（投递任务）" class="headerlink" title="1.2.3 execute（投递任务）"></a>1.2.3 execute（投递任务）</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 执行execute的方法</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span>Runnable command<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>command <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取当前线程池状态</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 判断是否小于核心线程数，是则新建线程运行任务</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&lt;</span> corePoolSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 核心数满了，并且当前线程池状态为Running，加到等待队列中</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isRunning</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> workQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> recheck <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> <span class="token function">isRunning</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">remove</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token function">addWorker</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 等待队列满了，新建线程，但不能大于最大线程数</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 创建失败，直接调用拒绝策略</span>        <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-2-4-worker的运行和阻塞"><a href="#1-2-4-worker的运行和阻塞" class="headerlink" title="1.2.4 worker的运行和阻塞"></a>1.2.4 worker的运行和阻塞</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// Worker的Runnable方法</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">runWorker</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">runWorker</span><span class="token punctuation">(</span>Worker w<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Thread wt <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Runnable task <span class="token operator">=</span> w<span class="token punctuation">.</span>firstTask<span class="token punctuation">;</span>    w<span class="token punctuation">.</span>firstTask <span class="token operator">=</span> null<span class="token punctuation">;</span>    w<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// allow interrupts</span>    <span class="token keyword">boolean</span> completedAbruptly <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 利用阻塞队列，一直循环取任务执行（阻塞队列为空时会阻塞当前想取出元素的线程）</span>        <span class="token comment" spellcheck="true">// 如果getTask为null，就代表会终结当前工作线程</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>task <span class="token operator">!=</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>task <span class="token operator">=</span> <span class="token function">getTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            w<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> STOP<span class="token punctuation">)</span> <span class="token operator">||</span>                 <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                  <span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> STOP<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                <span class="token operator">!</span>wt<span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                wt<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token function">beforeExecute</span><span class="token punctuation">(</span>wt<span class="token punctuation">,</span> task<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// hook before</span>                Throwable thrown <span class="token operator">=</span> null<span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    task<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 真正的运行Runnable</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RuntimeException</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> x<span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Error</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> x<span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                    <span class="token function">afterExecute</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> thrown<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// hook after</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                task <span class="token operator">=</span> null<span class="token punctuation">;</span>                w<span class="token punctuation">.</span>completedTasks<span class="token operator">++</span><span class="token punctuation">;</span>                w<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        completedAbruptly <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token function">processWorkerExit</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> completedAbruptly<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 核心方法之一，从阻塞队列中取任务</span><span class="token keyword">private</span> Runnable <span class="token function">getTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">boolean</span> timedOut <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Did the last poll() time out?</span>    <span class="token comment" spellcheck="true">// 死循环取任务</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Check if queue empty only if necessary.</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">>=</span> SHUTDOWN <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>rs <span class="token operator">>=</span> STOP <span class="token operator">||</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">decrementWorkerCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> wc <span class="token operator">=</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 允许核心线程过期和非核心线程都可以超时取任务</span>        <span class="token keyword">boolean</span> timed <span class="token operator">=</span> allowCoreThreadTimeOut <span class="token operator">||</span> wc <span class="token operator">></span> corePoolSize<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>wc <span class="token operator">></span> maximumPoolSize <span class="token operator">||</span> <span class="token punctuation">(</span>timed <span class="token operator">&amp;&amp;</span> timedOut<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>wc <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">||</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 原子性的尝试减少一个工作线程，减少成功才返回结束线程</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndDecrementWorkerCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span>                 <span class="token keyword">return</span> null<span class="token punctuation">;</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 如果是超时取任务，时间结束后还是取不到，则设置timedOut为true，下次循环就可以直接返回null退出了，这样，这个Worker也就终结了</span>            Runnable r <span class="token operator">=</span> timed <span class="token operator">?</span>                workQueue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span>keepAliveTime<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>NANOSECONDS<span class="token punctuation">)</span> <span class="token operator">:</span>            workQueue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 不为null才返回，就不用担心返回null而终结了当前线程</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">!=</span> null<span class="token punctuation">)</span>                <span class="token keyword">return</span> r<span class="token punctuation">;</span>            timedOut <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> retry<span class="token punctuation">)</span> <span class="token punctuation">{</span>            timedOut <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-3-总结"><a href="#1-3-总结" class="headerlink" title="1.3 总结"></a>1.3 总结</h3><p><strong>execute Runnable的流程</strong></p><ul><li>先判断线程池的工作线程数量是否小于核心线程数，小于核心线程数直接新建线程来执行</li><li>如果核心线程数满了，则将Runnable投入到workQueue中</li><li>如果workQueue满了，则创建非核心线程来继续执行任务</li><li>如果线程池中的工作现场数量到达了maximumPoolSize的值，则使用拒绝策略来执行任务</li></ul><p><strong>Worker的工作流程</strong></p><p>​调用getTask取任务来执行，如果取出的任务为空，则这个Worker也就结束了（终结了）。getTask不为空的话，还是先进性一系列的线程池状态校验，在执行hook函数（beforeExecute），在真正的执行这个Runnable，再执行hook函数（afterExecute），最后再将completedTasks加1，表示当前Worker完成的任务总数</p><p><strong>getTask流程</strong>（实现线程超时回收的关键）</p><ul><li>先进行一系列的状态校验</li><li><strong>判断是否允许超时（满足任意一个就行）</strong><ul><li><strong>allowCoreThreadTimeOut为true（都允许核心线程超时了，那没任务的情况下线程池就不该有worker线程）</strong></li><li><strong>当前线程池的工作线程数量大于核心线程数量就允许超时</strong></li></ul></li><li>判断是否触发减少工作线程数量的机制，然后使用CAS减少工作线程数量，减少成功才返回null，结束当前工作线程</li><li>通过阻塞队列取Runnable，如果不允许超时，则会一直阻塞到这。如果允许超时，则会超时等待keepAliveTime纳秒取Runnable，如果取不出来，则设置一次已经超时，再来循环一次，来判断是否该减少工作线程</li></ul><h2 id="2-ScheduledThreadPoolExecutor"><a href="#2-ScheduledThreadPoolExecutor" class="headerlink" title="2 ScheduledThreadPoolExecutor"></a>2 ScheduledThreadPoolExecutor</h2><h3 id="2-1-ScheduledExecutorService"><a href="#2-1-ScheduledExecutorService" class="headerlink" title="2.1 ScheduledExecutorService"></a>2.1 ScheduledExecutorService</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ScheduledExecutorService</span> <span class="token keyword">extends</span> <span class="token class-name">ExecutorService</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 创建一个一次性的延迟（定时）任务。     * 框架中cron表达式就是通过此接口实现（只需要在任务完成后，在计算下一次的执行时间，再用此方法定时执行，以此类推）     */</span>    <span class="token keyword">public</span> ScheduledFuture<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">schedule</span><span class="token punctuation">(</span>Runnable command<span class="token punctuation">,</span>                                       <span class="token keyword">long</span> delay<span class="token punctuation">,</span> TimeUnit unit<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**    * 执行Callable接口的任务，也是一个一次性的定时任务    */</span>    <span class="token keyword">public</span> <span class="token operator">&lt;</span>V<span class="token operator">></span> ScheduledFuture<span class="token operator">&lt;</span>V<span class="token operator">></span> <span class="token function">schedule</span><span class="token punctuation">(</span>Callable<span class="token operator">&lt;</span>V<span class="token operator">></span> callable<span class="token punctuation">,</span>                                           <span class="token keyword">long</span> delay<span class="token punctuation">,</span> TimeUnit unit<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 基于固定的频率执行定时任务      * 例：初始执行任务的时间戳：当前时间戳（调用时）+ initialDelay      * 第二次执行：初始执行任务开始时的时间戳 + period      * 第三次执行：第二次执行任务开始时的时间戳 + period     *     * 典型场景：严格周期性的任务，如：     * - 每分钟采集一次系统指标     * - 每5秒发送心跳包     */</span>    <span class="token keyword">public</span> ScheduledFuture<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">scheduleAtFixedRate</span><span class="token punctuation">(</span>Runnable command<span class="token punctuation">,</span>                                                  <span class="token keyword">long</span> initialDelay<span class="token punctuation">,</span>                                                  <span class="token keyword">long</span> period<span class="token punctuation">,</span>                                                  TimeUnit unit<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 基于固定的周期执行定时任务      * 例：初始执行任务的时间戳：当前时间戳（调用时）+ initialDelay     *  第二次执行：初始任务执行完结时的时间戳 + delay     *  第三次执行：第二次任务执行完结时的时间戳 + delay     *     * 典型场景：需要冷却时间的任务，如：     * - 数据库批量处理（保证每次处理完成后再间隔）     * - 异步结果轮询（避免密集请求）     */</span>    <span class="token keyword">public</span> ScheduledFuture<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">scheduleWithFixedDelay</span><span class="token punctuation">(</span>Runnable command<span class="token punctuation">,</span>                                                     <span class="token keyword">long</span> initialDelay<span class="token punctuation">,</span>                                                     <span class="token keyword">long</span> delay<span class="token punctuation">,</span>                                                     TimeUnit unit<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-DelayedWorkQueue"><a href="#2-2-DelayedWorkQueue" class="headerlink" title="2.2 DelayedWorkQueue"></a>2.2 DelayedWorkQueue</h3><p>​为ScheduledThreadPoolExecutor内部固定的阻塞队列，基于<strong>小顶堆</strong>数据结构实现。</p><p>​投递的每个任务被封装后都扔进DelayedWorkQueue中，<strong>按照任务被执行的时间戳进行小顶堆排序，堆顶就刚好是队列中下个需要执行的任务</strong>。同时基于<strong>Leader-Follower 模式</strong>进行线程调度的优化，只有leader进行延时等待堆首任务，其余线程直接阻塞等待</p><p>​核心字段和方法如下</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">DelayedWorkQueue</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span>        <span class="token keyword">implements</span> <span class="token class-name">BlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 数组初始容量</span>        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> INITIAL_CAPACITY <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 数组实现的最小顶堆结构，queue[0]始终都是最快需要被执行的那个任务</span>        <span class="token keyword">private</span> RunnableScheduledFuture<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> queue <span class="token operator">=</span>            <span class="token keyword">new</span> <span class="token class-name">RunnableScheduledFuture</span><span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span>INITIAL_CAPACITY<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">private</span> <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">private</span> <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// leader线程，定时等待queue[0]任务的那个线程</span>        <span class="token keyword">private</span> Thread leader <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">private</span> <span class="token keyword">final</span> Condition available <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 向堆尾新加入任务，进行上移（和父节点换个位置）调整位置</span>        <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">siftUp</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> RunnableScheduledFuture<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>k <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> parent <span class="token operator">=</span> <span class="token punctuation">(</span>k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 父节点的索引</span>                RunnableScheduledFuture<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> e <span class="token operator">=</span> queue<span class="token punctuation">[</span>parent<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 调整完毕，直接break</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 当前节点的下次执行时间更快，继续递归向上遍历，直到放到合适的位置</span>                queue<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>                <span class="token function">setIndex</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>                k <span class="token operator">=</span> parent<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            queue<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> key<span class="token punctuation">;</span>            <span class="token function">setIndex</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>              <span class="token comment" spellcheck="true">/**         * Sifts element added at top down to its heap-ordered spot.         * Call only when holding lock.&lt;p/>         * 元素下移操作（弹出堆顶元素后，将堆尾元素放置到堆顶再重新调整下移）         */</span>        <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">siftDown</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> RunnableScheduledFuture<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> half <span class="token operator">=</span> size <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>k <span class="token operator">&lt;</span> half<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 较小值节点的索引（初始为左子节点）</span>                <span class="token keyword">int</span> child <span class="token operator">=</span> <span class="token punctuation">(</span>k <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 小值，初始为左子节点</span>                RunnableScheduledFuture<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> c <span class="token operator">=</span> queue<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 右子节点索引</span>                <span class="token keyword">int</span> right <span class="token operator">=</span> child <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>right <span class="token operator">&lt;</span> size <span class="token operator">&amp;&amp;</span> c<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>queue<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 如果右子节点更小，则将c替换为右子节点，同时替换child为右子节点索引</span>                    c <span class="token operator">=</span> queue<span class="token punctuation">[</span>child <span class="token operator">=</span> right<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 目标元素比最小的子节点元素还小，目的就达成了，直接break</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 左右子节点中较小的节点和父节点交换</span>                queue<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> c<span class="token punctuation">;</span>                <span class="token function">setIndex</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 替换目标索引，继续将参数k向下比较</span>                k <span class="token operator">=</span> child<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            queue<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> key<span class="token punctuation">;</span>            <span class="token function">setIndex</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">/**          重写的offer方法（该方法就是线程池投递任务的方法）         */</span>        <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">offer</span><span class="token punctuation">(</span>Runnable x<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> null<span class="token punctuation">)</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            RunnableScheduledFuture<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> e <span class="token operator">=</span> <span class="token punctuation">(</span>RunnableScheduledFuture<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">)</span>x<span class="token punctuation">;</span>            <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>            lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> i <span class="token operator">=</span> size<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> queue<span class="token punctuation">.</span>length<span class="token punctuation">)</span>                    <span class="token function">grow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                size <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 数组中还没有任务，直接放在首位</span>                    queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>                    <span class="token function">setIndex</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 已存在定时任务，看是否需要调整位置</span>                    <span class="token function">siftUp</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                 <span class="token keyword">if</span> <span class="token punctuation">(</span>queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 代表向队列添加了一个需要最快执行的任务</span>                    <span class="token comment" spellcheck="true">// 需要重置leader线程，并唤醒一个阻塞的线程（可能为无限阻塞的，也可能为上个定时等待的leader线程）来定时等待这个任务</span>                    <span class="token comment" spellcheck="true">// 换种角度，如果唤醒的是上个定时等待的leader线程，那肯定是很赚的，因为不需要启动多个定时等待的线程了</span>                    <span class="token comment" spellcheck="true">// 如果唤醒的不是上个leader线程，那就会存在多个定时等待的线程，这是没法避免的</span>                    leader <span class="token operator">=</span> null<span class="token punctuation">;</span>                    available<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将阻塞的线程从等待队列转移到同步队列，当下面的unlock后再唤醒阻塞线程</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">/*        重写的take方法                所以，多线程多任务且没有任务需要立即执行造成的结果就是：            1、1个leader线程定时等待队首任务（实时的向线程池添加最快需要执行的任务，可能存在多个定时等待的线程，且至少他们曾经是leader线程）            2、其余全部线程无限期等待，最大程度的减少资源损耗（因为任务都有顺序，没必要同时让所有线程都定时等待，给底层的通知增加压力）        总结：        1、当没有任务时：所有线程都无限等待，没有leader线程，等待任务入队列的唤醒        2、当有任务时：唤醒的线程成为leader线程，当这个leader线程等待到期时，            取消自己为leader线程（另一种说法就是自己变成了follower线程），            唤醒一个无限期等待的线程，然后自己就去执行这个到期的任务，被唤醒的线程就会变成新的leader线程。一直这么循环下去        3、当实时向线程池添加最快需要执行的任务时：会取消当前leader线程，并唤醒一个阻塞的线程，让其成为新的leader线程         */</span>        <span class="token keyword">public</span> RunnableScheduledFuture<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>            <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>            lock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    RunnableScheduledFuture<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> first <span class="token operator">=</span> queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>first <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 不存在定时任务，所有线程都在这等待</span>                        available<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">else</span> <span class="token punctuation">{</span>                        <span class="token keyword">long</span> delay <span class="token operator">=</span> first<span class="token punctuation">.</span><span class="token function">getDelay</span><span class="token punctuation">(</span>NANOSECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>delay <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 时间已过，弹出队首任务去执行它</span>                            <span class="token keyword">return</span> <span class="token function">finishPoll</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 进入下面，无论怎样都要等待，所以直接把first置为null，下次循环再获取</span>                        <span class="token comment" spellcheck="true">// 因为可能多个线程走到下面，都持有了队首的引用。避免出现RunnableScheduledFuture运行完了但不能及时回收的情况</span>                        <span class="token comment" spellcheck="true">// 当然，也只有一次性的RunnableScheduledFuture才会回收，定时任务都是循环使用这个RunnableScheduledFuture的</span>                        first <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// don't retain ref while waiting</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>leader <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 由leader存在，其他线程只需要无限期等待就行</span>                            available<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 没有leader存在，设置当前线程为leader，并定时等待（时间就为最近待执行的那个任务的距离下次执行时间间隔）</span>                            Thread thisThread <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            leader <span class="token operator">=</span> thisThread<span class="token punctuation">;</span>                            <span class="token keyword">try</span> <span class="token punctuation">{</span>                                available<span class="token punctuation">.</span><span class="token function">awaitNanos</span><span class="token punctuation">(</span>delay<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 定时等待</span>                            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 时间一到，说明队首任务可执行了，但当前线程可能不是leader线程了，需要判断一下再置空</span>                                <span class="token keyword">if</span> <span class="token punctuation">(</span>leader <span class="token operator">==</span> thisThread<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 必须判断，有可能实时的添加了一个最快需要执行的线程，导致当前线程被取消了leader</span>                                    leader <span class="token operator">=</span> null<span class="token punctuation">;</span>                            <span class="token punctuation">}</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>leader <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span>                    <span class="token comment" spellcheck="true">// 任务取出来了，leader为空且存在队首任务，需要唤醒一个无限等待的线程</span>                    <span class="token comment" spellcheck="true">// 让其成为leader线程并继续定时等待</span>                    available<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3-总结"><a href="#2-3-总结" class="headerlink" title="2.3 总结"></a>2.3 总结</h3><p>​ScheduledThreadPoolExecutor本质还是个线程池，<strong>内部的DelayedWorkQueue就是工作队列。投递的定时任务和普通任务都会封装为ScheduledFutureTask，并最终放入DelayedWorkQueue里的那个数组（只不过定时任务有延时，可能会放在队列中的任何位置。而普通任务封装的ScheduledFutureTask执行时间就是当前而已，始终会放到队列的队首并立马执行）</strong></p><p>​DelayedWorkQueue实现了BlockingQueue，是基于<strong>数组的最小顶堆的数据结构</strong>实现，以此<strong>保证数组的第一个位置就是最近需要被执行的任务</strong>。结构图和特点如下</p><p>​ScheduledThreadPoolExecutor还使用了<strong>Leader-Follower模式</strong>，leader线程定时等待工作队列中第一个任务，其余线程一般就都无限期等待（如果向工作队列添加的是一个最快需要被执行的任务，可能就有多个定时等待的线程，但leader线程始终都会是最快需要被执行任务的线程）。</p><p><strong>为什么使用Leader-Follower模式：</strong></p><blockquote><p>​避免资源的浪费。定时任务再怎么排序，也只会有一个是最快需要执行的任务（时间相同会根据sequenceNumber排序），只需要设计一个定时等待线程等待这个最快需要执行的任务。当这个最快需要执行的任务触发后，再设计一个新的leader线程等待下一个最近的定时任务。理想的情况下，定时任务线程池只会有一个定时等待的线程（Leader线程），其余线程要么正在运行定时任务，要么全部无限期阻塞（Follower线程），最大程度的避免资源浪费（无限期等待的线程不用想其它的，乖乖等待被其他线程唤醒就行。而定时等待的线程需要在时间到达后被唤醒，至少需要被定时器监视以用来执行唤醒操作）</p></blockquote><ul><li><strong>固定周期</strong>：受执行时常影响，只有当任务结束后才相对于结束时间来计算任务的下次执行时间</li><li><strong>固定频率</strong>：不受任务的执行时常所影响，当任务投递到队列时就可以预判到以后任何执行该任务的时间</li></ul><p>​一个被投递的周期任务首先会封装成ScheduledFutureTask，再根据其下次执行时间放在DelayedWorkQueue的某个位置。如果放在了DelayedWorkQueue的队首，则使用定时任务线程池里的线程超时等待，以便时间到达后开始执行。正常执行完毕则会先根据其是固定周期任务还是固定频率的任务来计算下次执行时间并修赋值到ScheduledFutureTask的time字段，再将这个任务再次入队列，这样递归去执行。执行中如果抛出了异常，则会将ScheduledFutureTask的state修改为异常，之后就不再执行这个任务了</p>]]></content>
      
      
      <categories>
          
          <category> jdk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java源码篇-Future</title>
      <link href="/2020/05/09/java-yuan-ma-pian-future/"/>
      <url>/2020/05/09/java-yuan-ma-pian-future/</url>
      
        <content type="html"><![CDATA[<hr><p>​jdk中Future接口实现类相关源码解析。包括FutureTask和 ScheduledFutureTask</p> <span id="more"></span><h1 id="1-Future"><a href="#1-Future" class="headerlink" title="1 Future"></a>1 Future</h1><p>Future接口表示一个异步操作的结果，即未来的结果，同时实现了 <code>Runnable</code> 和 <code>Future</code> 接口。提供了如下的一些基础方法可获取、判断和取消等操作</p><ul><li><p><code>get()</code>：<strong>阻塞</strong>直到计算完成并返回结果（支持超时设置）</p></li><li><p><code>isDone()</code>：<strong>非阻塞</strong>检查任务是否完成（成功&#x2F;失败&#x2F;取消）</p></li><li><p><code>cancel(boolean mayInterruptIfRunning)</code>：尝试取消任务，参数决定是否中断执行中的线程</p></li><li><p><code>isCancelled()</code>：判断任务是否被取消</p></li></ul><p>其实现类为FutureTask，就是用它来实现Callable接口的功能</p><hr><h2 id="1-1-FutureTask"><a href="#1-1-FutureTask" class="headerlink" title="1.1 FutureTask"></a>1.1 FutureTask</h2><h3 id="1-1-1-重点字段和方法"><a href="#1-1-1-重点字段和方法" class="headerlink" title="1.1.1 重点字段和方法"></a>1.1.1 重点字段和方法</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FutureTask</span><span class="token operator">&lt;</span>V<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">RunnableFuture</span><span class="token operator">&lt;</span>V<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// state字段，表示了当前Future的状态，取值为如下字段</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> state<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> NEW          <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 初始状态，新建</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> COMPLETING   <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 正在结束</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> NORMAL       <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 正常执行完毕</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> EXCEPTIONAL  <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 异常执行完毕</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> CANCELLED    <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 前一个状态必须是NEW，已取消（未中断）</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> INTERRUPTING <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 前一个状态必须是NEW，正在中断（中断）</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> INTERRUPTED  <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 取消成功的才可以设置，中断完成（中断）</span>    <span class="token comment" spellcheck="true">// 待运行的Callable任务</span>    <span class="token keyword">private</span> Callable<span class="token operator">&lt;</span>V<span class="token operator">></span> callable<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Callable执行的结果。如果出现执行的过程中异常，则保存的是异常对象</span>    <span class="token keyword">private</span> Object outcome<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 运行Callable#call方法的线程（也即是运行业务代码的线程）</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> Thread runner<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 当这里面的Callable还未执行完，却有其他线程调用Future#get()方法，</span>    <span class="token comment" spellcheck="true">// 会将其他线程阻塞并构造为等待节点，维持一个链表结构，以便在Callable执行完毕后唤醒并回调</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> WaitNode waiters<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>state <span class="token operator">!=</span> NEW <span class="token operator">||</span>            <span class="token operator">!</span>UNSAFE<span class="token punctuation">.</span><span class="token function">compareAndSwapObject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> runnerOffset<span class="token punctuation">,</span>                                         null<span class="token punctuation">,</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Callable<span class="token operator">&lt;</span>V<span class="token operator">></span> c <span class="token operator">=</span> callable<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> state <span class="token operator">==</span> NEW<span class="token punctuation">)</span> <span class="token punctuation">{</span>                V result<span class="token punctuation">;</span>                <span class="token keyword">boolean</span> ran<span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 执行业务方法</span>                    result <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    ran <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    result <span class="token operator">=</span> null<span class="token punctuation">;</span>                    ran <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                    <span class="token function">setException</span><span class="token punctuation">(</span>ex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 异常结束，将状态设为EXCEPTIONAL，如果等待队列有节点，则唤醒对应的线程</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>ran<span class="token punctuation">)</span>                    <span class="token function">set</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 正常结束，将状态设为NORMAL，如果等待队列有节点，则唤醒对应的线程</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            runner <span class="token operator">=</span> null<span class="token punctuation">;</span>            <span class="token keyword">int</span> s <span class="token operator">=</span> state<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">>=</span> INTERRUPTING<span class="token punctuation">)</span>                <span class="token function">handlePossibleCancellationInterrupt</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 阻塞获取</span>    <span class="token keyword">public</span> V <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">,</span> ExecutionException <span class="token punctuation">{</span>        <span class="token keyword">int</span> s <span class="token operator">=</span> state<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">&lt;=</span> COMPLETING<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 还未完全结束Callabke，进入等待</span>            s <span class="token operator">=</span> <span class="token function">awaitDone</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> 0L<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">report</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 根据state判断是否需要阻塞并做对于的事</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">awaitDone</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> timed<span class="token punctuation">,</span> <span class="token keyword">long</span> nanos<span class="token punctuation">)</span>        <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        <span class="token keyword">final</span> <span class="token keyword">long</span> deadline <span class="token operator">=</span> timed <span class="token operator">?</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> nanos <span class="token operator">:</span> 0L<span class="token punctuation">;</span>        WaitNode q <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">boolean</span> queued <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 当前线程支持响应中断</span>                <span class="token function">removeWaiter</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">int</span> s <span class="token operator">=</span> state<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">></span> COMPLETING<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// Callable运行完毕，且result已经设置完毕</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>q <span class="token operator">!=</span> null<span class="token punctuation">)</span>                    q<span class="token punctuation">.</span>thread <span class="token operator">=</span> null<span class="token punctuation">;</span>                <span class="token keyword">return</span> s<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 进入到以下分支，就代表Callable还未完全执行完毕</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> COMPLETING<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// cannot time out yet  Callable运行完毕，但正在设置result，让出执行时间，等待下次判断</span>                Thread<span class="token punctuation">.</span><span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>q <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 第一次循环，构造等待节点</span>                q <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WaitNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>queued<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 还未加入等待队列，则将节点加入到等待队列中</span>                queued <span class="token operator">=</span> UNSAFE<span class="token punctuation">.</span><span class="token function">compareAndSwapObject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> waitersOffset<span class="token punctuation">,</span>                                                     q<span class="token punctuation">.</span>next <span class="token operator">=</span> waiters<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>timed<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 是否运行超时判断</span>                nanos <span class="token operator">=</span> deadline <span class="token operator">-</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nanos <span class="token operator">&lt;=</span> 0L<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">removeWaiter</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> state<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                LockSupport<span class="token punctuation">.</span><span class="token function">parkNanos</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> nanos<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token comment" spellcheck="true">// 暂停当前线程，等待任务执行完毕的唤醒</span>                LockSupport<span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 任务执行完毕，唤醒等待队列的所有节点</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">finishCompletion</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// assert state > COMPLETING;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>WaitNode q<span class="token punctuation">;</span> <span class="token punctuation">(</span>q <span class="token operator">=</span> waiters<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>UNSAFE<span class="token punctuation">.</span><span class="token function">compareAndSwapObject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> waitersOffset<span class="token punctuation">,</span> q<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    Thread t <span class="token operator">=</span> q<span class="token punctuation">.</span>thread<span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        q<span class="token punctuation">.</span>thread <span class="token operator">=</span> null<span class="token punctuation">;</span>                        LockSupport<span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    WaitNode next <span class="token operator">=</span> q<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                    q<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// unlink to help gc</span>                    q <span class="token operator">=</span> next<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        callable <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// to reduce footprint</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-1-2-总结"><a href="#1-1-2-总结" class="headerlink" title="1.1.2 总结"></a>1.1.2 总结</h3><ol><li>FutureTask根据内部的state字段来判断当前任务运行到了哪个阶段并作出对于的抉择，也使用<strong>volatile修饰保证它在多线程环境下的可见性</strong>。<ul><li><strong>state状态流转</strong>：<ul><li>NEW<code>→</code>COMPLETING<code>→</code>NORMAL<code>（成功）</code></li><li>NEW<code>→</code>COMPLETING<code>→</code>EXCEPTIONAL<code>（失败）</code></li><li>NEW<code>→</code>CANCELLED&#x2F;INTERRUPTED<code>（取消）</code></li></ul></li></ul></li><li>如果想获取任务执行的结果，要使用get来获取结果，get是个阻塞的方法。当任务还未执行完毕时，会将调用get的方法阻塞并构造成WaitNode，再通过内部的next字段链接下一个WaitNode，形成一个链表结构。当任务执行完毕后，内部调用的finishCompletion方法会判断等待链表是否为空，不为空就代表有线程在获取结果时被阻塞了，这时唤醒阻塞队列的所有线程，最终，调用get方法的线程返回结果。即<strong>使用 <code>WaitNode</code> 链表 + CAS 操作管理阻塞线程，避免显式锁开销</strong></li><li>只会允许任务执行一次，状态不可逆转</li></ol><h2 id="1-2-ScheduledFutureTask"><a href="#1-2-ScheduledFutureTask" class="headerlink" title="1.2 ScheduledFutureTask"></a>1.2 ScheduledFutureTask</h2><p>​ScheduledFutureTask继承了FutureTask，当<strong>向定时任务线程池投递任务时（Runnable或Callable），都会将其封装为ScheduledFutureTask</strong></p><h3 id="1-2-1-重点字段和方法"><a href="#1-2-1-重点字段和方法" class="headerlink" title="1.2.1 重点字段和方法"></a>1.2.1 重点字段和方法</h3><pre class="line-numbers language-java"><code class="language-java"> <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">ScheduledFutureTask</span><span class="token operator">&lt;</span>V<span class="token operator">></span>            <span class="token keyword">extends</span> <span class="token class-name">FutureTask</span><span class="token operator">&lt;</span>V<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">RunnableScheduledFuture</span><span class="token operator">&lt;</span>V<span class="token operator">></span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">/**      * 当前任务的id（自增的），代表了进入队列的顺序 &lt;br/>     * 当两个定时任务下次执行时间一致时，sequenceNumber越小就会越早执行     */</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">long</span> sequenceNumber<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 下次执行当前任务的纳秒时间戳</span>    <span class="token keyword">private</span> <span class="token keyword">long</span> time<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 执行定时任务的纳秒间隔时间     * 大于0：代表固定的频率，不受任务的执行所花费的时间影响     * 等于0：代表不是一个重复的任务（只会执行一次     * 小于0：代表固定的时间间隔，基于任务执行完毕后的时间计算。（任务执行完后再基于当前时间计算下次执行时间）     */</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">long</span> period<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 当前任务在数组中的索引</span>    <span class="token keyword">int</span> heapIndex<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">getDelay</span><span class="token punctuation">(</span>TimeUnit unit<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> unit<span class="token punctuation">.</span><span class="token function">convert</span><span class="token punctuation">(</span>time <span class="token operator">-</span> <span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> NANOSECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 比较方法，决定了放入数组的位置</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span>Delayed other<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>other <span class="token operator">==</span> <span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// compare zero if same object</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>other <span class="token keyword">instanceof</span> <span class="token class-name">ScheduledFutureTask</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            ScheduledFutureTask<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> x <span class="token operator">=</span> <span class="token punctuation">(</span>ScheduledFutureTask<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">)</span>other<span class="token punctuation">;</span>            <span class="token keyword">long</span> diff <span class="token operator">=</span> time <span class="token operator">-</span> x<span class="token punctuation">.</span>time<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>diff <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>diff <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 当前任务的下次执行时间更长，返回正数</span>                <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>sequenceNumber <span class="token operator">&lt;</span> x<span class="token punctuation">.</span>sequenceNumber<span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span>                <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">long</span> diff <span class="token operator">=</span> <span class="token function">getDelay</span><span class="token punctuation">(</span>NANOSECONDS<span class="token punctuation">)</span> <span class="token operator">-</span> other<span class="token punctuation">.</span><span class="token function">getDelay</span><span class="token punctuation">(</span>NANOSECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>diff <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> <span class="token punctuation">(</span>diff <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * false: 代表当前任务为一次性任务     * true: 定时任务     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isPeriodic</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> period <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 当前任务执行完毕后，用来计算下次执行时间</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">setNextRunTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">long</span> p <span class="token operator">=</span> period<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// p为两次执行时间的时间间隔的纳秒值</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// p大于0，即为固定时间执行的任务，基于初始运行时间计算下一次的执行时间</span>            time <span class="token operator">+=</span> p<span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token comment" spellcheck="true">// p小于0，为基于完成任务的时间来执行，基于任务运行完的时间，来计算出下一次的执行时间</span>            time <span class="token operator">=</span> <span class="token function">triggerTime</span><span class="token punctuation">(</span><span class="token operator">-</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 主方法，运行当前定时任务</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">boolean</span> periodic <span class="token operator">=</span> <span class="token function">isPeriodic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">canRunInCurrentRunState</span><span class="token punctuation">(</span>periodic<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>periodic<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 非定时任务，当作普通任务直接调用FutureTask的run方法运行</span>            ScheduledFutureTask<span class="token punctuation">.</span><span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ScheduledFutureTask<span class="token punctuation">.</span><span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">runAndReset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 运行定时任务，且运行成功（没抛异常）</span>            <span class="token function">setNextRunTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 设置下一次执行时间</span>            <span class="token function">reExecutePeriodic</span><span class="token punctuation">(</span>outerTask<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 再把当前任务重新入队列</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**      父类的FutureTask中的方法，运行并重置状态，用于任务的多次执行          * 正常执行时：不会修改运行状态（也就是说这个操作不会修改state字段值，保持初始值，以支持重复执行）。         * 出现异常时：还是将state设为EXCEPTIONAL，也就是说一个定时任务要是抛出了异常，之后就不会再执行它了         */</span>    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">runAndReset</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>state <span class="token operator">!=</span> NEW <span class="token operator">||</span> <span class="token comment" spellcheck="true">// 不为NEW状态的都不执行</span>            <span class="token operator">!</span>UNSAFE<span class="token punctuation">.</span><span class="token function">compareAndSwapObject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> runnerOffset<span class="token punctuation">,</span>                                         null<span class="token punctuation">,</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> ran <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> s <span class="token operator">=</span> state<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Callable<span class="token operator">&lt;</span>V<span class="token operator">></span> c <span class="token operator">=</span> callable<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> s <span class="token operator">==</span> NEW<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    c<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 不设置返回结果。多次执行的任务就不该有执行结果</span>                    ran <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">setException</span><span class="token punctuation">(</span>ex<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 抛出异常，修改state为EXCEPTIONAL，以后也不在执行它</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// runner must be non-null until state is settled to</span>            <span class="token comment" spellcheck="true">// prevent concurrent calls to run()</span>            runner <span class="token operator">=</span> null<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// state must be re-read after nulling runner to prevent</span>            <span class="token comment" spellcheck="true">// leaked interrupts</span>            s <span class="token operator">=</span> state<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">>=</span> INTERRUPTING<span class="token punctuation">)</span>                <span class="token function">handlePossibleCancellationInterrupt</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ran <span class="token operator">&amp;&amp;</span> s <span class="token operator">==</span> NEW<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2-2-总结"><a href="#1-2-2-总结" class="headerlink" title="1.2.2 总结"></a>1.2.2 总结</h3><p><code>ScheduledFutureTask</code> 通过 <code>period</code> 字段判断任务类型：<code>0</code> 表示一次性任务，<code>&gt;0</code> 表示固定频率，<code>&lt;0</code> 表示固定延迟。</p><p>在 <code>run()</code> 方法中，若<strong>任务为周期性任务，执行完当前任务后会计算下次执行时间，并将自身重新提交至基于小顶堆的 <code>DelayedWorkQueue</code> 中，以维持调度</strong>。</p><ul><li>基于纳秒时间精度，避免 <code>System.currentTimeMillis()</code> 的系统时间变动干扰。</li><li>复用 <code>FutureTask</code> 的任务封装机制，增强任务调度能力。</li><li>精简实现，不依赖额外锁，主要通过最小堆和 <code>Delayed</code> 接口实现调度。</li></ul>]]></content>
      
      
      <categories>
          
          <category> jdk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java源码篇-锁</title>
      <link href="/2020/04/18/java-yuan-ma-pian-suo/"/>
      <url>/2020/04/18/java-yuan-ma-pian-suo/</url>
      
        <content type="html"><![CDATA[<p>​jdk中AQS实现类相关源码解析。包括 ReentrantLock，Condition，CountDownLatch，Semaphore，ReentrantReadWriteLock</p><span id="more"></span><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="1-ReentrantLock"><a href="#1-ReentrantLock" class="headerlink" title="1 ReentrantLock"></a>1 ReentrantLock</h2><p>​基于AQS实现的一种可重入互斥锁，所以只允许一个线程获取到锁。获取到锁时state设为1，当获取到锁的线程尝试重入时，便会增加state，同理需要将state减到0才会释放锁</p><h3 id="1-1-非公平锁（NonfairSync）"><a href="#1-1-非公平锁（NonfairSync）" class="headerlink" title="1.1 非公平锁（NonfairSync）"></a>1.1 非公平锁（NonfairSync）</h3><h4 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h4><blockquote><ol><li>java.util.concurrent.locks.ReentrantLock.Sync#nonfairTryAcquire：利用CAS尝试设置state，能设置成功，代表获取到锁，成功返回。设置失败，代表已经被其他线程获取了锁，返回失败</li><li>返回失败后将当前线程构造为Node节点，设置到同步队列的链表中进入到<strong>java.util.concurrent.locks.AbstractQueuedSynchronizer#acquireQueued</strong>方法：死循环获取当前Node的前一个节点（<strong>同步队列的首节点是成功获取到锁的节点</strong>），如果前驱结点为首节点，当前Node才有资格获取锁。如果还是获取不到，就调用<strong>java.util.concurrent.locks.LockSupport#park</strong>(java.lang.Object)方法阻塞当前线程，等待其他线程唤醒再去竞争锁</li></ol></blockquote><h4 id="unlock"><a href="#unlock" class="headerlink" title="unlock"></a><strong>unlock</strong></h4><blockquote><ol><li>java.util.concurrent.locks.ReentrantLock.Sync#tryRelease：复原state（将其归0），exclusiveOwnerThread设为null</li><li>java.util.concurrent.locks.AbstractQueuedSynchronizer#release：在tryRelease成功后，使用<strong>java.util.concurrent.locks.LockSupport#unpark</strong>方法唤醒同步队列首节点的下一个节点里的线程，让他再去尝试获取锁</li></ol></blockquote><h3 id="1-2-公平锁（FairSync）"><a href="#1-2-公平锁（FairSync）" class="headerlink" title="1.2 公平锁（FairSync）"></a>1.2 公平锁（FairSync）</h3><h4 id="lock-1"><a href="#lock-1" class="headerlink" title="lock"></a><strong>lock</strong></h4><blockquote><p>​和非公平锁很像，不同的部分就在覆盖了<strong>java.util.concurrent.locks.AbstractQueuedSynchronizer#tryAcquire</strong>这个方法和非公平锁略有不同。在新的线程获取锁失败，并将自己构造为Node节点并放入同步队列链表后，还会通过调用<strong>java.util.concurrent.locks.AbstractQueuedSynchronizer#hasQueuedPredecessors</strong>方法</p></blockquote><h4 id="unlock：和非公平锁一样"><a href="#unlock：和非公平锁一样" class="headerlink" title="unlock：和非公平锁一样"></a><strong>unlock</strong>：和非公平锁一样</h4><h4 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// ReentrantLock的公平锁第一次尝试获取锁</span><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> Thread current <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">hasQueuedPredecessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token comment" spellcheck="true">// 测试当前线程是否是等待最久的线程</span>                <span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> acquires<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">==</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> nextc <span class="token operator">=</span> c <span class="token operator">+</span> acquires<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nextc <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Maximum lock count exceeded"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">setState</span><span class="token punctuation">(</span>nextc<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">/**  * 查询是否有线程等待获取的时间长于当前线程 * 判断是否存在队列中第二个Node(因为首节点是个空节点)，且第二个节点中的线程是否是当前线程 * 也就是说：判断同步队列中当前节点是否有前驱结点 * true:代表当前线程不是等待最久的线程或压根就没有等待的线程 * false:在代表当前线程已经是等待最久的线程（毕竟队列越前面，则代表进去的越久）&lt;p/> * 只有公平锁才需要用到这个方法，来判断当前线程是否等待时间最长 */</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">hasQueuedPredecessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node t <span class="token operator">=</span> tail<span class="token punctuation">;</span>     Node h <span class="token operator">=</span> head<span class="token punctuation">;</span>    Node s<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 用 h != t 来做判断是因为调用这个方法的线程此时还没有进入等待队列</span>    <span class="token comment" spellcheck="true">// 如果 h != t，则代表队列中有线程在等待获取锁</span>    <span class="token keyword">return</span> h <span class="token operator">!=</span> t <span class="token operator">&amp;&amp;</span>        <span class="token punctuation">(</span><span class="token punctuation">(</span>s <span class="token operator">=</span> h<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">||</span> s<span class="token punctuation">.</span>thread <span class="token operator">!=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-3-总结"><a href="#1-3-总结" class="headerlink" title="1.3 总结"></a>1.3 总结</h3><h4 id="1-3-1-为什么叫公平锁和非公平锁"><a href="#1-3-1-为什么叫公平锁和非公平锁" class="headerlink" title="1.3.1 为什么叫公平锁和非公平锁"></a>1.3.1 为什么叫公平锁和非公平锁</h4><p>​根据上面的分析，<strong>公平锁在获取锁是总是会先判断当前线程是否是等待最久的线程</strong>。<strong>所以，就算是同步队列存在大量Node，且有线程第一次在获取锁，那么，下一次获取到锁的线程也一定是同步队列的首节点的下一个节点，即必须排队。（首节点就是当前获取到锁的节点，只有获取成功了，同步才会更新首节点）</strong></p><p>​<strong>非公平锁中：对于已经进入同步队列的线程来说，也只能首节点的下一个节点里的线程能尝试获取锁。但对于还未构造成Node加入到同步队列的线程来说，这个线程和首节点的下一个节点里的线程能竞争获取锁</strong>，所以非公平。<strong>但对于已经进入同步队列的线程来说，前驱结点是一定比后面的节点先获取到锁的</strong></p><h4 id="1-3-2-各自优势"><a href="#1-3-2-各自优势" class="headerlink" title="1.3.2 各自优势"></a>1.3.2 各自优势</h4><ul><li>公平锁：防止线程饥饿，分散性很好，适合线程等待时间敏感的场景</li><li>非公平锁：更快。一是<strong>获取锁是不用判断当前线程是否是等待最久的线程</strong>。二是<strong>上下文交换没有公平锁频繁</strong>。在存在大量锁竞争的前提下，可以肯定，公平锁上下文切换很频繁，获取锁后的线程再次获取锁时是一定会阻塞的。而非公平锁则不一样，下一次获取到锁的线程仍可能是上一次获取到锁的线程，没有上下文切换</li></ul><h2 id="2-Condition"><a href="#2-Condition" class="headerlink" title="2 Condition"></a>2 Condition</h2><p>等待通知接口，代替Object原生的wait和notify，其具体实现为AQS里的ConditionObject（定义在AQS里的非静态内部类，所以使用了AQS部分方法来实现其功能）。<strong>只有获取到锁的线程才能调用Condition的阻塞和唤醒方法</strong>。三个核心组件如下</p><ul><li>等待队列：使用 Node 节点串联，与 AQS 同步队列共用 Node 结构 </li><li>状态转换：Node 在等待队列和同步队列之间的转换 </li><li>线程控制：包括阻塞、唤醒、中断处理等机制</li></ul><p>主要字段</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 等待队列中的首节点</span><span class="token keyword">private</span> <span class="token keyword">transient</span> Node firstWaiter<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 等待队列中的尾节点</span><span class="token keyword">private</span> <span class="token keyword">transient</span> Node lastWaiter<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-1-Condition-await"><a href="#2-1-Condition-await" class="headerlink" title="2.1 Condition#await"></a>2.1 Condition#await</h3><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><blockquote><ul><li>首先将当前线程构造为等待节点，并加入到等待队列的末尾</li><li>其次释放锁资源（能够await的线程一定是获取到锁的），同时唤醒同步队列的第二个节点，让其尝试获取锁</li><li>死循环判断当前节点是否为同步节点（等待节点在等待队列里，是一定要阻塞的。同步节点在同步队列里，是可以并被唤醒并尝试获取锁的），await到这里线程就阻塞了</li><li>当被唤醒后，当前节点一定被加入了同步队列，再尝试获取锁，如果能获取到，代表就可以返回了。如果获取不到，就表示当前同步块被其他线程暂用了，也还是阻塞。不过下一次被唤醒后就会通过同步队列的唤醒方式来尝试获取锁</li></ul></blockquote><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 响应中断</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 构建等待节点并加入等待队列</span>    Node node <span class="token operator">=</span> <span class="token function">addConditionWaiter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 先检查当前线程是否已获取到锁，否则抛异常。然后完全释放锁并且唤醒同步队列中的第二个节点</span>    <span class="token keyword">int</span> savedState <span class="token operator">=</span> <span class="token function">fullyRelease</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> interruptMode <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 死循环判断当前节点是否在等待队列中</span>    <span class="token comment" spellcheck="true">// 等待队列中的节点一定要阻塞，而同步队列中的节点是可以被唤醒的</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isOnSyncQueue</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        LockSupport<span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>interruptMode <span class="token operator">=</span> <span class="token function">checkInterruptWhileWaiting</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 当signal后，需要重新获取锁，要复原现场，需要重新持有上一次所持有的所有的state值</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">acquireQueued</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> savedState<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> interruptMode <span class="token operator">!=</span> THROW_IE<span class="token punctuation">)</span>        interruptMode <span class="token operator">=</span> REINTERRUPT<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>nextWaiter <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// clean up if cancelled</span>        <span class="token function">unlinkCancelledWaiters</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>interruptMode <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 当前节点有中断</span>        <span class="token function">reportInterruptAfterWait</span><span class="token punctuation">(</span>interruptMode<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** *   将当前线程构造为一个等待节点，并加入到等待队列的尾部，并通过nextWaiter字段建立联系 &lt;br/> *  注意：等待队列建立关联用的是nextWaiter字段，不是prev和next字段 */</span><span class="token keyword">private</span> Node <span class="token function">addConditionWaiter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node lastW <span class="token operator">=</span> lastWaiter<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 尾节点</span>    <span class="token comment" spellcheck="true">// If lastWaiter is cancelled, clean out.</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>lastW <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> lastW<span class="token punctuation">.</span>waitStatus <span class="token operator">!=</span> Node<span class="token punctuation">.</span>CONDITION<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">unlinkCancelledWaiters</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        lastW <span class="token operator">=</span> lastWaiter<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    Node node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Node<span class="token punctuation">.</span>CONDITION<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>lastW <span class="token operator">==</span> null<span class="token punctuation">)</span>        firstWaiter <span class="token operator">=</span> node<span class="token punctuation">;</span>    <span class="token keyword">else</span>        lastW<span class="token punctuation">.</span>nextWaiter <span class="token operator">=</span> node<span class="token punctuation">;</span>    lastWaiter <span class="token operator">=</span> node<span class="token punctuation">;</span>    <span class="token keyword">return</span> node<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// ====================以下为AQS中的方法===================</span><span class="token comment" spellcheck="true">// 判断这个节点是否在同步队列上</span><span class="token comment" spellcheck="true">// false -> 这个节点在等待队列上</span><span class="token comment" spellcheck="true">// true -> 这个节点在同步队列上</span><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">isOnSyncQueue</span><span class="token punctuation">(</span>Node node<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>waitStatus <span class="token operator">==</span> Node<span class="token punctuation">.</span>CONDITION <span class="token operator">||</span> node<span class="token punctuation">.</span>prev <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// If has successor, it must be on queue</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">findNodeFromTail</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*** 当前节点尝试获取锁* 返回true -> 获取锁的过程有中断*/</span><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token keyword">final</span> Node node<span class="token punctuation">,</span> <span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">boolean</span> failed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">boolean</span> interrupted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">final</span> Node prevNode <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">predecessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 只有当前节点的前驱结点为首节点，当前节点里的线程才有资格获取锁</span>            <span class="token comment" spellcheck="true">// 只可能有一个线程获取成功（即获取锁），所以设置首节点不需要同步了</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>prevNode <span class="token operator">==</span> head <span class="token operator">&amp;&amp;</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">setHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>                prevNode<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// help GC</span>                failed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> interrupted<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>prevNode<span class="token punctuation">,</span> node<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                interrupted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>failed<span class="token punctuation">)</span>            <span class="token function">cancelAcquire</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-Condition-signal和signalAll"><a href="#2-2-Condition-signal和signalAll" class="headerlink" title="2.2 Condition#signal和signalAll"></a>2.2 Condition#signal和signalAll</h3><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>singal的目的很简单，就是将等待队列的首节点转移到同步队列的尾节点，signalAll则是将等待队列中的所有节点都转移到同步节点。<strong>signal方法本身不能唤醒线程，只是让这些节点里的线程有资格被唤醒</strong>，可以将signal和排队买票做类比</p><ul><li>等待队列相当于候补区</li><li>signal 相当于叫号，让候补区的人去正式排队区（同步队列）</li><li>但叫号本身并不会直接让人拿到票，还需要排队区的人按顺序获取票（锁）</li></ul><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">doSignal</span><span class="token punctuation">(</span>Node first<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">do</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 将首节点的nextWaiter转移到首节点，如果nextWaiter为空，则表示队列中只有一个节点，且首尾相同</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>firstWaiter <span class="token operator">=</span> first<span class="token punctuation">.</span>nextWaiter<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>            lastWaiter <span class="token operator">=</span> null<span class="token punctuation">;</span>        first<span class="token punctuation">.</span>nextWaiter <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// gc处理</span>    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">transferForSignal</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>             <span class="token punctuation">(</span>first <span class="token operator">=</span> firstWaiter<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 将当前的等待节点转换为同步节点，并加入到同步队列的末尾</span><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">transferForSignal</span><span class="token punctuation">(</span>Node node<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> Node<span class="token punctuation">.</span>CONDITION<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    Node p <span class="token operator">=</span> <span class="token function">enq</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> ws <span class="token operator">=</span> p<span class="token punctuation">.</span>waitStatus<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> ws<span class="token punctuation">,</span> Node<span class="token punctuation">.</span>SIGNAL<span class="token punctuation">)</span><span class="token punctuation">)</span>        LockSupport<span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 前驱节点被取消了，或者设置为SIGNAL失败</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3-总结"><a href="#2-3-总结" class="headerlink" title="2.3 总结"></a>2.3 总结</h3><p>​Condition实现了等待通知，当一个线程进入同步块后，就可以调用await，释放自己获取的锁资源，将自己阻塞。内部实现是<strong>首先将当前线程构造成一个等待节点，加入ConditionObject的等待队列的末尾，再释放锁资源，之后唤醒同步队列的第二个节点让其尝试获取锁</strong>。而当其他进入同步块的线程调用signal后，会将等待队列的首节点转移到同步队列，并将其变成同步节点，最后再使用同步队列的唤醒机制等待被唤醒。</p><p>​所以signal并不能直接唤醒一个await的线程，最佳使用案例就是消费者发送者机制，比如阻塞队列。</p><h2 id="3-CountDownLatch"><a href="#3-CountDownLatch" class="headerlink" title="3 CountDownLatch"></a>3 CountDownLatch</h2><p>CountDownLatch为共享锁实现，只能使用一次。用来“卡点”，阻塞的线程需要等待其他线程准备好了后（countDown直到AQS里的state为0），才继续被唤醒执行后面的代码。</p><p>在CountDownLatch中，AQS里的state值并不表示可获取到锁的次数，而是<strong>java.util.concurrent.CountDownLatch#countDown</strong> state值的次数后会释放所有调用了**java.util.concurrent.CountDownLatch#await()**的线程</p><p>内部的同步器Sync主要方法</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**    获取共享锁，只有AQS的state为0才能获取到    通过这个接口就可以猜到，当state为0时（拉下了所有门闩），总会返回1，代表获取锁成功。    并依次传播下去递归调用这个方法，直到同步队列的所有Node里的线程全部唤醒，这就是CountDownLatch的原理*/</span><span class="token keyword">protected</span> <span class="token keyword">int</span> <span class="token function">tryAcquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 释放共享锁，state第一次被减为0才释放成功，也就表示了CountDownLatch只能用一次</span><span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryReleaseShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> releases<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Decrement count; signal when transition to zero</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> nextc <span class="token operator">=</span> c<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> nextc<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> nextc <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>await方法会阻塞当前线程，直到其他线程“拉下所有门闩”。阻塞的线程会构造为共享节点加入同步队列，只有队首节点的下一个节点才有资格尝试获取锁，获取不到就LockSupport#park</p><p>countDown会将state值减小1，当state将为0时，释放同步队列里的第二个共享节点里的线程。当这个线程释放后，就能成功获取到锁了，将这个事件传播下去，一次唤醒同步队列里的所有共享节点。至此，所有被阻塞的线程都被唤醒且会成功获取到锁，最终从await方法里返回</p><h2 id="4-Semaphore"><a href="#4-Semaphore" class="headerlink" title="4 Semaphore"></a>4 Semaphore</h2><p><strong>信号量，共享锁实现。可以利用构造器指定令牌（permits）的数量。当线程到达时，获取（acquire）指定数量的令牌，当没有可用令牌（premits为0）时，阻塞线程，等待令牌的释放（release）再被唤醒后继续执行。基于此，即可实现共享锁（permits大于1），也可实现不可重入的互斥锁（permits为1）</strong></p><p>也分为公平锁和分公平锁，其判断方式完全和ReentrantLock一致。</p><p>​<strong>非公平锁允许准备进入同步块的线程（还未加入同步队列）和同步队列中的第二个节点竞争获取锁。而公平锁则只允许同步队列中第二个节点里的线程能尝试获取锁。</strong></p><p>​<strong>其实现方式就是将state设为我们允许并发运行的线程数量，每当一个线程获取到锁后，将state - 1，如果state为0则阻塞所有准备进入同步块的线程，并将其构造为共享节点加入同步队列。每当有线程从同步块退出时，将state + 1，并根据是否非公平来唤醒同步队列的第二个节点来尝试获取锁</strong></p><h2 id="5-ReentrantReadWriteLock"><a href="#5-ReentrantReadWriteLock" class="headerlink" title="5 ReentrantReadWriteLock"></a>5 ReentrantReadWriteLock</h2><p>​读写锁，<strong>支持并发的读或互斥的写</strong>。读写锁分别各自实现，读锁使用共享锁，写锁使用互斥锁。ReentrantReadWriteLock内部的ReadLock和WriteLock都使用了内部同一个Sync对象来实现读写加锁的功能，在Sync内，他将AQS的state转换为二进制，高十六位表示读状态位，低十六位表示写状态位。由于读是共享的，所以state的高十六位表示了当前有多少个线程在读，在此期间写锁是禁用的。而低十六位是写锁，所以只可能有一个线程，但可能数字大于1（这是就表示写锁重入了）。当写锁被占用是，读是不允许的</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> SHARED_SHIFT<span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">//   读状态位            写状态位</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> SHARED_UNIT  <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> SHARED_SHIFT<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 0000000000000001 0000000000000000</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAX_COUNT <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> SHARED_SHIFT<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//0000000000000000 1111111111111111</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> EXCLUSIVE_MASK <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> SHARED_SHIFT<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//0000000000000000 1111111111111111</span><span class="token comment" spellcheck="true">// 获取共享锁冲入次数（读锁专用）</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">sharedCount</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span>    <span class="token punctuation">{</span> <span class="token keyword">return</span> c <span class="token operator">>>></span> SHARED_SHIFT<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 获取排他锁冲入次数（写锁专用）</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">exclusiveCount</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> c <span class="token operator">&amp;</span> EXCLUSIVE_MASK<span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>读写锁都支持重入，但写锁只能让当前线程重入，并且要解锁时需要unlock重入的次数。</strong></p></li><li><p><strong>支持锁降级但不支持锁升级</strong></p><blockquote><p> 锁降级：即一个线程在持有写锁的情况下，可以继续获取读锁，然后释放写锁，从而将写锁降级为读锁。在某些场景下很有用，比如</p><ul><li>在写操作完成后，仍然需要保持对数据的读访问权限</li><li>避免其他线程在写锁释放后立即获取写锁，导致数据不一致</li></ul></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> jdk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AQS实现类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java源码篇-AQS</title>
      <link href="/2020/04/17/java-yuan-ma-pian-aqs/"/>
      <url>/2020/04/17/java-yuan-ma-pian-aqs/</url>
      
        <content type="html"><![CDATA[<hr><p>​总结了LockSupport的作用，并从源码分析了AbstractQueuedSynchronizer的实现逻辑</p><span id="more"></span><h1 id="Java源码篇-AQS"><a href="#Java源码篇-AQS" class="headerlink" title="Java源码篇-AQS"></a>Java源码篇-AQS</h1><h2 id="1-LockSupport"><a href="#1-LockSupport" class="headerlink" title="1 LockSupport"></a>1 LockSupport</h2><h3 id="1-1-总结"><a href="#1-1-总结" class="headerlink" title="1.1 总结"></a>1.1 总结</h3><p>Java中实现<strong>当前线程的阻塞和定时阻塞</strong>，并提供<strong>唤醒指定线程</strong>的工具，在内部使用sun.misc.Unsafe来实现这一系列的操作。在AQS中普遍被使用</p><ul><li><strong>阻塞当前线程</strong>：通过 <code>park()</code> 方法使当前线程进入等待状态。</li><li><strong>定时阻塞</strong>：通过 <code>parkNanos(long nanos)</code> 或 <code>parkUntil(long deadline)</code> 方法使当前线程在指定时间内等待。</li><li><strong>唤醒指定线程</strong>：通过 <code>unpark(Thread thread)</code> 方法唤醒指定的处于等待状态的线程。</li></ul><h3 id="1-2-核心代码"><a href="#1-2-核心代码" class="headerlink" title="1.2 核心代码"></a>1.2 核心代码</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 唤醒指定的线程（如果该线程被park了） * 如果线程先被unpark（解除等待）了，那么该线程下一次调用park(进入等待)则不起作用，也就不会被阻塞 */</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">unpark</span><span class="token punctuation">(</span>Thread thread<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>thread <span class="token operator">!=</span> null<span class="token punctuation">)</span>        UNSAFE<span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 阻塞当前线程，并设置一个blocker（俗称阻塞器，这个只是用来jstack查看，并不能通过notifyAll来唤醒阻塞的线程） * blocker只能用来调试和诊断，并不影响线程的阻塞和唤醒 */</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">park</span><span class="token punctuation">(</span>Object blocker<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Thread t <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">setBlocker</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> blocker<span class="token punctuation">)</span><span class="token punctuation">;</span>    UNSAFE<span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> 0L<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">setBlocker</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 定时等待，阻塞当前线程指定的纳秒数，当时间到达时就自动唤醒（定时任务会调用） */</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">parkNanos</span><span class="token punctuation">(</span><span class="token keyword">long</span> nanos<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nanos <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>        UNSAFE<span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> nanos<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 定时等待，阻塞当前线程直到指定的时间戳（deadline）到来就自动唤醒（定时任务会调用） */</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">parkUntil</span><span class="token punctuation">(</span><span class="token keyword">long</span> deadline<span class="token punctuation">)</span> <span class="token punctuation">{</span>    UNSAFE<span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> deadline<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-AbstractQueuedSynchronizer"><a href="#2-AbstractQueuedSynchronizer" class="headerlink" title="2 AbstractQueuedSynchronizer"></a>2 AbstractQueuedSynchronizer</h2><blockquote><p>​Node是AQS的核心内部类，它是构建同步器的基础数据结构，通过不同的配置可以实现同步队列，也可实现等待队列</p></blockquote><h3 id="2-1-同步队列"><a href="#2-1-同步队列" class="headerlink" title="2.1 同步队列"></a>2.1 同步队列</h3><p>​<strong>当线程尝试获取锁时，未获取到锁的线程会被构造成一个Node，利用CAS放入同步尾部作为尾节点，等待被唤醒。同步队列关联的是整个锁，一对一的关系。而同步队列中的Node又根据nextWaiter字段判断当前Node是共享节点还是独占节点</strong></p><ul><li><p>Node之间通过<strong>prev和next指针构成双向链表</strong></p></li><li><p><strong>头节点(head)代表当前持有锁的线程</strong></p></li><li><p>包含waitStatus字段标记节点状态</p><ul><li><strong>CANCELLED(1): 线程已取消</strong></li><li><strong>SIGNAL(-1): 后继节点需要唤醒</strong></li><li><strong>CONDITION(-2): 节点在等待队列中</strong></li><li>PROPAGATE(-3): 共享锁需要向后传播</li><li>0: 初始状态</li></ul></li><li><p>使用nextWaiter区分共享&#x2F;互斥模式</p><ul><li><p><strong>共享节点：共享锁的实现（Semaphore、CountDownLatch等）。nextWaiter字段为固定的Node#SHARED。释放当前节点的线程后，还具有向后传播的能力（根据state的值判断是否需要释放后继共享节点里的线程）</strong></p></li><li><p><strong>互斥节点：互斥锁的实现（ReentrantLock等），nextWaiter字段为Node#EXCLUSIVE（即null），只会释放当前节点里的线程</strong></p></li></ul></li></ul><h3 id="2-2-等待队列"><a href="#2-2-等待队列" class="headerlink" title="2.2 等待队列"></a>2.2 等待队列</h3><p>​当已经获取到锁的线程触发<strong>java.util.concurrent.locks.Condition#await()<strong>方法阻塞自己，让出锁时。</strong>会将当前线程构造成一个Node（等待节点，状态为CONDITION），利用CAS放入等待队列尾部。等待队列关联的是Condition。所以，当ReentrantLock构造多个Condition时，就有多个等待队列，ReentrantLock和等待队列可以为一对多，而Condition和等待队列时一对一</strong>。而<strong>当其他线程获取当前锁（ReentrantLock）的线程调用java.util.concurrent.locks.Condition#signal等方法时，便会将等待队列的首节点转入到同步队列的尾节点，并重新设置Node的状态</strong></p><ul><li><p>单向链表结构，只使用nextWaiter指针</p></li><li><p><strong>nextWaiter字段为等待队列中下一个等待节点的指针</strong></p></li><li><p>当调用signal()时，节点从等待队列转移到同步队列过程中的状态变化如下</p><ol><li>CONDITION -&gt; 0</li><li>入队同步队列</li><li>等待获取锁</li></ol></li></ul><h3 id="2-3-核心代码"><a href="#2-3-核心代码" class="headerlink" title="2.3 核心代码"></a>2.3 核心代码</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 同步队列专属的头尾节点。</span><span class="token comment" spellcheck="true">// 因为只有在同步队列里的线程才需要被唤醒。等待队列里的线程如果要被唤醒，需要先加入到同步队列</span><span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> Node head<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> Node tail<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 核心，可获取到锁的次数</span><span class="token comment" spellcheck="true">// - ReentrantLock: 表示重入次数</span><span class="token comment" spellcheck="true">// - Semaphore: 表示剩余许可数</span><span class="token comment" spellcheck="true">// - CountDownLatch: 表示剩余计数</span><span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> state<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 自旋的阈值（纳秒）。当超时等待时间小于这个值时，就不会再暂停线程，而是自旋。因为这个时间已经很少了，考虑到阻塞线程后上线文切换会消耗时间，就没必要再阻塞了</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> spinForTimeoutThreshold <span class="token operator">=</span> 1000L<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 获取到独占锁的线程</span><span class="token keyword">private</span> <span class="token keyword">transient</span> Thread exclusiveOwnerThread<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**    留给子类实现的尝试获取共享锁的方法，共享锁获取，返回AQS里state的剩余值     1：返回值 > 0，代表当前线程获取成功，且state还有剩余值，表示可以继续传播给下一个共享节点线程，让其尝试获取锁     2：返回值 = 0，代表当前线程获取成功，但state值刚好被用完，那么下一个共享节点线程就不应该被唤醒了（因为这时已经获取不到state的剩余值了）    3：返回值 &lt; 0，代表当前线程都没获取成功，直接获取失败，阻塞等待被其他线程唤醒后在尝试获取*/</span><span class="token keyword">protected</span> <span class="token keyword">int</span> <span class="token function">tryAcquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UnsupportedOperationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 获取共享锁</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">doAcquireSharedInterruptibly</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span>    <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    <span class="token keyword">final</span> Node node <span class="token operator">=</span> <span class="token function">addWaiter</span><span class="token punctuation">(</span>Node<span class="token punctuation">.</span>SHARED<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> failed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">final</span> Node p <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">predecessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> head<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 首节点的下个节点才有资格获取锁（首节点就是获取到锁的节点）</span>                <span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token function">tryAcquireShared</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 至少当前线程获取成功了，但可能state值已经被用完了</span>                    <span class="token comment" spellcheck="true">// 获取成功，传播给下一个共享Node，根据state的剩余值来判断是否需要唤醒下一个共享Node里的线程</span>                    <span class="token function">setHeadAndPropagate</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>                    p<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// help GC</span>                    failed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> node<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 不能获取到锁线程就park</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>failed<span class="token punctuation">)</span>            <span class="token function">cancelAcquire</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 释放共享锁（Semaphore会使用）</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">doReleaseShared</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 必要的循环</span>      <span class="token comment" spellcheck="true">// 1. CAS操作可能失败需要重试</span>    <span class="token comment" spellcheck="true">// 2. 在设置head的过程中可能有新的节点入队</span>    <span class="token comment" spellcheck="true">// 3. 传播机制要求必须确保传播状态正确设置</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Node h <span class="token operator">=</span> head<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// h != tail 检查确保队列中还有后继节点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> h <span class="token operator">!=</span> tail<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> ws <span class="token operator">=</span> h<span class="token punctuation">.</span>waitStatus<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">==</span> Node<span class="token punctuation">.</span>SIGNAL<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> Node<span class="token punctuation">.</span>SIGNAL<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// loop to recheck cases</span>                <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>                     <span class="token operator">!</span><span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> Node<span class="token punctuation">.</span>PROPAGATE<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// loop on failed CAS</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">==</span> head<span class="token punctuation">)</span>                   <span class="token comment" spellcheck="true">// loop if head changed</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*    将目标节点（参数node）设为同步队列的尾部（使用CAS来解决并发问题）。    所以，在这整个过程中，链表中除首节点外其余节点的prev在任何时刻都不会为空；        但除尾节点外其余节点的next字段有可能为空 （刚好走完第②步，还没走到第③步）*/</span><span class="token keyword">private</span> Node <span class="token function">enq</span><span class="token punctuation">(</span><span class="token keyword">final</span> Node node<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Node t <span class="token operator">=</span> tail<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 初始化同步队列，设置一个空Node为首尾节点</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetHead</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                tail <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            node<span class="token punctuation">.</span>prev <span class="token operator">=</span> t<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 先将目标节点的prev设置程原尾节点 ①</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetTail</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// CAS设置尾节点 ②</span>                t<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 设置成功了，才把原尾节点的next设为目标节点（现尾节点）③</span>                <span class="token keyword">return</span> t<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 唤醒目标节点（参数node）的最近下一个可唤醒节点中的线程</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span>Node node<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> ws <span class="token operator">=</span> node<span class="token punctuation">.</span>waitStatus<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> ws<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 首节点的下个节点唤醒失败时，就从尾节点向前遍历，直到找到距首节点最近的可唤醒的节点</span>    <span class="token comment" spellcheck="true">// 目的是避免并发时（节点入队列和唤醒），倒数第二个节点（甚至不止）的next字段为空，导致拿不到其实已经入队列里的后续节点</span>    Node s <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> null <span class="token operator">||</span> s<span class="token punctuation">.</span>waitStatus <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        s <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Node t <span class="token operator">=</span> tail<span class="token punctuation">;</span> t <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> t <span class="token operator">!=</span> node<span class="token punctuation">;</span> t <span class="token operator">=</span> t<span class="token punctuation">.</span>prev<span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span>waitStatus <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>                s <span class="token operator">=</span> t<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">!=</span> null<span class="token punctuation">)</span>        LockSupport<span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// ============内部的Node数据结构=================</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 共享锁</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> Node SHARED <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 互斥锁</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> Node EXCLUSIVE <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//  取消获取锁</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> CANCELLED <span class="token operator">=</span>  <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> SIGNAL    <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 等待condition唤醒（等待队列才会用到这个状态）</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> CONDITION <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> PROPAGATE <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 当前节点的状态</span>    <span class="token keyword">volatile</span> <span class="token keyword">int</span> waitStatus<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 同步队列专用</span>    <span class="token keyword">volatile</span> Node prev<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 同步队列专用</span>    <span class="token keyword">volatile</span> Node next<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 等待线程</span>    <span class="token keyword">volatile</span> Thread thread<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 1. 当前Node为同步队列中的共享节点时：SHARED</span>    <span class="token comment" spellcheck="true">// 2. 当前Node为同步队列中的独占节点时：null</span>    <span class="token comment" spellcheck="true">// 3. 当前Node为等待队列中的节点时：下一个等待节点的指针</span>    Node nextWaiter<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 判断当前节点是互斥锁，还是共享锁</span>    <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">isShared</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> nextWaiter <span class="token operator">==</span> SHARED<span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 当前节点的前驱结点</span>    <span class="token keyword">final</span> Node <span class="token function">predecessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> NullPointerException <span class="token punctuation">{</span>        Node p <span class="token operator">=</span> prev<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> null<span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token keyword">return</span> p<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> jdk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LockSupport </tag>
            
            <tag> AQS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java源码篇-Map</title>
      <link href="/2020/04/09/java-yuan-ma-pian-map/"/>
      <url>/2020/04/09/java-yuan-ma-pian-map/</url>
      
        <content type="html"><![CDATA[<p>​jdk中常用Map实现类相关源码解析。包括 HashMap，LinkedHashMap，ConcurrentHashMap</p> <span id="more"></span><h1 id="Java源码篇-Map"><a href="#Java源码篇-Map" class="headerlink" title="Java源码篇-Map"></a>Java源码篇-Map</h1><h2 id="1-HashMap"><a href="#1-HashMap" class="headerlink" title="1 HashMap"></a>1 HashMap</h2><h3 id="1-1-重点字段"><a href="#1-1-重点字段" class="headerlink" title="1.1 重点字段"></a>1.1 重点字段</h3><pre class="line-numbers language-java"><code class="language-java"> <span class="token comment" spellcheck="true">/** * 数组默认长度 */</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_INITIAL_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// aka 16</span><span class="token comment" spellcheck="true">/** * 最大容量（即数组最大长度） */</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAXIMUM_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">30</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 默认加载因子 * 加载因子（loadFactor）是哈希表中用于控制数组存放数据疏密程度的参数。 * 当loadFactor越趋近于1时，数组中存放的数据（entry）越多，哈希冲突的概率增加， * 导致单个桶中的链表长度可能增加，进而影响查找元素的效率。反之，当loadFactor越小， * 数组中存放的数据越少，数据分布越稀疏，数组的利用率降低。 * * 默认的loadFactor值为0.75f，是官方经过权衡后给出的一个较为理想的平衡点， * 旨在兼顾查找效率和空间利用率。 */</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">float</span> DEFAULT_LOAD_FACTOR <span class="token operator">=</span> <span class="token number">0.75f</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 树化阈值。当桶(bucket)上的结点数大于这个值时会转成红黑树 */</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TREEIFY_THRESHOLD <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 链表化阈值（当桶(bucket)上的结点数小于这个值时树转链表） */</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> UNTREEIFY_THRESHOLD <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 桶中结构树化对应的table的最小长度 */</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MIN_TREEIFY_CAPACITY <span class="token operator">=</span> <span class="token number">64</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 扩容阈值（threshold） * threshold = loadFactor * 数组长度 * 当HashMap中元素的数量超过threshold时，会触发数组的扩容操作。 * 扩容是为了减少哈希冲突，保持查找效率。 */</span><span class="token keyword">int</span> threshold<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2-核心方法"><a href="#1-2-核心方法" class="headerlink" title="1.2 核心方法"></a>1.2 核心方法</h3><h4 id="1-2-1-put"><a href="#1-2-1-put" class="headerlink" title="1.2.1 put"></a>1.2.1 put</h4><h5 id="1-初始化数组"><a href="#1-初始化数组" class="headerlink" title="1 初始化数组"></a>1 <strong>初始化数组</strong></h5><ul><li>如果是第一次添加元素，先初始化数组（即分配内存空间）。</li><li>计算键的哈希值并确定索引位置，然后将键值对放入对应的桶（bucket）中。</li></ul><h5 id="2-目标桶为空"><a href="#2-目标桶为空" class="headerlink" title="2 目标桶为空"></a>2 <strong>目标桶为空</strong></h5><ul><li>如果计算索引后，数组中对应的桶为空，则直接将键值对放入该桶中。</li></ul><h5 id="3-目标桶不为空"><a href="#3-目标桶不为空" class="headerlink" title="3 目标桶不为空"></a>3 <strong>目标桶不为空</strong></h5><ul><li><strong>根节点匹配</strong>：<ul><li>如果桶中的根节点（第一个节点）与待插入节点的键 <code>equals</code>，则直接替换根节点的值。</li></ul></li><li><strong>树化节点</strong>：<ul><li>如果根节点是树形节点（即红黑树节点），则调用红黑树的插入方法将节点放入树中。</li></ul></li><li><strong>链表遍历</strong>：<ul><li>如果根节点是链表节点，则遍历链表：<ul><li>如果找到与待插入节点键 <code>equals</code> 的节点，则替换其值。</li><li>如果遍历到链表末尾仍未找到匹配的节点，则将新节点插入链表末尾。</li><li><strong>树化条件</strong>：<ul><li>如果链表长度（包括待插入节点）达到 8 且数组长度大于等于 64，则将链表转换为红黑树。</li><li>如果链表长度达到 8 但数组长度小于 64，则仅进行数组扩容，不进行树化。</li></ul></li></ul></li></ul></li></ul><h4 id="1-2-2-resize"><a href="#1-2-2-resize" class="headerlink" title="1.2.2 resize"></a>1.2.2 resize</h4><p><strong>HashMap 数组的长度始终为 2 的次幂，且扩容时长度加倍。这样设计的主要目的是为了方便扩容时的索引计算。</strong>以下为具体的扩容过程</p><h5 id="1-创建新数组"><a href="#1-创建新数组" class="headerlink" title="1 创建新数组"></a>1 <strong>创建新数组</strong></h5><ul><li>先创建一个长度为原数组 2 倍的新数组。</li></ul><h5 id="2-迁移数据"><a href="#2-迁移数据" class="headerlink" title="2 迁移数据"></a>2 <strong>迁移数据</strong></h5><ul><li><p>遍历原数组中的每个桶（bucket）：</p><ul><li><p><strong>如果桶为空或只有一个元素</strong>：</p><ul><li>直接计算该元素在新数组中的索引，并将其放入新数组。</li></ul></li><li><p><strong>如果桶中有链表结构</strong>：</p><ul><li><p>遍历链表中的每个节点（Node），计算其在新数组中的索引。</p></li><li><p>由于新数组长度是原数组的 2 倍，且长度始终为 2 的次幂，因此新索引的计算方法为：</p><pre class="line-numbers language-java"><code class="language-java">newIndex <span class="token operator">=</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>新索引的结果只有两种可能：</p><ul><li><strong>与原索引相同</strong>：如果 key 的哈希值在高一位为 0。</li><li><strong>等于原索引加上原数组长度</strong>：如果 key 的哈希值在高一位为 1。</li></ul></li><li><p>根据计算结果，将节点放入新数组的对应位置。</p></li></ul></li></ul></li></ul><h5 id="3-链表拆分"><a href="#3-链表拆分" class="headerlink" title="3 链表拆分"></a>3 <strong>链表拆分</strong></h5><ul><li>如果原桶中的链表被拆分为两个链表（一个保持原索引，另一个为原索引加上原数组长度），则分别将它们放入新数组的对应位置。</li></ul><h4 id="1-2-3-部分核心代码"><a href="#1-2-3-部分核心代码" class="headerlink" title="1.2.3 部分核心代码"></a>1.2.3 部分核心代码</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">final</span> V <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">,</span>             <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span>  Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> rootNode<span class="token punctuation">;</span> <span class="token keyword">int</span> tableLength<span class="token punctuation">,</span> index<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>tableLength <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 添加第一个元素</span>      tableLength <span class="token operator">=</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>rootNode <span class="token operator">=</span> tab<span class="token punctuation">[</span>index <span class="token operator">=</span> <span class="token punctuation">(</span>tableLength <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 数组上对于的索引为空，代表这个kv可以直接放到这</span>      tab<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">else</span> <span class="token punctuation">{</span>      Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span> K k<span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>rootNode<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>          <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> rootNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// bucket上的元素equals要放进来的kv，直接覆盖</span>          e <span class="token operator">=</span> rootNode<span class="token punctuation">;</span>      <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>rootNode <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// bucket上已经是红黑树结构了，直接存放为红黑树结构</span>          e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>rootNode<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 向链表的末尾添加</span>          <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> rootNode<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 到链表末尾了</span>                  rootNode<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">>=</span> TREEIFY_THRESHOLD <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// -1 for 1st</span>                  <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 链表的长度（算上bucket）已经大于等于了8，转换为红黑树</span>                      <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token punctuation">}</span>                  <span class="token keyword">break</span><span class="token punctuation">;</span>              <span class="token punctuation">}</span>              <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                  <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 遍历链表时有equals，直接替换</span>                  <span class="token keyword">break</span><span class="token punctuation">;</span>              <span class="token punctuation">}</span>              rootNode <span class="token operator">=</span> e<span class="token punctuation">;</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// existing mapping for key</span>          <span class="token comment" spellcheck="true">// e不为空，代表是覆盖的情况，不是新增</span>          V oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent <span class="token operator">||</span> oldValue <span class="token operator">==</span> null<span class="token punctuation">)</span>              e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>          <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token operator">++</span>modCount<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>size <span class="token operator">></span> threshold<span class="token punctuation">)</span>      <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span>evict<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * resize方法，只展示了部分核心代码 * 数组的初始化或扩容，扩容是加倍的 */</span><span class="token keyword">final</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldTab <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 旧数组存在元素</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> oldCap<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// bucket存在元素</span>                oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 这个bucket没有链表，只需要将它重新计算下在新数组的索引，并放入对于的bucket中</span>                    newTab<span class="token punctuation">[</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> <span class="token punctuation">(</span>newCap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 红黑树结构</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>e<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> newTab<span class="token punctuation">,</span> j<span class="token punctuation">,</span> oldCap<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// preserve order</span>                    <span class="token comment" spellcheck="true">/* 旧数组的桶在新数组的索引位的节点 */</span>                    <span class="token comment" spellcheck="true">// 索引大小没有变化</span>                    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> loHead <span class="token operator">=</span> null<span class="token punctuation">,</span> loTail <span class="token operator">=</span> null<span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 索引扩大了旧数组的长度（即新索引位：旧索引位+旧数组长度）</span>                    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> hiHead <span class="token operator">=</span> null<span class="token punctuation">,</span> hiTail <span class="token operator">=</span> null<span class="token punctuation">;</span>                    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">;</span>                    <span class="token keyword">do</span> <span class="token punctuation">{</span>                        next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// e.hash &amp; oldCap == 0 就代表e的hash值（转换为2进制）高一位为0，</span>                        <span class="token comment" spellcheck="true">// 与（新的容量-1）相与后，其在数组的索引位置不变</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> oldCap<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">==</span> null<span class="token punctuation">)</span>                                loHead <span class="token operator">=</span> e<span class="token punctuation">;</span>                            <span class="token keyword">else</span>                                loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>                            loTail <span class="token operator">=</span> e<span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 这里则高一位为1，与新的容量 &amp; 后，</span>                             <span class="token comment" spellcheck="true">// 其在新数组的索引位置会增加新容量的扩大值（即原容量的大小）</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">==</span> null<span class="token punctuation">)</span>                                hiHead <span class="token operator">=</span> e<span class="token punctuation">;</span>                            <span class="token keyword">else</span>                                hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>                            hiTail <span class="token operator">=</span> e<span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>                        newTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> loHead<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>                        newTab<span class="token punctuation">[</span>j <span class="token operator">+</span> oldCap<span class="token punctuation">]</span> <span class="token operator">=</span> hiHead<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> newTab<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-3-线程不安全"><a href="#1-3-线程不安全" class="headerlink" title="1.3 线程不安全"></a>1.3 线程不安全</h3><blockquote><ul><li>当两个线程同时put数据时，且被put的两个数据能定位到HashMap数组的相同那个bucket位置上，就可能产生一个覆盖掉另一个的可能，造成一个数据消失。</li><li>多个线程同时修改 HashMap的结构时（如插入、删除或扩容），可能会导致部分数据丢失。比如线程A插入，而线程B正在扩容，最终导致A线程插入的数据丢失</li><li>没有volatile或锁的同步机制，会导致一个线程的修改对另一个线程不可见</li></ul></blockquote><h2 id="2-LinkedHashMap"><a href="#2-LinkedHashMap" class="headerlink" title="2 LinkedHashMap"></a>2 LinkedHashMap</h2><p><code>LinkedHashMap</code> 是 <code>HashMap</code> 的子类，它不仅实现了 <code>Map</code> 接口，还具有排序功能。其排序行为由 <code>accessOrder</code> 字段控制</p><h3 id="2-1-核心字段"><a href="#2-1-核心字段" class="headerlink" title="2.1 核心字段"></a>2.1 核心字段</h3><ul><li><code>head</code>：链表的头节点，指向最早插入或访问的节点。</li><li><code>tail</code>：链表的尾节点，指向最近插入或访问的节点。</li><li><code>accessOrder</code>（默认 <code>false</code>）：<ul><li><code>false</code>：按照<strong>插入顺序排序</strong>，越晚插入的元素越排在链表末尾。</li><li><code>true</code>：按照<strong>访问顺序排序</strong>，最近访问的元素会被移动到链表末尾。<strong>可用于实现 LRU 缓存。</strong></li></ul></li></ul><h3 id="2-2-排序实现原理"><a href="#2-2-排序实现原理" class="headerlink" title="2.2 排序实现原理"></a>2.2 排序实现原理</h3><h4 id="2-2-1-双向链表"><a href="#2-2-1-双向链表" class="headerlink" title="2.2.1 双向链表"></a>2.2.1 双向链表</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 继承了HashMap.Node的Entry内部结构</span><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">HashMap<span class="token punctuation">.</span>Node</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 具有链表结构的Entry</span>    <span class="token comment" spellcheck="true">// 前驱节点和后继节点</span>    Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> before<span class="token punctuation">,</span> after<span class="token punctuation">;</span>    <span class="token function">Entry</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-2-添加元素"><a href="#2-2-2-添加元素" class="headerlink" title="2.2.2 添加元素"></a>2.2.2 添加元素</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 重写了HashMap的newNode方法，在构造新节点时将其添加到链表末尾</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token function">newNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将新节点链接到链表末尾</span>    <span class="token function">linkNodeLast</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> p<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-3-访问节点移动到末尾"><a href="#2-2-3-访问节点移动到末尾" class="headerlink" title="2.2.3 访问节点移动到末尾"></a>2.2.3 访问节点移动到末尾</h4><p>如果 <code>accessOrder</code> 为 <code>true</code>，<code>LinkedHashMap</code> 会在访问节点时（如调用 <code>get</code> 方法）触发 <code>afterNodeAccess</code> 方法，将最近访问的节点移动到链表末尾，基于此<strong>可以实现LRU缓存</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 重写的HashMap#afterNodeAccess方法，</span><span class="token keyword">void</span> <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    LinkedHashMap<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> last<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>accessOrder <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>last <span class="token operator">=</span> tail<span class="token punctuation">)</span> <span class="token operator">!=</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// accessOrder为true，e不为tail</span>        <span class="token comment" spellcheck="true">// 重排序当前元素，将当前节点设为新的tail（保持最近一次被访问的节点在最后面）</span>        LinkedHashMap<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p <span class="token operator">=</span>            <span class="token punctuation">(</span>LinkedHashMap<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>e<span class="token punctuation">,</span> b <span class="token operator">=</span> p<span class="token punctuation">.</span>before<span class="token punctuation">,</span> a <span class="token operator">=</span> p<span class="token punctuation">.</span>after<span class="token punctuation">;</span>        p<span class="token punctuation">.</span>after <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// e为head，更新头节点</span>            head <span class="token operator">=</span> a<span class="token punctuation">;</span>        <span class="token keyword">else</span>            b<span class="token punctuation">.</span>after <span class="token operator">=</span> a<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// e不为tail</span>            a<span class="token punctuation">.</span>before <span class="token operator">=</span> b<span class="token punctuation">;</span>        <span class="token keyword">else</span>            last <span class="token operator">=</span> b<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>last <span class="token operator">==</span> null<span class="token punctuation">)</span>            head <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            p<span class="token punctuation">.</span>before <span class="token operator">=</span> last<span class="token punctuation">;</span>            last<span class="token punctuation">.</span>after <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        tail <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token operator">++</span>modCount<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-ConcurrentHashMap"><a href="#3-ConcurrentHashMap" class="headerlink" title="3 ConcurrentHashMap"></a>3 ConcurrentHashMap</h2><p><code>ConcurrentHashMap</code> 是一个线程安全的 <code>Map</code> 实现，通过 **CAS 和 <strong>分段锁</strong> 机制实现高效的并发操作。其数据结构与 <code>HashMap</code> 类似，采用 <strong>数组 + 链表 + 红黑树</strong> 的形式：</p><ul><li>当链表长度超过 8 时，链表会转换为红黑树。</li><li>当红黑树节点数小于 6 时，红黑树会退化为链表。</li></ul><h3 id="3-1-put方法"><a href="#3-1-put方法" class="headerlink" title="3.1 put方法"></a>3.1 put方法</h3><p><strong>死循环put元素</strong>，直到操作成功才退出</p><ul><li>数组还没初始化，开始数组的初始化</li><li>数组的bucket还未被占用，CAS占用（成功了就break，失败了就代表已经被其他节点占用了，进行下一次循环进入其他if分支）</li><li><strong>当前桶为<code>ForwardingNode</code>，表示有线程正在进行扩容操作，则先帮助扩容，等扩容完毕在继续put</strong></li><li>bucket被占用，锁住根节点，开始构造到链表的为尾节点。添加到尾节点后，在判断当前链表长度是否超过8，否则就转换为红黑树</li></ul><h3 id="3-2-扩容（重点）"><a href="#3-2-扩容（重点）" class="headerlink" title="3.2 扩容（重点）"></a>3.2 扩容（重点）</h3><p>​核心是通过 <strong>多线程协作</strong> 和 <strong>分段迁移</strong> 的方式进行高效的数据迁移，同时尽量减少对读写操作的影响</p><h4 id="3-2-1-扩容触发时机"><a href="#3-2-1-扩容触发时机" class="headerlink" title="3.2.1 扩容触发时机"></a>3.2.1 扩容触发时机</h4><ul><li>当 <code>ConcurrentHashMap</code> 中的元素数量超过 <strong>阈值（threshold）</strong> 时触发</li><li>阈值计算公式：<code>阈值 = 数组长度 * 负载因子（loadFactor，默认 0.75）</code>。</li></ul><h4 id="3-2-2-具体步骤"><a href="#3-2-2-具体步骤" class="headerlink" title="3.2.2 具体步骤"></a>3.2.2 具体步骤</h4><ul><li><p>首先创建一个新的数据，为元素组大小的2倍。将其设置到nextTable字段</p></li><li><p>通过CAS设置transferIndex（初始设为旧数组的长度，即是从旧数组末尾开始向前遍历转移数据的）</p></li><li><p>每个线程通过CAS从transferIndex获取一段连续长度为stride（步长）的桶，stride计算如下</p><ul><li><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 计算步长：即扩容时每个线程每次最小处理的数组连续长度</span><span class="token comment" spellcheck="true">// cpu为1，则由这个线程全部处理；cpu数量大于1，每个核心负责的步长为 数组长度/(8 * cpu核数) ，不过如果计算出步长小于16，则会被设置为16。确保线程的工作量均衡</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>stride <span class="token operator">=</span> <span class="token punctuation">(</span>NCPU <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>n <span class="token operator">>>></span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">/</span> NCPU <span class="token operator">:</span> n<span class="token punctuation">)</span> <span class="token operator">&lt;</span> MIN_TRANSFER_STRIDE<span class="token punctuation">)</span><span class="token punctuation">{</span>  stride <span class="token operator">=</span> MIN_TRANSFER_STRIDE<span class="token punctuation">;</span><span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>开始迁移数据，到这一步了每个线程就只会迁移自己所负责的步长索引数据，不会冲突</p><ul><li>空桶：则放置一个 <code>ForwardingNode</code>，表示该桶已迁移</li><li>桶为<code>ForwardingNode</code>：当前桶已迁移。因为整体是从后向前迁移的，可推测当前线程负责的这段步长索引一定已处理完毕，即这段步长内这个桶后面的所有桶也都已经被处理完成了，需要重新计算它下一次该负责的新步长索引</li><li>桶未迁移：则操作加锁，对桶中的链表或红黑树进行迁移，迁移完成后，再将当前桶放置为<code>ForwardingNode</code>节点</li></ul></li><li><p>当最后一个线程迁移完毕后，则更新table为新数据和sizeCtl，表示扩容完成</p></li></ul><h4 id="3-2-3-相关思考"><a href="#3-2-3-相关思考" class="headerlink" title="3.2.3 相关思考"></a>3.2.3 相关思考</h4><ul><li><p>步长计算安全嘛？</p><blockquote><p>​安全，通过CAS设置公共变量transferIndex（初始值为table.length），同时该变量为volatile，它的变化能立马被其他线程感知到，可以保证每个线程处理的步长索引不会重复和交叉</p></blockquote></li><li><p>其他线程如何感知并帮助扩容？</p><blockquote><p>​通过判断桶节点为ForwardingNode，则表示正在扩容，此时这个线程则帮助扩容，计算自己需要处理的步长索引来转移数据到新数组中。每处理完一个桶也将其设为ForwardingNode节点</p></blockquote></li><li><p>get方法并没有加锁，如果桶已被转移怎么获取到数据？</p><blockquote><p>​首先扩容是读写分离的，扩容时不会对桶本身做任何修改（即不会修改Node的内部指针数据），所以如果拿到原桶数据，则能直接遍历获取数据。而如果拿到的是ForwardingNode，它本身也提供了find方法，会到新数组中去找到需要的数据</p></blockquote></li><li><p>扩容完成如何处理？</p><blockquote><p>​每个线程完成自己负责区间的迁移后，会更新<code>sizeCtl</code>字段中的扩容线程数计数，判断确定最后一个完成迁移的线程会将新数组赋值给table并重新计算<code>sizeCtl</code>的阈值</p></blockquote></li><li><p>最后需要注意，在操作数组中的桶时，都会获取这个桶节点的锁（put和resize等等修改方法），锁是相同的，所以不必担心某一个桶的相关数据被多个线程同时处理（put，resize等）</p></li></ul><h4 id="3-2-4-核心代码"><a href="#3-2-4-核心代码" class="headerlink" title="3.2.4 核心代码"></a>3.2.4 核心代码</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">,</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> nextTab<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">,</span> stride<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 计算步长：即扩容时每个线程每次最小处理的数组连续长度</span>    <span class="token comment" spellcheck="true">// cpu为1，则由这个线程全部处理；cpu数量大于1，每个核心负责的步长为 数组长度/(8 * cpu核数) ，不过如何计算出步长小于16，则会被设置为16。确保线程的工作量均衡</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>stride <span class="token operator">=</span> <span class="token punctuation">(</span>NCPU <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>n <span class="token operator">>>></span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">/</span> NCPU <span class="token operator">:</span> n<span class="token punctuation">)</span> <span class="token operator">&lt;</span> MIN_TRANSFER_STRIDE<span class="token punctuation">)</span>        stride <span class="token operator">=</span> MIN_TRANSFER_STRIDE<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// subdivide range</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nextTab <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// initiating</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// 创建新数组，2次幂便于扩容计算新索引位置</span>            Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> nt <span class="token operator">=</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span>n <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            nextTab <span class="token operator">=</span> nt<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// try to cope with OOME</span>            sizeCtl <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        nextTable <span class="token operator">=</span> nextTab<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 表示从数组末尾开始分配迁移任务</span>        transferIndex <span class="token operator">=</span> n<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> nextn <span class="token operator">=</span> nextTab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    ForwardingNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> fwd <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ForwardingNode</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">(</span>nextTab<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 当前线程是否需要继续在旧数组上截取一段桶来处理数据，默认是</span>    <span class="token keyword">boolean</span> advance <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 扩容完毕的标志</span>    <span class="token keyword">boolean</span> finishing <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// to ensure sweep before committing nextTab</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> bound <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// i 是当前线程正在处理的桶的索引，bound 是当前线程负责的迁移任务的起始索引（也就是在处理中则 i>bound）</span>        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> f<span class="token punctuation">;</span> <span class="token keyword">int</span> fh<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 检查当前线程负责的步长内的桶是否处理完毕。处理完毕，则选取下一段当前现场该处理的步长索引段</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>advance<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> nextIndex<span class="token punctuation">,</span> nextBound<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span>i <span class="token operator">>=</span> bound <span class="token operator">||</span> finishing<span class="token punctuation">)</span>                advance <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>nextIndex <span class="token operator">=</span> transferIndex<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                i <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                advance <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>U<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span>                     <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> TRANSFERINDEX<span class="token punctuation">,</span> nextIndex<span class="token punctuation">,</span>                      nextBound <span class="token operator">=</span> <span class="token punctuation">(</span>nextIndex <span class="token operator">></span> stride <span class="token operator">?</span>                                   nextIndex <span class="token operator">-</span> stride <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                bound <span class="token operator">=</span> nextBound<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// i初始化为旧数组最后一个索引位置</span>                i <span class="token operator">=</span> nextIndex <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>                advance <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> i <span class="token operator">>=</span> n <span class="token operator">||</span> i <span class="token operator">+</span> n <span class="token operator">>=</span> nextn<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 当前线程扩容完毕处理</span>            <span class="token keyword">int</span> sc<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>finishing<span class="token punctuation">)</span> <span class="token punctuation">{</span>                nextTable <span class="token operator">=</span> null<span class="token punctuation">;</span>                table <span class="token operator">=</span> nextTab<span class="token punctuation">;</span>                sizeCtl <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token punctuation">(</span>n <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>U<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> SIZECTL<span class="token punctuation">,</span> sc <span class="token operator">=</span> sizeCtl<span class="token punctuation">,</span> sc <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>sc <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token function">resizeStamp</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> RESIZE_STAMP_SHIFT<span class="token punctuation">)</span>                    <span class="token keyword">return</span><span class="token punctuation">;</span>                finishing <span class="token operator">=</span> advance <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                i <span class="token operator">=</span> n<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// recheck before commit</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>f <span class="token operator">=</span> <span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 空桶，CAS放置ForwardingNode，让其他线程可以感知到，以帮助扩容</span>            advance <span class="token operator">=</span> <span class="token function">casTabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> null<span class="token punctuation">,</span> fwd<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fh <span class="token operator">=</span> f<span class="token punctuation">.</span>hash<span class="token punctuation">)</span> <span class="token operator">==</span> MOVED<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 当前桶已被处理</span>            <span class="token comment" spellcheck="true">// 到这了就说明这段步长索引处理完毕，需要重新计算新步长索引</span>            advance <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// already processed</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 桶加锁，开始转移当前桶的链表或红黑树到新的数组里</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">==</span> f<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 获取成功，再次校验桶节点是否变化，未变才继续操作（避免被其他刚释放了这个锁的线程给修改了）</span>                    <span class="token comment" spellcheck="true">// 桶数据转移到新数组去，和HashMap类似计算新数组中的索引</span>                    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> ln<span class="token punctuation">,</span> hn<span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>fh <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">int</span> runBit <span class="token operator">=</span> fh <span class="token operator">&amp;</span> n<span class="token punctuation">;</span>                        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> lastRun <span class="token operator">=</span> f<span class="token punctuation">;</span>                        <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p <span class="token operator">=</span> f<span class="token punctuation">.</span>next<span class="token punctuation">;</span> p <span class="token operator">!=</span> null<span class="token punctuation">;</span> p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token keyword">int</span> b <span class="token operator">=</span> p<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> n<span class="token punctuation">;</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">!=</span> runBit<span class="token punctuation">)</span> <span class="token punctuation">{</span>                                runBit <span class="token operator">=</span> b<span class="token punctuation">;</span>                                lastRun <span class="token operator">=</span> p<span class="token punctuation">;</span>                            <span class="token punctuation">}</span>                        <span class="token punctuation">}</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>runBit <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            ln <span class="token operator">=</span> lastRun<span class="token punctuation">;</span>                            hn <span class="token operator">=</span> null<span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        <span class="token keyword">else</span> <span class="token punctuation">{</span>                            hn <span class="token operator">=</span> lastRun<span class="token punctuation">;</span>                            ln <span class="token operator">=</span> null<span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p <span class="token operator">=</span> f<span class="token punctuation">;</span> p <span class="token operator">!=</span> lastRun<span class="token punctuation">;</span> p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token keyword">int</span> ph <span class="token operator">=</span> p<span class="token punctuation">.</span>hash<span class="token punctuation">;</span> K pk <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">;</span> V pv <span class="token operator">=</span> p<span class="token punctuation">.</span>val<span class="token punctuation">;</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ph <span class="token operator">&amp;</span> n<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>                                ln <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">(</span>ph<span class="token punctuation">,</span> pk<span class="token punctuation">,</span> pv<span class="token punctuation">,</span> ln<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token keyword">else</span>                                hn <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">(</span>ph<span class="token punctuation">,</span> pk<span class="token punctuation">,</span> pv<span class="token punctuation">,</span> hn<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        <span class="token function">setTabAt</span><span class="token punctuation">(</span>nextTab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> ln<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token function">setTabAt</span><span class="token punctuation">(</span>nextTab<span class="token punctuation">,</span> i <span class="token operator">+</span> n<span class="token punctuation">,</span> hn<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 转移完后，旧数组的桶放置ForwardingNode，表示当前桶已处理完毕并表示为扩容中</span>                        <span class="token function">setTabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> fwd<span class="token punctuation">)</span><span class="token punctuation">;</span>                        advance <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token keyword">instanceof</span> <span class="token class-name">TreeBin</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        TreeBin<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> t <span class="token operator">=</span> <span class="token punctuation">(</span>TreeBin<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>f<span class="token punctuation">;</span>                        TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> lo <span class="token operator">=</span> null<span class="token punctuation">,</span> loTail <span class="token operator">=</span> null<span class="token punctuation">;</span>                        TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> hi <span class="token operator">=</span> null<span class="token punctuation">,</span> hiTail <span class="token operator">=</span> null<span class="token punctuation">;</span>                        <span class="token keyword">int</span> lc <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> hc <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                        <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> t<span class="token punctuation">.</span>first<span class="token punctuation">;</span> e <span class="token operator">!=</span> null<span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token keyword">int</span> h <span class="token operator">=</span> e<span class="token punctuation">.</span>hash<span class="token punctuation">;</span>                            TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span>                                <span class="token punctuation">(</span>h<span class="token punctuation">,</span> e<span class="token punctuation">.</span>key<span class="token punctuation">,</span> e<span class="token punctuation">.</span>val<span class="token punctuation">,</span> null<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>h <span class="token operator">&amp;</span> n<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>prev <span class="token operator">=</span> loTail<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>                                    lo <span class="token operator">=</span> p<span class="token punctuation">;</span>                                <span class="token keyword">else</span>                                    loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">;</span>                                loTail <span class="token operator">=</span> p<span class="token punctuation">;</span>                                <span class="token operator">++</span>lc<span class="token punctuation">;</span>                            <span class="token punctuation">}</span>                            <span class="token keyword">else</span> <span class="token punctuation">{</span>                                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>prev <span class="token operator">=</span> hiTail<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>                                    hi <span class="token operator">=</span> p<span class="token punctuation">;</span>                                <span class="token keyword">else</span>                                    hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">;</span>                                hiTail <span class="token operator">=</span> p<span class="token punctuation">;</span>                                <span class="token operator">++</span>hc<span class="token punctuation">;</span>                            <span class="token punctuation">}</span>                        <span class="token punctuation">}</span>                        ln <span class="token operator">=</span> <span class="token punctuation">(</span>lc <span class="token operator">&lt;=</span> UNTREEIFY_THRESHOLD<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">untreeify</span><span class="token punctuation">(</span>lo<span class="token punctuation">)</span> <span class="token operator">:</span>                            <span class="token punctuation">(</span>hc <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">TreeBin</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">(</span>lo<span class="token punctuation">)</span> <span class="token operator">:</span> t<span class="token punctuation">;</span>                        hn <span class="token operator">=</span> <span class="token punctuation">(</span>hc <span class="token operator">&lt;=</span> UNTREEIFY_THRESHOLD<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">untreeify</span><span class="token punctuation">(</span>hi<span class="token punctuation">)</span> <span class="token operator">:</span>                            <span class="token punctuation">(</span>lc <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">TreeBin</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">(</span>hi<span class="token punctuation">)</span> <span class="token operator">:</span> t<span class="token punctuation">;</span>                        <span class="token function">setTabAt</span><span class="token punctuation">(</span>nextTab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> ln<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token function">setTabAt</span><span class="token punctuation">(</span>nextTab<span class="token punctuation">,</span> i <span class="token operator">+</span> n<span class="token punctuation">,</span> hn<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 转移完后，旧数组的桶放置ForwardingNode，表示当前桶已处理完毕并表示为扩容中</span>                        <span class="token function">setTabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> fwd<span class="token punctuation">)</span><span class="token punctuation">;</span>                        advance <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4-为什么key和value不允许为null，而HashMap可以呢？"><a href="#3-4-为什么key和value不允许为null，而HashMap可以呢？" class="headerlink" title="3.4 为什么key和value不允许为null，而HashMap可以呢？"></a>3.4 为什么key和value不允许为null，而HashMap可以呢？</h3><blockquote><p>​<strong>ConcurrentHashMap如果允许key和value为null，会产生二义性</strong>。即不能确定map里本身没有这个数据，还是说有这个数据，但这个数据存的是null值。</p><p>​为什么HashMap可以允许呢？因为它不会产生二义性，使用<strong>HashMap设计用于单线程下，假设我们获取key为A的数据返回了null，之后还马上可以通过containsKey来判断到底是不存在A还是A就为null（因为是单线程，不用担心其他线程会修改数据）</strong></p><p>​但ConcurrentHashMap是线程安全的，也就是默认会在多线程下修改数据。假设ConcurrentHashMap支持设置null，这时线程A获取key为null的数据返回了null，此时我们不确定A在不在ConcurrentHashMap里，需要用containsKey来判断key为null是否存在于ConcurrentHashMap里。但多线程的情况下，B线程在A线程containsKey操作前添加了key为null的数据，导致A线程containsKey返回了true，导致和第一步预期不同（第一步可能是不存在key为null的数据）</p><p>​综上：<strong>ConcurrentHashMap，它是为并发而生的，它是要用在并发场景中的。假如允许使用 map.get(key)返回 null ，这时是没办法通过 map.containsKey来准确的检测，因为在检测过程中可能会被其他线程锁修改，而导致检测结果并不可靠。所以直接禁用了null，好处就是返回null一定能表示key不存在，而不是有其他的含义，让语义更明确了</strong></p><p>​所以这个设计选择反映了<strong>并发编程的一个重要原则：通过适当的限制来换取更好的可靠性和简单性</strong>。虽然失去了存储null值的能力，但换来了更清晰的语义和更好的并发安全性。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> jdk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Map </tag>
            
            <tag> ConcurrentHashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="/2020/02/07/git/"/>
      <url>/2020/02/07/git/</url>
      
        <content type="html"><![CDATA[<p>​Git常用命令总结</p><span id="more"></span><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="1-git-config"><a href="#1-git-config" class="headerlink" title="1 git config"></a>1 git config</h2><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># git查看配置</span><span class="token function">git</span> config --list<span class="token comment" spellcheck="true"># ================= 全局配置（保存在用户目录下的 ～/.gitconfig 文件中）======================</span><span class="token comment" spellcheck="true"># 设置全局用户名和邮箱（在 git commit 时记录为提交者信息））</span><span class="token function">git</span> config --global user.name  <span class="token string">"reef"</span><span class="token function">git</span> config --global user.email <span class="token string">"shanzhao.rd@gmail.com"</span><span class="token comment" spellcheck="true"># 设置全局代理（socks5 协议，端口号为 7890）</span><span class="token function">git</span> config --global http.proxy<span class="token operator">=</span>socks5://127.0.0.1:7890<span class="token function">git</span> config --global https.proxy<span class="token operator">=</span>socks5://127.0.0.1:7890<span class="token comment" spellcheck="true"># ================= 当前仓库单独配置（保存在当前仓库中 .git/config 文件中）======================</span><span class="token comment" spellcheck="true"># 设置仓库专属用户名和邮箱（覆盖全局设置）</span><span class="token function">git</span> config  user.name  <span class="token string">"reef"</span><span class="token function">git</span> config  user.email <span class="token string">"shanzhao.rd@gmail.com"</span><span class="token comment" spellcheck="true"># 设置当前仓库的代理（仅对该仓库生效）</span><span class="token function">git</span> config  http.proxy<span class="token operator">=</span>socks5://127.0.0.1:7890<span class="token function">git</span> config  https.proxy<span class="token operator">=</span>socks5://127.0.0.1:7890<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-初始化仓库"><a href="#2-初始化仓库" class="headerlink" title="2 初始化仓库"></a>2 初始化仓库</h2><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 将当前文件夹初始化为一个 Git 本地仓库</span><span class="token function">git</span> init<span class="token comment" spellcheck="true"># 将指定文件夹初始化为一个 Git 本地仓库</span><span class="token function">git</span> init <span class="token operator">&lt;</span>目录路径<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-本地仓库的操作"><a href="#3-本地仓库的操作" class="headerlink" title="3 本地仓库的操作"></a>3 本地仓库的操作</h2><h3 id="3-1-查看文件状态"><a href="#3-1-查看文件状态" class="headerlink" title="3.1 查看文件状态"></a>3.1 查看文件状态</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 可以查看分支名（branch）和文件的状态，如已修改（Modified），未跟踪的（untracked）,未修改的不会有提示</span><span class="token function">git</span> status<span class="token comment" spellcheck="true"># 简洁版的git status</span><span class="token comment" spellcheck="true"># 红色M 代表文件修改了但未加入暂存区</span><span class="token comment" spellcheck="true"># 绿色M 代表文件修改了并且已加入暂存区</span><span class="token comment" spellcheck="true"># ?? 代表未跟踪的，</span><span class="token comment" spellcheck="true"># A 代表文件已被加入到暂存区</span><span class="token function">git</span> status -s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-未暂存的文件添加到暂存区和解暂存"><a href="#3-2-未暂存的文件添加到暂存区和解暂存" class="headerlink" title="3.2 未暂存的文件添加到暂存区和解暂存"></a>3.2 未暂存的文件添加到暂存区和解暂存</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 将文件加入暂存区</span><span class="token function">git</span> add 文件名<span class="token comment" spellcheck="true"># 将暂存区的文件取消暂存</span><span class="token function">git</span> reset 文件名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-commit-暂存区文件的提交"><a href="#3-3-commit-暂存区文件的提交" class="headerlink" title="3.3 commit(暂存区文件的提交)"></a>3.3 commit(暂存区文件的提交)</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 不带文件名会提交暂存区所有的文件</span><span class="token function">git</span> commit -m <span class="token string">"提交的日志信息"</span><span class="token comment" spellcheck="true"># 提交全部暂存区文件，并打开一个编辑器，让你写入提交日志（'i':插入，'ESC':退出编辑，':wq':保存并退出）</span><span class="token function">git</span> commit<span class="token comment" spellcheck="true"># 该语句可将不是暂存区的文件直接commit，因为-a就代表提交到了暂存区。两步合为一步了</span><span class="token function">git</span> commit -a -m <span class="token string">"提交的日志信息"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4-已commit的文件删除"><a href="#3-4-已commit的文件删除" class="headerlink" title="3.4 已commit的文件删除"></a>3.4 已commit的文件删除</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 会放在暂存区，在commit之后就删除了。如果直接在文件夹中删除，则不会放在暂存区，要将其删除，就必须先add进暂存区，再commit</span><span class="token function">git</span> <span class="token function">rm</span> 文件名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="3-5-将文件添加至忽略列表"><a href="#3-5-将文件添加至忽略列表" class="headerlink" title="3.5 将文件添加至忽略列表"></a>3.5 将文件添加至忽略列表</h3><blockquote><p> 自动生成的文件，比如日志文件，class文件就不需要通过git提交，git一般只负责提交源代码。这种情况下，我们可以在<strong>工作区中创建一个.gitignore文件</strong>（文件名固定，可以在git命令行中用touch .gitignore语句创建）</p></blockquote><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 通配符（匹配任意）</span>*<span class="token comment" spellcheck="true"># 取反。比如!hello.class文件，git就不会忽略掉hello.class文件</span><span class="token operator">!</span><span class="token comment" spellcheck="true"># 忽略当前目录下的xxx文件</span>/xxx<span class="token comment" spellcheck="true"># 忽略当前目录下的doc文件夹下的所有</span>doc/<span class="token comment" spellcheck="true"># 忽略当前目录下的doc文件夹里的所有txt文件</span>doc/*.txt<span class="token comment" spellcheck="true"># 忽略当前目录下的doc文件里的所有文件夹里的class文件</span>doc/**/*.class<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-6-查看git操作日志"><a href="#3-6-查看git操作日志" class="headerlink" title="3.6 查看git操作日志"></a>3.6 查看git操作日志</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 因为日志太多，不会一次性全部显示，按回车会显示下面的，按Q会退出。</span><span class="token function">git</span> log<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="4-远程仓库的操作"><a href="#4-远程仓库的操作" class="headerlink" title="4. 远程仓库的操作"></a>4. 远程仓库的操作</h2><h3 id="4-1-remote"><a href="#4-1-remote" class="headerlink" title="4.1 remote"></a>4.1 remote</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 可以查看到本地关联的的远程仓库的别名（粗略查看）</span><span class="token function">git</span> remote<span class="token comment" spellcheck="true"># 显示远程仓库地址（详细点）</span><span class="token function">git</span> remote -v<span class="token comment" spellcheck="true"># 可查看更多信息（更详细）</span><span class="token function">git</span> remote show 远程仓库的别名<span class="token comment" spellcheck="true"># 添加(add)远程仓库（一个本地仓库可以添加多个远程仓库）</span><span class="token function">git</span> remote add 仓库别名 远程仓库的url<span class="token comment" spellcheck="true"># 删除本地仓库中配置的某个远程仓库别名及其对应的 URL（该命令不会影响到真正的远程仓库）</span><span class="token function">git</span> remote <span class="token function">rm</span> 远程仓库的别名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-2-clone"><a href="#4-2-clone" class="headerlink" title="4.2 clone"></a>4.2 clone</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 克隆远程仓库到此命令行文件夹下面</span><span class="token function">git</span> clone 远程仓库的url<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="4-3-fetch-pull"><a href="#4-3-fetch-pull" class="headerlink" title="4.3 fetch &amp; pull"></a>4.3 fetch &amp; pull</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 从远程仓库获取最新版本带本地仓库，不会合并(merge)。如果省略这两个参数，即别名为origin，分支为matser</span><span class="token function">git</span> fetch 仓库别名 远程仓库的branchName<span class="token comment" spellcheck="true"># 合并到本地仓库</span><span class="token function">git</span> merge origin/master<span class="token comment" spellcheck="true"># 从远程仓库获取最新版本带本地仓库，会合并(merge)。如果省略这两个参数，即别名为origin，分支为matser</span><span class="token function">git</span> pull 仓库别名 远程仓库的branchName<span class="token comment" spellcheck="true"># 用于合并本地和远程仓库之间没有共同历史的分支内容。（强制合并）</span><span class="token function">git</span> pull 仓库别名 远程仓库的branchName --allow-unrelated-histories<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-Git分支操作"><a href="#5-Git分支操作" class="headerlink" title="5 Git分支操作"></a>5 Git分支操作</h2><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 列出所有本地分支</span><span class="token function">git</span> branch<span class="token comment" spellcheck="true"># 列出所有远程分支</span><span class="token function">git</span> branch -r<span class="token comment" spellcheck="true"># 列出所有本地和远程的分支</span><span class="token function">git</span> branch -a<span class="token comment" spellcheck="true"># 查看所有本地分支，并可查看是否和远程分支建立映射关系</span><span class="token function">git</span> branch -v<span class="token comment" spellcheck="true"># 在本仓库中新建一个分支(在正在使用的分支下创建新的分支，新的分支将会复制正在使用的分支的所有内容进行初始化)</span><span class="token function">git</span> branch 新分支名<span class="token comment" spellcheck="true"># 切换到指定的分支下，前面会有*提示</span><span class="token function">git</span> checkout 已存在的分支名<span class="token comment" spellcheck="true"># 本地仓库分支推送到远程仓库</span><span class="token function">git</span> push 仓库别名<span class="token punctuation">(</span>shortname<span class="token punctuation">)</span> 本地仓库的分支名<span class="token punctuation">(</span>branchName<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 将指定的分支名的分支文件合并到正在使用的分支里（branchName -> 正在使用的分支）</span><span class="token function">git</span> merge 分支名<span class="token punctuation">(</span>branchName<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 根据分支名删除分支，未push的不能删除</span><span class="token function">git</span> branch -d 分支名<span class="token comment" spellcheck="true"># 根据分支名强力删除分支，未push的也能删除</span><span class="token function">git</span> branch -D 分支名<span class="token comment" spellcheck="true"># 删除远程仓库中的分支</span><span class="token function">git</span> push 远程仓库的别名 -d 分支名<span class="token comment" spellcheck="true"># oldName是当前分支名，newName是想改成的名</span><span class="token function">git</span> branch -m oldName newName<span class="token comment" spellcheck="true"># 本地更新远程仓库分支</span><span class="token function">git</span> remote update origin --prune<span class="token comment" spellcheck="true"># =========分支追踪（名字不同也可以）============</span><span class="token comment" spellcheck="true"># 在本地新建分支local-branchName，并和对应的远程分支remote-branchName做映射，最后再checkout并pull</span><span class="token function">git</span> checkout -b local-branchName origin/remote-branchName<span class="token comment" spellcheck="true"># 将本地分支local-branchName分支追踪远程分支origin/remote-branchName（建立映射关系）   </span><span class="token function">git</span> branch --set-upstream local-branchName origin/remote-branchName<span class="token comment" spellcheck="true"># 将当前分支跟踪远程分支origin/remote-branchName   </span><span class="token function">git</span> branch -u origin/remote-branchName<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-Git标签操作"><a href="#6-Git标签操作" class="headerlink" title="6 Git标签操作"></a>6 Git标签操作</h2><blockquote><p> 标签指的是某个分支的某个特定时间点的状态，记录了截止到当前时间的当前分支的全部内容。根据标签，我们可以很方便的切回到标签标记时的状态</p></blockquote><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 创建一个新标签</span><span class="token function">git</span> tag 新的标签名<span class="token comment" spellcheck="true"># 列出所有标签</span><span class="token function">git</span> tag<span class="token comment" spellcheck="true"># 查看tag的信息</span><span class="token function">git</span> show 标签名<span class="token comment" spellcheck="true"># 将指定的标签推送至远程仓库</span><span class="token function">git</span> push 仓库别名 标签名<span class="token comment" spellcheck="true"># 新建一个分支，根据标签名指向指定的标签</span><span class="token function">git</span> checkout -b 新的分支名 标签名<span class="token comment" spellcheck="true"># 删除本地仓库中指定的标签</span><span class="token function">git</span> tag -d 标签名<span class="token comment" spellcheck="true"># 删除远程仓库中指定的标签</span><span class="token function">git</span> push origin :refs/tags/标签名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="7-SSH（secure-shell）认证"><a href="#7-SSH（secure-shell）认证" class="headerlink" title="7 SSH（secure shell）认证"></a>7 SSH（secure shell）认证</h2><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 生成 SSH 密钥对的命令（由公钥和私钥组成，常用语SSH的连接和认证）</span>ssh-keygen -t rsa<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>上诉命令会生成两个文件，将公钥放在git远程仓库的ssh key里接可以使用ssh操作远程仓库了</p><ul><li><strong>~&#x2F;.ssh&#x2F;id_rsa：私钥，用于客户端身份认证，需保密，放在本地</strong></li><li><strong>~&#x2F;.ssh&#x2F;id_rsa.pub：公钥，可放在远程服务器上</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
